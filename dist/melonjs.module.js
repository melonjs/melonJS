/*!
 * melonJS Game Engine - v12.0.0
 * http://www.melonjs.org
 * melonjs is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * @copyright (C) 2011 - 2022 Olivier Biot
 */
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global$c =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();

var objectGetOwnPropertyDescriptor = {};

var fails$9 = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

var fails$8 = fails$9;

// Detect IE8's incomplete defineProperty implementation
var descriptors = !fails$8(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});

var fails$7 = fails$9;

var functionBindNative = !fails$7(function () {
  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});

var NATIVE_BIND$1 = functionBindNative;

var call$4 = Function.prototype.call;

var functionCall = NATIVE_BIND$1 ? call$4.bind(call$4) : function () {
  return call$4.apply(call$4, arguments);
};

var objectPropertyIsEnumerable = {};

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$1(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

var createPropertyDescriptor$2 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var NATIVE_BIND = functionBindNative;

var FunctionPrototype$1 = Function.prototype;
var bind = FunctionPrototype$1.bind;
var call$3 = FunctionPrototype$1.call;
var uncurryThis$b = NATIVE_BIND && bind.bind(call$3, call$3);

var functionUncurryThis = NATIVE_BIND ? function (fn) {
  return fn && uncurryThis$b(fn);
} : function (fn) {
  return fn && function () {
    return call$3.apply(fn, arguments);
  };
};

var uncurryThis$a = functionUncurryThis;

var toString$4 = uncurryThis$a({}.toString);
var stringSlice = uncurryThis$a(''.slice);

var classofRaw$1 = function (it) {
  return stringSlice(toString$4(it), 8, -1);
};

var uncurryThis$9 = functionUncurryThis;
var fails$6 = fails$9;
var classof$2 = classofRaw$1;

var $Object$3 = Object;
var split = uncurryThis$9(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails$6(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object$3('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof$2(it) == 'String' ? split(it, '') : $Object$3(it);
} : $Object$3;

var $TypeError$5 = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible$3 = function (it) {
  if (it == undefined) throw $TypeError$5("Can't call method on " + it);
  return it;
};

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = indexedObject;
var requireObjectCoercible$2 = requireObjectCoercible$3;

var toIndexedObject$3 = function (it) {
  return IndexedObject(requireObjectCoercible$2(it));
};

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
var isCallable$b = function (argument) {
  return typeof argument == 'function';
};

var isCallable$a = isCallable$b;

var isObject$5 = function (it) {
  return typeof it == 'object' ? it !== null : isCallable$a(it);
};

var global$b = global$c;
var isCallable$9 = isCallable$b;

var aFunction = function (argument) {
  return isCallable$9(argument) ? argument : undefined;
};

var getBuiltIn$3 = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global$b[namespace]) : global$b[namespace] && global$b[namespace][method];
};

var uncurryThis$8 = functionUncurryThis;

var objectIsPrototypeOf = uncurryThis$8({}.isPrototypeOf);

var getBuiltIn$2 = getBuiltIn$3;

var engineUserAgent = getBuiltIn$2('navigator', 'userAgent') || '';

var global$a = global$c;
var userAgent = engineUserAgent;

var process$1 = global$a.process;
var Deno = global$a.Deno;
var versions = process$1 && process$1.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version$1;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version$1 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version$1 && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version$1 = +match[1];
  }
}

var engineV8Version = version$1;

/* eslint-disable es-x/no-symbol -- required for testing */

var V8_VERSION = engineV8Version;
var fails$5 = fails$9;

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$5(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});

/* eslint-disable es-x/no-symbol -- required for testing */

var NATIVE_SYMBOL$1 = nativeSymbol;

var useSymbolAsUid = NATIVE_SYMBOL$1
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';

var getBuiltIn$1 = getBuiltIn$3;
var isCallable$8 = isCallable$b;
var isPrototypeOf = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;

var $Object$2 = Object;

var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn$1('Symbol');
  return isCallable$8($Symbol) && isPrototypeOf($Symbol.prototype, $Object$2(it));
};

var $String$2 = String;

var tryToString$1 = function (argument) {
  try {
    return $String$2(argument);
  } catch (error) {
    return 'Object';
  }
};

var isCallable$7 = isCallable$b;
var tryToString = tryToString$1;

var $TypeError$4 = TypeError;

// `Assert: IsCallable(argument) is true`
var aCallable$1 = function (argument) {
  if (isCallable$7(argument)) return argument;
  throw $TypeError$4(tryToString(argument) + ' is not a function');
};

var aCallable = aCallable$1;

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
var getMethod$1 = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};

var call$2 = functionCall;
var isCallable$6 = isCallable$b;
var isObject$4 = isObject$5;

var $TypeError$3 = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
var ordinaryToPrimitive$1 = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable$6(fn = input.toString) && !isObject$4(val = call$2(fn, input))) return val;
  if (isCallable$6(fn = input.valueOf) && !isObject$4(val = call$2(fn, input))) return val;
  if (pref !== 'string' && isCallable$6(fn = input.toString) && !isObject$4(val = call$2(fn, input))) return val;
  throw $TypeError$3("Can't convert object to primitive value");
};

var shared$3 = {exports: {}};

var global$9 = global$c;

// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty$1 = Object.defineProperty;

var defineGlobalProperty$3 = function (key, value) {
  try {
    defineProperty$1(global$9, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global$9[key] = value;
  } return value;
};

var global$8 = global$c;
var defineGlobalProperty$2 = defineGlobalProperty$3;

var SHARED = '__core-js_shared__';
var store$3 = global$8[SHARED] || defineGlobalProperty$2(SHARED, {});

var sharedStore = store$3;

var store$2 = sharedStore;

(shared$3.exports = function (key, value) {
  return store$2[key] || (store$2[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.23.3',
  mode: 'global',
  copyright: 'Â© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});

var requireObjectCoercible$1 = requireObjectCoercible$3;

var $Object$1 = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
var toObject$1 = function (argument) {
  return $Object$1(requireObjectCoercible$1(argument));
};

var uncurryThis$7 = functionUncurryThis;
var toObject = toObject$1;

var hasOwnProperty = uncurryThis$7({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es-x/no-object-hasown -- safe
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};

var uncurryThis$6 = functionUncurryThis;

var id = 0;
var postfix = Math.random();
var toString$3 = uncurryThis$6(1.0.toString);

var uid$2 = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$3(++id + postfix, 36);
};

var global$7 = global$c;
var shared$2 = shared$3.exports;
var hasOwn$6 = hasOwnProperty_1;
var uid$1 = uid$2;
var NATIVE_SYMBOL = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;

var WellKnownSymbolsStore = shared$2('wks');
var Symbol$1 = global$7.Symbol;
var symbolFor = Symbol$1 && Symbol$1['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;

var wellKnownSymbol$3 = function (name) {
  if (!hasOwn$6(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn$6(Symbol$1, name)) {
      WellKnownSymbolsStore[name] = Symbol$1[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  } return WellKnownSymbolsStore[name];
};

var call$1 = functionCall;
var isObject$3 = isObject$5;
var isSymbol$1 = isSymbol$2;
var getMethod = getMethod$1;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$2 = wellKnownSymbol$3;

var $TypeError$2 = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$2('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
var toPrimitive$1 = function (input, pref) {
  if (!isObject$3(input) || isSymbol$1(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call$1(exoticToPrim, input, pref);
    if (!isObject$3(result) || isSymbol$1(result)) return result;
    throw $TypeError$2("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};

var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
var toPropertyKey$2 = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};

var global$6 = global$c;
var isObject$2 = isObject$5;

var document$1 = global$6.document;
// typeof document.createElement is 'object' in old IE
var EXISTS$1 = isObject$2(document$1) && isObject$2(document$1.createElement);

var documentCreateElement = function (it) {
  return EXISTS$1 ? document$1.createElement(it) : {};
};

var DESCRIPTORS$6 = descriptors;
var fails$4 = fails$9;
var createElement = documentCreateElement;

// Thanks to IE8 for its funny defineProperty
var ie8DomDefine = !DESCRIPTORS$6 && !fails$4(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});

var DESCRIPTORS$5 = descriptors;
var call = functionCall;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var createPropertyDescriptor$1 = createPropertyDescriptor$2;
var toIndexedObject$2 = toIndexedObject$3;
var toPropertyKey$1 = toPropertyKey$2;
var hasOwn$5 = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;

// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$5 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$2(O);
  P = toPropertyKey$1(P);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$1(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn$5(O, P)) return createPropertyDescriptor$1(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};

var objectDefineProperty = {};

var DESCRIPTORS$4 = descriptors;
var fails$3 = fails$9;

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
var v8PrototypeDefineBug = DESCRIPTORS$4 && fails$3(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});

var isObject$1 = isObject$5;

var $String$1 = String;
var $TypeError$1 = TypeError;

// `Assert: Type(argument) is Object`
var anObject$2 = function (argument) {
  if (isObject$1(argument)) return argument;
  throw $TypeError$1($String$1(argument) + ' is not an object');
};

var DESCRIPTORS$3 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var anObject$1 = anObject$2;
var toPropertyKey = toPropertyKey$2;

var $TypeError = TypeError;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE$1 = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
objectDefineProperty.f = DESCRIPTORS$3 ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject$1(O);
  P = toPropertyKey(P);
  anObject$1(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject$1(O);
  P = toPropertyKey(P);
  anObject$1(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var DESCRIPTORS$2 = descriptors;
var definePropertyModule$2 = objectDefineProperty;
var createPropertyDescriptor = createPropertyDescriptor$2;

var createNonEnumerableProperty$2 = DESCRIPTORS$2 ? function (object, key, value) {
  return definePropertyModule$2.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var makeBuiltIn$2 = {exports: {}};

var DESCRIPTORS$1 = descriptors;
var hasOwn$4 = hasOwnProperty_1;

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS$1 && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn$4(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$1 || (DESCRIPTORS$1 && getDescriptor(FunctionPrototype, 'name').configurable));

var functionName = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};

var uncurryThis$5 = functionUncurryThis;
var isCallable$5 = isCallable$b;
var store$1 = sharedStore;

var functionToString = uncurryThis$5(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable$5(store$1.inspectSource)) {
  store$1.inspectSource = function (it) {
    return functionToString(it);
  };
}

var inspectSource$2 = store$1.inspectSource;

var global$5 = global$c;
var isCallable$4 = isCallable$b;
var inspectSource$1 = inspectSource$2;

var WeakMap$1 = global$5.WeakMap;

var nativeWeakMap = isCallable$4(WeakMap$1) && /native code/.test(inspectSource$1(WeakMap$1));

var shared$1 = shared$3.exports;
var uid = uid$2;

var keys = shared$1('keys');

var sharedKey$1 = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

var hiddenKeys$3 = {};

var NATIVE_WEAK_MAP = nativeWeakMap;
var global$4 = global$c;
var uncurryThis$4 = functionUncurryThis;
var isObject = isObject$5;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$2;
var hasOwn$3 = hasOwnProperty_1;
var shared = sharedStore;
var sharedKey = sharedKey$1;
var hiddenKeys$2 = hiddenKeys$3;

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError$1 = global$4.TypeError;
var WeakMap = global$4.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError$1('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = uncurryThis$4(store.get);
  var wmhas = uncurryThis$4(store.has);
  var wmset = uncurryThis$4(store.set);
  set = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys$2[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn$3(it, STATE)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$1(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn$3(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn$3(it, STATE);
  };
}

var internalState = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

var fails$2 = fails$9;
var isCallable$3 = isCallable$b;
var hasOwn$2 = hasOwnProperty_1;
var DESCRIPTORS = descriptors;
var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
var inspectSource = inspectSource$2;
var InternalStateModule = internalState;

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails$2(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {
  if (String(name).slice(0, 7) === 'Symbol(') {
    name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn$2(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$2(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn$2(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn$2(state, 'source')) {
    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn$1(function toString() {
  return isCallable$3(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');

var isCallable$2 = isCallable$b;
var definePropertyModule$1 = objectDefineProperty;
var makeBuiltIn = makeBuiltIn$2.exports;
var defineGlobalProperty$1 = defineGlobalProperty$3;

var defineBuiltIn$1 = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable$2(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule$1.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};

var objectGetOwnPropertyNames = {};

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es-x/no-math-trunc -- safe
var mathTrunc = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};

var trunc = mathTrunc;

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
var toIntegerOrInfinity$2 = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};

var toIntegerOrInfinity$1 = toIntegerOrInfinity$2;

var max = Math.max;
var min$1 = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex$1 = function (index, length) {
  var integer = toIntegerOrInfinity$1(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
};

var toIntegerOrInfinity = toIntegerOrInfinity$2;

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
var toLength$1 = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var toLength = toLength$1;

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
var lengthOfArrayLike$1 = function (obj) {
  return toLength(obj.length);
};

var toIndexedObject$1 = toIndexedObject$3;
var toAbsoluteIndex = toAbsoluteIndex$1;
var lengthOfArrayLike = lengthOfArrayLike$1;

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod$1 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$1($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$1(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$1(false)
};

var uncurryThis$3 = functionUncurryThis;
var hasOwn$1 = hasOwnProperty_1;
var toIndexedObject = toIndexedObject$3;
var indexOf = arrayIncludes.indexOf;
var hiddenKeys$1 = hiddenKeys$3;

var push = uncurryThis$3([].push);

var objectKeysInternal = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn$1(hiddenKeys$1, key) && hasOwn$1(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn$1(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};

// IE8- don't enum bug keys
var enumBugKeys$1 = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];

var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$1;

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};

var objectGetOwnPropertySymbols = {};

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

var getBuiltIn = getBuiltIn$3;
var uncurryThis$2 = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject = anObject$2;

var concat = uncurryThis$2([].concat);

// all object keys, includes non-enumerable and symbols
var ownKeys$1 = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};

var hasOwn = hasOwnProperty_1;
var ownKeys = ownKeys$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule = objectDefineProperty;

var copyConstructorProperties$1 = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};

var fails$1 = fails$9;
var isCallable$1 = isCallable$b;

var replacement = /#|\.prototype\./;

var isForced$1 = function (feature, detection) {
  var value = data$1[normalize$1(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable$1(detection) ? fails$1(detection)
    : !!detection;
};

var normalize$1 = isForced$1.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data$1 = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = 'N';
var POLYFILL = isForced$1.POLYFILL = 'P';

var isForced_1 = isForced$1;

var global$3 = global$c;
var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty = createNonEnumerableProperty$2;
var defineBuiltIn = defineBuiltIn$1;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced = isForced_1;

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$3;
  } else if (STATIC) {
    target = global$3[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$3[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};

var $$4 = _export;
var global$2 = global$c;

// `globalThis` object
// https://tc39.es/ecma262/#sec-globalthis
$$4({ global: true }, {
  globalThis: global$2
});

var wellKnownSymbol$1 = wellKnownSymbol$3;

var TO_STRING_TAG$1 = wellKnownSymbol$1('toStringTag');
var test = {};

test[TO_STRING_TAG$1] = 'z';

var toStringTagSupport = String(test) === '[object z]';

var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var isCallable = isCallable$b;
var classofRaw = classofRaw$1;
var wellKnownSymbol = wellKnownSymbol$3;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
var classof$1 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};

var classof = classof$1;

var $String = String;

var toString$2 = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};

// a string of all valid unicode whitespaces
var whitespaces$2 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var uncurryThis$1 = functionUncurryThis;
var requireObjectCoercible = requireObjectCoercible$3;
var toString$1 = toString$2;
var whitespaces$1 = whitespaces$2;

var replace = uncurryThis$1(''.replace);
var whitespace = '[' + whitespaces$1 + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString$1(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};

var PROPER_FUNCTION_NAME = functionName.PROPER;
var fails = fails$9;
var whitespaces = whitespaces$2;

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
var stringTrimForced = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]()
      || non[METHOD_NAME]() !== non
      || (PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME);
  });
};

var $trimStart = stringTrim.start;
var forcedStringTrimMethod$1 = stringTrimForced;

// `String.prototype.{ trimStart, trimLeft }` method
// https://tc39.es/ecma262/#sec-string.prototype.trimstart
// https://tc39.es/ecma262/#String.prototype.trimleft
var stringTrimStart = forcedStringTrimMethod$1('trimStart') ? function trimStart() {
  return $trimStart(this);
// eslint-disable-next-line es-x/no-string-prototype-trimstart-trimend -- safe
} : ''.trimStart;

var $$3 = _export;
var trimStart$1 = stringTrimStart;

// `String.prototype.trimLeft` method
// https://tc39.es/ecma262/#sec-string.prototype.trimleft
// eslint-disable-next-line es-x/no-string-prototype-trimleft-trimright -- safe
$$3({ target: 'String', proto: true, name: 'trimStart', forced: ''.trimLeft !== trimStart$1 }, {
  trimLeft: trimStart$1
});

// TODO: Remove this line from `core-js@4`

var $$2 = _export;
var trimStart = stringTrimStart;

// `String.prototype.trimStart` method
// https://tc39.es/ecma262/#sec-string.prototype.trimstart
// eslint-disable-next-line es-x/no-string-prototype-trimstart-trimend -- safe
$$2({ target: 'String', proto: true, name: 'trimStart', forced: ''.trimStart !== trimStart }, {
  trimStart: trimStart
});

var global$1 = global$c;
var uncurryThis = functionUncurryThis;

var entryUnbind$2 = function (CONSTRUCTOR, METHOD) {
  return uncurryThis(global$1[CONSTRUCTOR].prototype[METHOD]);
};

var entryUnbind$1 = entryUnbind$2;

entryUnbind$1('String', 'trimLeft');

var $trimEnd = stringTrim.end;
var forcedStringTrimMethod = stringTrimForced;

// `String.prototype.{ trimEnd, trimRight }` method
// https://tc39.es/ecma262/#sec-string.prototype.trimend
// https://tc39.es/ecma262/#String.prototype.trimright
var stringTrimEnd = forcedStringTrimMethod('trimEnd') ? function trimEnd() {
  return $trimEnd(this);
// eslint-disable-next-line es-x/no-string-prototype-trimstart-trimend -- safe
} : ''.trimEnd;

var $$1 = _export;
var trimEnd$1 = stringTrimEnd;

// `String.prototype.trimRight` method
// https://tc39.es/ecma262/#sec-string.prototype.trimend
// eslint-disable-next-line es-x/no-string-prototype-trimleft-trimright -- safe
$$1({ target: 'String', proto: true, name: 'trimEnd', forced: ''.trimRight !== trimEnd$1 }, {
  trimRight: trimEnd$1
});

// TODO: Remove this line from `core-js@4`

var $ = _export;
var trimEnd = stringTrimEnd;

// `String.prototype.trimEnd` method
// https://tc39.es/ecma262/#sec-string.prototype.trimend
// eslint-disable-next-line es-x/no-string-prototype-trimstart-trimend -- safe
$({ target: 'String', proto: true, name: 'trimEnd', forced: ''.trimEnd !== trimEnd }, {
  trimEnd: trimEnd
});

var entryUnbind = entryUnbind$2;

entryUnbind('String', 'trimRight');

if (typeof globalThis !== "undefined") {
    if (typeof globalThis.console === "undefined") {
        globalThis.console = {};
        globalThis.console.log = function() {};
        globalThis.console.assert = function() {};
        globalThis.console.warn = function() {};
        globalThis.console.error = function() {
            alert(Array.prototype.slice.call(arguments).join(", "));
        };
    }
}

if ("performance" in globalThis === false) {
    globalThis.performance = {};
}

Date.now = (Date.now || function () {  // thanks IE8
    return new Date().getTime();
});

if ("now" in globalThis.performance === false) {

    var nowOffset = Date.now();

    if (performance.timing && performance.timing.navigationStart) {
      nowOffset = performance.timing.navigationStart;
    }

    globalThis.performance.now = function now() {
      return Date.now() - nowOffset;
  };
}

/**
 * a collection of string utility functions
 * @namespace utils.string
 */

/**
 * converts the first character of the given string to uppercase
 * @public
 * @memberof utils.string
 * @name capitalize
 * @param {string} str the string to be capitalized
 * @returns {string} the capitalized string
 */
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
/**
 * returns true if the given string contains a numeric integer or float value
 * @public
 * @memberof utils.string
 * @name isNumeric
 * @param {string} str the string to be tested
 * @returns {boolean} true if string contains only digits
 */
function isNumeric(str) {
    if (typeof str === "string") {
        str = str.trim();
    }
    return !isNaN(str) && /[+-]?([0-9]*[.])?[0-9]+/.test(str);
}
/**
 * returns true if the given string contains a true or false
 * @public
 * @memberof utils.string
 * @name isBoolean
 * @param {string} str the string to be tested
 * @returns {boolean} true if the string is either true or false
 */
function isBoolean(str) {
    var trimmed = str.trim();
    return (trimmed === "true") || (trimmed === "false");
}
/**
 * convert a string to the corresponding hexadecimal value
 * @public
 * @memberof utils.string
 * @name toHex
 * @param {string} str the string to be converted
 * @returns {string} the converted hexadecimal value
 */
function toHex$1(str) {
    var res = "", c = 0;
    while (c < str.length) {
        res += str.charCodeAt(c++).toString(16);
    }
    return res;
}

var stringUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	capitalize: capitalize,
	isNumeric: isNumeric,
	isBoolean: isBoolean,
	toHex: toHex$1
});

/**
 * a collection of utility functons to ease porting between different user agents.
 * @namespace utils.agent
 */

/**
 * Known agent vendors
 * @ignore
 */
const vendors$1 = [ "ms", "MS", "moz", "webkit", "o" ];

/**
 * Get a vendor-prefixed property
 * @public
 * @name prefixed
 * @param {string} name Property name
 * @param {object} [obj=globalThis] Object or element reference to access
 * @returns {string} Value of property
 * @memberof utils.agent
 */
function prefixed(name, obj) {
    obj = obj || globalThis;
    if (name in obj) {
        return obj[name];
    }

    var uc_name = capitalize(name);

    var result;
    vendors$1.some(function (vendor) {
        var name = vendor + uc_name;
        return (result = (name in obj) ? obj[name] : undefined);
    });
    return result;
}
/**
 * Set a vendor-prefixed property
 * @public
 * @name setPrefixed
 * @param {string} name Property name
 * @param {string} value Property value
 * @param {object} [obj=globalThis] Object or element reference to access
 * @returns {boolean} true if one of the vendor-prefixed property was found
 * @memberof utils.agent
 */
function setPrefixed(name, value, obj) {
    obj = obj || globalThis;
    if (name in obj) {
        obj[name] = value;
        return;
    }

    var uc_name = capitalize(name);

    vendors$1.some(function (vendor) {
        var name = vendor + uc_name;
        if (name in obj) {
            obj[name] = value;
            return true;
        }
    });

    return false;
}

var agentUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	prefixed: prefixed,
	setPrefixed: setPrefixed
});

/**
 * a collection of math utility functions
 * @namespace Math
 */

/**
 * constant to convert from degrees to radians
 * @public
 * @type {number}
 * @name DEG_TO_RAD
 * @memberof Math
 */
const DEG_TO_RAD = Math.PI / 180.0;

/**
 * constant to convert from radians to degrees
 * @public
 * @type {number}
 * @name RAD_TO_DEG
 * @memberof Math
 */
const RAD_TO_DEG = 180.0 / Math.PI;

/**
 * constant equals to 2 times pi
 * @public
 * @type {number}
 * @name TAU
 * @memberof Math
 */
const TAU = Math.PI * 2;

/**
 * constant equals to half pi
 * @public
 * @type {number}
 * @name ETA
 * @memberof Math
 */
const ETA = Math.PI * 0.5;

/**
 * the difference between 1 and the smallest floating point number greater than 1
 * @public
 * @type {number}
 * @name EPSILON
 * @memberof Math
 */
const EPSILON = 0.000001;

/**
 * returns true if the given value is a power of two
 * @public
 * @memberof Math
 * @name isPowerOfTwo
 * @param {number} val
 * @returns {boolean}
 */
function isPowerOfTwo(val) {
    return (val & (val - 1)) === 0;
}
/**
 * returns the next power of two for the given value
 * @public
 * @memberof Math
 * @name nextPowerOfTwo
 * @param {number} val
 * @returns {boolean}
 */
function nextPowerOfTwo(val) {
    val --;
    val |= val >> 1;
    val |= val >> 2;
    val |= val >> 4;
    val |= val >> 8;
    val |= val >> 16;
    val ++;
    return val;
}
/**
 * Converts an angle in degrees to an angle in radians
 * @public
 * @memberof Math
 * @name degToRad
 * @param {number} angle angle in degrees
 * @returns {number} corresponding angle in radians
 * @example
 * // convert a specific angle
 * me.Math.degToRad(60); // return 1.0471...
 */
function degToRad(angle) {
    return angle * DEG_TO_RAD;
}
/**
 * Converts an angle in radians to an angle in degrees.
 * @public
 * @memberof Math
 * @name radToDeg
 * @param {number} radians angle in radians
 * @returns {number} corresponding angle in degrees
 * @example
 * // convert a specific angle
 * me.Math.radToDeg(1.0471975511965976); // return 60
 */
function radToDeg(radians) {
    return radians * RAD_TO_DEG;
}
/**
 * clamp the given value
 * @public
 * @memberof Math
 * @name clamp
 * @param {number} val the value to clamp
 * @param {number} low lower limit
 * @param {number} high higher limit
 * @returns {number} clamped value
 */
function clamp(val, low, high) {
    return val < low ? low : val > high ? high : +val;
}
/**
 * return a random integer between min (included) and max (excluded)
 * @public
 * @memberof Math
 * @name random
 * @param {number} min minimum value.
 * @param {number} max maximum value.
 * @returns {number} random value
 * @example
 * // Print a random number; one of 5, 6, 7, 8, 9
 * console.log(me.Math.random(5, 10) );
 */
function random$1(min, max) {
    return (~~(Math.random() * (max - min)) + min);
}
/**
 * return a random float between min, max (exclusive)
 * @public
 * @memberof Math
 * @name randomFloat
 * @param {number} min minimum value.
 * @param {number} max maximum value.
 * @returns {number} random value
 * @example
 * // Print a random number; one of 5, 6, 7, 8, 9
 * console.log(me.Math.randomFloat(5, 10) );
 */
function randomFloat(min, max) {
    return (Math.random() * (max - min)) + min;
}
/**
 * return a weighted random between min, max (exclusive)
 * @public
 * @memberof Math
 * @name weightedRandom
 * @param {number} min minimum value.
 * @param {number} max maximum value.
 * @returns {number} random value
 * @example
 * // Print a random number; one of 5, 6, 7, 8, 9
 * console.log(me.Math.weightedRandom(5, 10) );
 */
function weightedRandom$1(min, max) {
    return (~~(Math.pow(Math.random(), 2) * (max - min)) + min);
}
/**
 * round a value to the specified number of digit
 * @public
 * @memberof Math
 * @name round
 * @param {number} num value to be rounded.
 * @param {number} [dec=0] number of decimal digit to be rounded to.
 * @returns {number} rounded value
 * @example
 * // round a specific value to 2 digits
 * me.Math.round(10.33333, 2); // return 10.33
 */
function round(num, dec = 0) {
    // if only one argument use the object value
    var powres = Math.pow(10, dec);
    return (~~(0.5 + num * powres) / powres);
}
/**
 * check if the given value is close to the expected one
 * @public
 * @memberof Math
 * @name toBeCloseTo
 * @param {number} expected value to be compared with.
 * @param {number} actual actual value to compare
 * @param {number} [precision=2] float precision for the comparison
 * @returns {boolean} if close to
 * @example
 * // test if the given value is close to 10
 * if (me.Math.toBeCloseTo(10, value)) {
 *     // do something
 * }
 */
function toBeCloseTo(expected, actual, precision = 2) {
    return Math.abs(expected - actual) < (Math.pow(10, -precision) / 2);
}

var math = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DEG_TO_RAD: DEG_TO_RAD,
	RAD_TO_DEG: RAD_TO_DEG,
	TAU: TAU,
	ETA: ETA,
	EPSILON: EPSILON,
	isPowerOfTwo: isPowerOfTwo,
	nextPowerOfTwo: nextPowerOfTwo,
	degToRad: degToRad,
	radToDeg: radToDeg,
	clamp: clamp,
	random: random$1,
	randomFloat: randomFloat,
	weightedRandom: weightedRandom$1,
	round: round,
	toBeCloseTo: toBeCloseTo
});

/**
 * a collection of array utility functions
 * @namespace utils.array
 */

/**
 * Remove the specified object from the given Array
 * @public
 * @memberof utils.array
 * @name remove
 * @param {Array} arr array from which to remove an object
 * @param {object} obj to be removed
 * @returns {Array} the modified Array
 * var arr = [ "foo", "bar", "baz" ];
 * // remove "foo" from the array
 * me.utils.array.remove(arr, "foo");
 */
function remove(arr, obj) {
    var i = Array.prototype.indexOf.call(arr, obj);
    if (i !== -1) {
        Array.prototype.splice.call(arr, i, 1);
    }
    return arr;
}
/**
 * return a random array element
 * @public
 * @memberof utils.array
 * @name random
 * @param {Array} arr array to pick a element
 * @returns {any} random member of array
 * @example
 * // Select a random array element
 * var arr = [ "foo", "bar", "baz" ];
 * console.log(me.utils.array.random(arr));
 */
function random(arr) {
    return arr[random$1(0, arr.length)];
}
/**
 * return a weighted random array element, favoring the earlier entries
 * @public
 * @memberof utils.array
 * @name weightedRandom
 * @param {Array} arr array to pick a element
 * @returns {any} random member of array
 */
function weightedRandom(arr) {
    return arr[weightedRandom$1(0, arr.length)];
}

var arrayUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	remove: remove,
	random: random,
	weightedRandom: weightedRandom
});

/**
 * a collection of file utility functions
 * @namespace utils.file
 */

// regexp to deal with file name & path
const REMOVE_PATH = /^.*(\\|\/|\:)/;
const REMOVE_EXT = /\.[^\.]*$/;


/**
 * return the base name of the file without path info
 * @public
 * @memberof utils.file
 * @name getBasename
 * @param  {string} path path containing the filename
 * @returns {string} the base name without path information.
 */
function getBasename(path) {
    return path.replace(REMOVE_PATH, "").replace(REMOVE_EXT, "");
}
/**
 * return the extension of the file in the given path
 * @public
 * @memberof utils.file
 * @name getExtension
 * @param  {string} path path containing the filename
 * @returns {string} filename extension.
 */
function getExtension(path) {
    return path.substring(path.lastIndexOf(".") + 1, path.length);
}

var fileUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	getBasename: getBasename,
	getExtension: getExtension
});

/**
 * a collection of utility functions
 * @namespace utils.function
 */

/**
 * Executes a function as soon as the interpreter is idle (stack empty).
 * @public
 * @memberof utils.function
 * @name defer
 * @param {Function} func The function to be deferred.
 * @param {object} thisArg The value to be passed as the this parameter to the target function when the deferred function is called
 * @param {...*} args Optional additional arguments to carry for the function.
 * @returns {number} id that can be used to clear the deferred function using
 * clearTimeout
 * @example
 * // execute myFunc() when the stack is empty,
 * // with the current context and [1, 2, 3] as parameter
 * me.utils.function.defer(myFunc, this, 1, 2, 3);
 */
function defer(func, thisArg, ...args) {
    return setTimeout(func.bind(thisArg), 0.01, ...args);
}
/**
 * returns a function that, when invoked will only be triggered at most
 * once during a given window of time
 * @public
 * @memberof utils.function
 * @name throttle
 * @param {Function} fn the function to be throttled.
 * @param {number} delay The delay in ms
 * @param {no_trailing} no_trailing disable the execution on the trailing edge
 * @returns {Function} the function that will be throttled
 */
function throttle(fn, delay, no_trailing) {
    var last = globalThis.performance.now(), deferTimer;
    // `no_trailing` defaults to false.
    if (typeof no_trailing !== "boolean") {
        no_trailing = false;
    }
    return function () {
        var now = globalThis.performance.now();
        var elasped = now - last;
        var args = arguments;
        if (elasped < delay) {
            if (no_trailing === false) {
                // hold on to it
                clearTimeout(deferTimer);
                deferTimer = setTimeout(function () {
                    last = now;
                    return fn.apply(null, args);
                }, elasped);
            }
        }
        else {
            last = now;
            return fn.apply(null, args);
        }
    };
}

var fnUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	defer: defer,
	throttle: throttle
});

/**
 * @classdesc
 * Object pooling - a technique that might speed up your game if used properly.<br>
 * If some of your classes will be instantiated and removed a lot at a time, it is a
 * good idea to add the class to this object pool. A separate pool for that class
 * will be created, which will reuse objects of the class. That way they won't be instantiated
 * each time you need a new one (slowing your game), but stored into that pool and taking one
 * already instantiated when you need it.<br><br>
 * This technique is also used by the engine to instantiate objects defined in the map,
 * which means, that on level loading the engine will try to instantiate every object
 * found in the map, based on the user defined name in each Object Properties<br>
 * <img src="images/object_properties.png"/><br>
 * @see {@link pool} the default global instance of ObjectPool
 */
class ObjectPool {

    constructor() {
        this.objectClass = {};
        this.instance_counter = 0;
    }

    /**
     * register an object to the pool. <br>
     * Pooling must be set to true if more than one such objects will be created. <br>
     * (Note: for an object to be poolable, it must implements a `onResetEvent` method)
     * @param {string} className as defined in the Name field of the Object Properties (in Tiled)
     * @param {object} classObj corresponding Class to be instantiated
     * @param {boolean} [recycling=false] enables object recycling for the specified class
     * @example
     * // implement CherryEntity
     * class CherryEntity extends Spritesheet {
     *    onResetEvent() {
     *        // reset object mutable properties
     *        this.lifeBar = 100;
     *    }
     * };
     * // add our users defined entities in the object pool and enable object recycling
     * me.pool.register("cherryentity", CherryEntity, true);
     */
    register(className, classObj, recycling = false) {
         if (typeof (classObj) !== "undefined") {
             this.objectClass[className] = {
                 "class" : classObj,
                 "pool" : (recycling ? [] : undefined)
             };
         } else {
             throw new Error("Cannot register object '" + className + "', invalid class");
         }
     }

    /**
     * Pull a new instance of the requested object (if added into the object pool)
     * @param {string} name as used in {@link pool.register}
     * @param {object} [...arguments] arguments to be passed when instantiating/reinitializing the object
     * @returns {object} the instance of the requested object
     * @example
     * me.pool.register("bullet", BulletEntity, true);
     * me.pool.register("enemy", EnemyEntity, true);
     * // ...
     * // when we need to manually create a new bullet:
     * var bullet = me.pool.pull("bullet", x, y, direction);
     * // ...
     * // params aren't a fixed number
     * // when we need new enemy we can add more params, that the object construct requires:
     * var enemy = me.pool.pull("enemy", x, y, direction, speed, power, life);
     * // ...
     * // when we want to destroy existing object, the remove
     * // function will ensure the object can then be reallocated later
     * me.game.world.removeChild(enemy);
     * me.game.world.removeChild(bullet);
     */
    pull(name) {
        var args = new Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) {
            args[i] = arguments[i];
        }
        var className = this.objectClass[name];
        if (className) {
            var proto = className["class"],
                poolArray = className.pool,
                obj;

            if (poolArray && ((obj = poolArray.pop()))) {
                // pull an existing instance from the pool
                args.shift();
                // call the object onResetEvent function if defined
                if (typeof(obj.onResetEvent) === "function") {
                    obj.onResetEvent.apply(obj, args);
                }
                this.instance_counter--;
            }
            else {
                // create a new instance
                args[0] = proto;
                obj = new (proto.bind.apply(proto, args))();
                if (poolArray) {
                    obj.className = name;
                }
            }
            return obj;
        }
        throw new Error("Cannot instantiate object of type '" + name + "'");
    }

    /**
     * purge the object pool from any inactive object <br>
     * Object pooling must be enabled for this function to work<br>
     * note: this will trigger the garbage collector
     */
    purge() {
        for (var className in this.objectClass) {
            if (this.objectClass[className]) {
                this.objectClass[className].pool = [];
            }
        }
        this.instance_counter = 0;
    }

    /**
     * Push back an object instance into the object pool <br>
     * Object pooling for the object class must be enabled,
     * and object must have been instantiated using {@link pool#pull},
     * otherwise this function won't work
     * @throws will throw an error if the object cannot be recycled
     * @param {object} obj instance to be recycled
     * @param {boolean} [throwOnError=true] throw an exception if the object cannot be recycled
     * @returns {boolean} true if the object was successfully recycled in the object pool
     */
    push(obj, throwOnError = true) {
        if (!this.poolable(obj)) {
            if (throwOnError === true ) {
                throw new Error("me.pool: object " + obj + " cannot be recycled");
            } else {
                return false;
            }
        }

        // store back the object instance for later recycling
        this.objectClass[obj.className].pool.push(obj);
        this.instance_counter++;

        return true;
    }

    /**
     * Check if an object with the provided name is registered
     * @param {string} name of the registered object class
     * @returns {boolean} true if the classname is registered
     */
    exists(name) {
        return name in this.objectClass;
    };

    /**
     * Check if an object is poolable
     * (was properly registered with the recycling feature enable)
     * @see register
     * @param {object} obj object to be checked
     * @returns {boolean} true if the object is poolable
     * @example
     * if (!me.pool.poolable(myCherryEntity)) {
     *     // object was not properly registered
     * }
     */
    poolable(obj) {
        var className = obj.className;
        return (typeof className !== "undefined") &&
                (typeof obj.onResetEvent === "function") &&
                (className in this.objectClass) &&
                (typeof this.objectClass[className].pool !== "undefined");

    }

    /**
     * returns the amount of object instance currently in the pool
     * @returns {number} amount of object instance
     */
    getInstanceCount() {
        return this.instance_counter;
    }
}

var pool = new ObjectPool();

/**
 * @classdesc
 * a generic 2D Vector Object
 */
class Vector2d {
    /**
     * @param {number} [x=0] x value of the vector
     * @param {number} [y=0] y value of the vector
     */
    constructor(x = 0, y = 0) {
        this.onResetEvent(x, y);
    }

    /**
     * @ignore
     */
    onResetEvent(x = 0, y = 0) {
        // this is to enable proper object pooling
        this.x = x;
        this.y = y;
        return this;
    }

    /**
     * @ignore
     */
    _set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }

    /**
     * set the Vector x and y properties to the given values<br>
     * @name set
     * @memberof Vector2d
     * @param {number} x
     * @param {number} y
     * @returns {Vector2d} Reference to this object for method chaining
     */
    set(x, y) {
        if (x !== +x || y !== +y) {
            throw new Error(
                "invalid x,y parameters (not a number)"
            );
        }

        /**
         * x value of the vector
         * @public
         * @member {number}
         * @name x
         * @memberof Vector2d
         */
        //this.x = x;

        /**
         * y value of the vector
         * @public
         * @member {number}
         * @name y
         * @memberof Vector2d
         */
        //this.y = y;

        return this._set(x, y);
    }

    /**
     * set the Vector x and y properties to 0
     * @name setZero
     * @memberof Vector2d
     * @returns {Vector2d} Reference to this object for method chaining
     */
    setZero() {
        return this.set(0, 0);
    }

    /**
     * set the Vector x and y properties using the passed vector
     * @name setV
     * @memberof Vector2d
     * @param {Vector2d} v
     * @returns {Vector2d} Reference to this object for method chaining
     */
    setV(v) {
        return this._set(v.x, v.y);
    }

    /**
     * Add the passed vector to this vector
     * @name add
     * @memberof Vector2d
     * @param {Vector2d} v
     * @returns {Vector2d} Reference to this object for method chaining
     */
    add(v) {
        return this._set(this.x + v.x, this.y + v.y);
    }

    /**
     * Substract the passed vector to this vector
     * @name sub
     * @memberof Vector2d
     * @param {Vector2d} v
     * @returns {Vector2d} Reference to this object for method chaining
     */
    sub(v) {
        return this._set(this.x - v.x, this.y - v.y);
    }

    /**
     * Multiply this vector values by the given scalar
     * @name scale
     * @memberof Vector2d
     * @param {number} x
     * @param {number} [y=x]
     * @returns {Vector2d} Reference to this object for method chaining
     */
    scale(x, y) {
        return this._set(this.x * x, this.y * (typeof (y) !== "undefined" ? y : x));
    }

    /**
     * Convert this vector into isometric coordinate space
     * @name toIso
     * @memberof Vector2d
     * @returns {Vector2d} Reference to this object for method chaining
     */
    toIso() {
        return this._set(this.x - this.y, (this.x + this.y) * 0.5);
    }

    /**
     * Convert this vector into 2d coordinate space
     * @name to2d
     * @memberof Vector2d
     * @returns {Vector2d} Reference to this object for method chaining
     */
    to2d() {
        return this._set(this.y + this.x / 2, this.y - this.x / 2);
    }

    /**
     * Multiply this vector values by the passed vector
     * @name scaleV
     * @memberof Vector2d
     * @param {Vector2d} v
     * @returns {Vector2d} Reference to this object for method chaining
     */
    scaleV(v) {
        return this._set(this.x * v.x, this.y * v.y);
    }

    /**
     * Divide this vector values by the passed value
     * @name div
     * @memberof Vector2d
     * @param {number} n the value to divide the vector by
     * @returns {Vector2d} Reference to this object for method chaining
     */
    div(n) {
        return this._set(this.x / n, this.y / n);
    }

    /**
     * Update this vector values to absolute values
     * @name abs
     * @memberof Vector2d
     * @returns {Vector2d} Reference to this object for method chaining
     */
    abs() {
        return this._set((this.x < 0) ? -this.x : this.x, (this.y < 0) ? -this.y : this.y);
    }

    /**
     * Clamp the vector value within the specified value range
     * @name clamp
     * @memberof Vector2d
     * @param {number} low
     * @param {number} high
     * @returns {Vector2d} new me.Vector2d
     */
    clamp(low, high) {
        return new Vector2d(clamp(this.x, low, high), clamp(this.y, low, high));
    }

    /**
     * Clamp this vector value within the specified value range
     * @name clampSelf
     * @memberof Vector2d
     * @param {number} low
     * @param {number} high
     * @returns {Vector2d} Reference to this object for method chaining
     */
    clampSelf(low, high) {
        return this._set(clamp(this.x, low, high), clamp(this.y, low, high));
    }

    /**
     * Update this vector with the minimum value between this and the passed vector
     * @name minV
     * @memberof Vector2d
     * @param {Vector2d} v
     * @returns {Vector2d} Reference to this object for method chaining
     */
    minV(v) {
        return this._set((this.x < v.x) ? this.x : v.x, (this.y < v.y) ? this.y : v.y);
    }

    /**
     * Update this vector with the maximum value between this and the passed vector
     * @name maxV
     * @memberof Vector2d
     * @param {Vector2d} v
     * @returns {Vector2d} Reference to this object for method chaining
     */
    maxV(v) {
        return this._set((this.x > v.x) ? this.x : v.x, (this.y > v.y) ? this.y : v.y);
    }

    /**
     * Floor the vector values
     * @name floor
     * @memberof Vector2d
     * @returns {Vector2d} new me.Vector2d
     */
    floor() {
        return new Vector2d(Math.floor(this.x), Math.floor(this.y));
    }

    /**
     * Floor this vector values
     * @name floorSelf
     * @memberof Vector2d
     * @returns {Vector2d} Reference to this object for method chaining
     */
    floorSelf() {
        return this._set(Math.floor(this.x), Math.floor(this.y));
    }

    /**
     * Ceil the vector values
     * @name ceil
     * @memberof Vector2d
     * @returns {Vector2d} new me.Vector2d
     */
    ceil() {
        return new Vector2d(Math.ceil(this.x), Math.ceil(this.y));
    }

    /**
     * Ceil this vector values
     * @name ceilSelf
     * @memberof Vector2d
     * @returns {Vector2d} Reference to this object for method chaining
     */
    ceilSelf() {
        return this._set(Math.ceil(this.x), Math.ceil(this.y));
    }

    /**
     * Negate the vector values
     * @name negate
     * @memberof Vector2d
     * @returns {Vector2d} new me.Vector2d
     */
    negate() {
        return new Vector2d(-this.x, -this.y);
    }

    /**
     * Negate this vector values
     * @name negateSelf
     * @memberof Vector2d
     * @returns {Vector2d} Reference to this object for method chaining
     */
    negateSelf() {
        return this._set(-this.x, -this.y);
    }

    /**
     * Copy the x,y values of the passed vector to this one
     * @name copy
     * @memberof Vector2d
     * @param {Vector2d} v
     * @returns {Vector2d} Reference to this object for method chaining
     */
    copy(v) {
        return this._set(v.x, v.y);
    }

    /**
     * return true if the two vectors are the same
     * @name equals
     * @memberof Vector2d
     * @method
     * @param {Vector2d} v
     * @returns {boolean}
     */
    /**
     * return true if this vector is equal to the given values
     * @name equals
     * @memberof Vector2d
     * @param {number} x
     * @param {number} y
     * @returns {boolean}
     */
    equals() {
        var _x, _y;
        if (arguments.length === 2) {
            // x, y
            _x = arguments[0];
            _y = arguments[1];
        } else {
            // vector
            _x = arguments[0].x;
            _y = arguments[0].y;
        }
        return ((this.x === _x) && (this.y === _y));
    }

    /**
     * normalize this vector (scale the vector so that its magnitude is 1)
     * @name normalize
     * @memberof Vector2d
     * @returns {Vector2d} Reference to this object for method chaining
     */
    normalize() {
        return this.div(this.length() || 1);
    }

    /**
     * change this vector to be perpendicular to what it was before.<br>
     * (Effectively rotates it 90 degrees in a clockwise direction)
     * @name perp
     * @memberof Vector2d
     * @returns {Vector2d} Reference to this object for method chaining
     */
    perp() {
        return this._set(this.y, -this.x);
    }

    /**
     * Rotate this vector (counter-clockwise) by the specified angle (in radians).
     * @name rotate
     * @memberof Vector2d
     * @param {number} angle The angle to rotate (in radians)
     * @param {Vector2d|ObservableVector2d} [v] an optional point to rotate around
     * @returns {Vector2d} Reference to this object for method chaining
     */
    rotate(angle, v) {
        var cx = 0;
        var cy = 0;

        if (typeof v === "object") {
            cx = v.x;
            cy = v.y;
        }

        var x = this.x - cx;
        var y = this.y - cy;

        var c = Math.cos(angle);
        var s = Math.sin(angle);

        return this._set(x * c - y * s + cx, x * s + y * c + cy);
    }

    /**
     * return the dot product of this vector and the passed one
     * @name dot
     * @memberof Vector2d
     * @param {Vector2d} v
     * @returns {number} The dot product.
     */
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }

    /**
     * return the cross product of this vector and the passed one
     * @name cross
     * @memberof Vector2d
     * @param {Vector2d} v
     * @returns {number} The cross product.
     */
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }

   /**
    * return the square length of this vector
    * @name length2
    * @memberof Vector2d
    * @returns {number} The length^2 of this vector.
    */
    length2() {
        return this.dot(this);
    }

    /**
     * return the length (magnitude) of this vector
     * @name length
     * @memberof Vector2d
     * @returns {number} the length of this vector
     */
    length() {
        return Math.sqrt(this.length2());
    }

    /**
     * Linearly interpolate between this vector and the given one.
     * @name lerp
     * @memberof Vector2d
     * @param {Vector2d} v
     * @param {number} alpha distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
     * @returns {Vector2d} Reference to this object for method chaining
     */
    lerp(v, alpha) {
        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        return this;
    }

    /**
     * return the distance between this vector and the passed one
     * @name distance
     * @memberof Vector2d
     * @param {Vector2d} v
     * @returns {number}
     */
    distance(v) {
        var dx = this.x - v.x, dy = this.y - v.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    /**
     * return the angle between this vector and the passed one
     * @name angle
     * @memberof Vector2d
     * @param {Vector2d} v
     * @returns {number} angle in radians
     */
    angle(v) {
        return Math.acos(clamp(this.dot(v) / (this.length() * v.length()), -1, 1));
    }

    /**
     * project this vector on to another vector.
     * @name project
     * @memberof Vector2d
     * @param {Vector2d} v The vector to project onto.
     * @returns {Vector2d} Reference to this object for method chaining
     */
    project(v) {
        return this.scale(this.dot(v) / v.length2());
    }

    /**
     * Project this vector onto a vector of unit length.<br>
     * This is slightly more efficient than `project` when dealing with unit vectors.
     * @name projectN
     * @memberof Vector2d
     * @param {Vector2d} v The unit vector to project onto.
     * @returns {Vector2d} Reference to this object for method chaining
     */
    projectN(v) {
        return this.scale(this.dot(v));
    }

    /**
     * return a clone copy of this vector
     * @name clone
     * @memberof Vector2d
     * @returns {Vector2d} new me.Vector2d
     */
    clone() {
        return pool.pull("Vector2d", this.x, this.y);
    }

    /**
     * convert the object to a string representation
     * @name toString
     * @memberof Vector2d
     * @returns {string}
     */
    toString() {
        return "x:" + this.x + ",y:" + this.y;
    }
}

// convert a give color component to it hexadecimal value
var toHex = function (component) {
    return "0123456789ABCDEF".charAt((component - (component % 16)) >> 4) + "0123456789ABCDEF".charAt(component % 16);
};

const rgbaRx = /^rgba?\((\d+), ?(\d+), ?(\d+)(, ?([\d\.]+))?\)$/;
const hex3Rx = /^#([\da-fA-F])([\da-fA-F])([\da-fA-F])$/;
const hex4Rx = /^#([\da-fA-F])([\da-fA-F])([\da-fA-F])([\da-fA-F])$/;
const hex6Rx = /^#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})$/;
const hex8Rx = /^#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})$/;

var cssToRGB = new Map();

[
    // CSS1
    [ "black",                  [   0,   0,   0 ] ],
    [ "silver",                 [ 192, 192, 129 ] ],
    [ "gray",                   [ 128, 128, 128 ] ],
    [ "white",                  [ 255, 255, 255 ] ],
    [ "maroon",                 [ 128,   0,   0 ] ],
    [ "red",                    [ 255,   0,   0 ] ],
    [ "purple",                 [ 128,   0, 128 ] ],
    [ "fuchsia",                [ 255,   0, 255 ] ],
    [ "green",                  [   0, 128,   0 ] ],
    [ "lime",                   [   0, 255,   0 ] ],
    [ "olive",                  [ 128, 128,   0 ] ],
    [ "yellow",                 [ 255, 255,   0 ] ],
    [ "navy",                   [   0,   0, 128 ] ],
    [ "blue",                   [   0,   0, 255 ] ],
    [ "teal",                   [   0, 128, 128 ] ],
    [ "aqua",                   [   0, 255, 255 ] ],

    // CSS2
    [ "orange",                 [ 255, 165,   0 ] ],

    // CSS3
    [ "aliceblue",              [ 240, 248, 245 ] ],
    [ "antiquewhite",           [ 250, 235, 215 ] ],
    [ "aquamarine",             [ 127, 255, 212 ] ],
    [ "azure",                  [ 240, 255, 255 ] ],
    [ "beige",                  [ 245, 245, 220 ] ],
    [ "bisque",                 [ 255, 228, 196 ] ],
    [ "blanchedalmond",         [ 255, 235, 205 ] ],
    [ "blueviolet",             [ 138,  43, 226 ] ],
    [ "brown",                  [ 165,  42,  42 ] ],
    [ "burlywood",              [ 222, 184,  35 ] ],
    [ "cadetblue",              [  95, 158, 160 ] ],
    [ "chartreuse",             [ 127, 255,   0 ] ],
    [ "chocolate",              [ 210, 105,  30 ] ],
    [ "coral",                  [ 255, 127,  80 ] ],
    [ "cornflowerblue",         [ 100, 149, 237 ] ],
    [ "cornsilk",               [ 255, 248, 220 ] ],
    [ "crimson",                [ 220,  20,  60 ] ],
    [ "darkblue",               [   0,   0, 139 ] ],
    [ "darkcyan",               [   0, 139, 139 ] ],
    [ "darkgoldenrod",          [ 184, 134,  11 ] ],
    [ "darkgray[*]",            [ 169, 169, 169 ] ],
    [ "darkgreen",              [   0, 100,   0 ] ],
    [ "darkgrey[*]",            [ 169, 169, 169 ] ],
    [ "darkkhaki",              [ 189, 183, 107 ] ],
    [ "darkmagenta",            [ 139,   0, 139 ] ],
    [ "darkolivegreen",         [  85, 107,  47 ] ],
    [ "darkorange",             [ 255, 140,   0 ] ],
    [ "darkorchid",             [ 153,  50, 204 ] ],
    [ "darkred",                [ 139,   0,   0 ] ],
    [ "darksalmon",             [ 233, 150, 122 ] ],
    [ "darkseagreen",           [ 143, 188, 143 ] ],
    [ "darkslateblue",          [  72,  61, 139 ] ],
    [ "darkslategray",          [  47,  79,  79 ] ],
    [ "darkslategrey",          [  47,  79,  79 ] ],
    [ "darkturquoise",          [   0, 206, 209 ] ],
    [ "darkviolet",             [ 148,   0, 211 ] ],
    [ "deeppink",               [ 255,  20, 147 ] ],
    [ "deepskyblue",            [   0, 191, 255 ] ],
    [ "dimgray",                [ 105, 105, 105 ] ],
    [ "dimgrey",                [ 105, 105, 105 ] ],
    [ "dodgerblue",             [  30, 144, 255 ] ],
    [ "firebrick",              [ 178,  34,  34 ] ],
    [ "floralwhite",            [ 255, 250, 240 ] ],
    [ "forestgreen",            [  34, 139,  34 ] ],
    [ "gainsboro",              [ 220, 220, 220 ] ],
    [ "ghostwhite",             [ 248, 248, 255 ] ],
    [ "gold",                   [ 255, 215,   0 ] ],
    [ "goldenrod",              [ 218, 165,  32 ] ],
    [ "greenyellow",            [ 173, 255,  47 ] ],
    [ "grey",                   [ 128, 128, 128 ] ],
    [ "honeydew",               [ 240, 255, 240 ] ],
    [ "hotpink",                [ 255, 105, 180 ] ],
    [ "indianred",              [ 205,  92,  92 ] ],
    [ "indigo",                 [  75,   0, 130 ] ],
    [ "ivory",                  [ 255, 255, 240 ] ],
    [ "khaki",                  [ 240, 230, 140 ] ],
    [ "lavender",               [ 230, 230, 250 ] ],
    [ "lavenderblush",          [ 255, 240, 245 ] ],
    [ "lawngreen",              [ 124, 252,   0 ] ],
    [ "lemonchiffon",           [ 255, 250, 205 ] ],
    [ "lightblue",              [ 173, 216, 230 ] ],
    [ "lightcoral",             [ 240, 128, 128 ] ],
    [ "lightcyan",              [ 224, 255, 255 ] ],
    [ "lightgoldenrodyellow",   [ 250, 250, 210 ] ],
    [ "lightgray",              [ 211, 211, 211 ] ],
    [ "lightgreen",             [ 144, 238, 144 ] ],
    [ "lightgrey",              [ 211, 211, 211 ] ],
    [ "lightpink",              [ 255, 182, 193 ] ],
    [ "lightsalmon",            [ 255, 160, 122 ] ],
    [ "lightseagreen",          [  32, 178, 170 ] ],
    [ "lightskyblue",           [ 135, 206, 250 ] ],
    [ "lightslategray",         [ 119, 136, 153 ] ],
    [ "lightslategrey",         [ 119, 136, 153 ] ],
    [ "lightsteelblue",         [ 176, 196, 222 ] ],
    [ "lightyellow",            [ 255, 255, 224 ] ],
    [ "limegreen",              [  50, 205,  50 ] ],
    [ "linen",                  [ 250, 240, 230 ] ],
    [ "mediumaquamarine",       [ 102, 205, 170 ] ],
    [ "mediumblue",             [   0,   0, 205 ] ],
    [ "mediumorchid",           [ 186,  85, 211 ] ],
    [ "mediumpurple",           [ 147, 112, 219 ] ],
    [ "mediumseagreen",         [  60, 179, 113 ] ],
    [ "mediumslateblue",        [ 123, 104, 238 ] ],
    [ "mediumspringgreen",      [   0, 250, 154 ] ],
    [ "mediumturquoise",        [  72, 209, 204 ] ],
    [ "mediumvioletred",        [ 199,  21, 133 ] ],
    [ "midnightblue",           [  25,  25, 112 ] ],
    [ "mintcream",              [ 245, 255, 250 ] ],
    [ "mistyrose",              [ 255, 228, 225 ] ],
    [ "moccasin",               [ 255, 228, 181 ] ],
    [ "navajowhite",            [ 255, 222, 173 ] ],
    [ "oldlace",                [ 253, 245, 230 ] ],
    [ "olivedrab",              [ 107, 142,  35 ] ],
    [ "orangered",              [ 255,  69,   0 ] ],
    [ "orchid",                 [ 218, 112, 214 ] ],
    [ "palegoldenrod",          [ 238, 232, 170 ] ],
    [ "palegreen",              [ 152, 251, 152 ] ],
    [ "paleturquoise",          [ 175, 238, 238 ] ],
    [ "palevioletred",          [ 219, 112, 147 ] ],
    [ "papayawhip",             [ 255, 239, 213 ] ],
    [ "peachpuff",              [ 255, 218, 185 ] ],
    [ "peru",                   [ 205, 133,  63 ] ],
    [ "pink",                   [ 255, 192, 203 ] ],
    [ "plum",                   [ 221, 160, 221 ] ],
    [ "powderblue",             [ 176, 224, 230 ] ],
    [ "rosybrown",              [ 188, 143, 143 ] ],
    [ "royalblue",              [  65, 105, 225 ] ],
    [ "saddlebrown",            [ 139,  69,  19 ] ],
    [ "salmon",                 [ 250, 128, 114 ] ],
    [ "sandybrown",             [ 244, 164,  96 ] ],
    [ "seagreen",               [  46, 139,  87 ] ],
    [ "seashell",               [ 255, 245, 238 ] ],
    [ "sienna",                 [ 160,  82,  45 ] ],
    [ "skyblue",                [ 135, 206, 235 ] ],
    [ "slateblue",              [ 106,  90, 205 ] ],
    [ "slategray",              [ 112, 128, 144 ] ],
    [ "slategrey",              [ 112, 128, 144 ] ],
    [ "snow",                   [ 255, 250, 250 ] ],
    [ "springgreen",            [   0, 255, 127 ] ],
    [ "steelblue",              [  70, 130, 180 ] ],
    [ "tan",                    [ 210, 180, 140 ] ],
    [ "thistle",                [ 216, 191, 216 ] ],
    [ "tomato",                 [ 255,  99,  71 ] ],
    [ "turquoise",              [  64, 224, 208 ] ],
    [ "violet",                 [ 238, 130, 238 ] ],
    [ "wheat",                  [ 245, 222, 179 ] ],
    [ "whitesmoke",             [ 245, 245, 245 ] ],
    [ "yellowgreen",            [ 154, 205,  50 ] ]
].forEach(function (value) {
    cssToRGB.set(value[0], value[1]);
});

/**
 * @classdesc
 * A color manipulation object.
 */
class Color {
    /**
     * @param {number} [r=0] red component or array of color components
     * @param {number} [g=0] green component
     * @param {number} [b=0] blue component
     * @param {number} [alpha=1.0] alpha value
     */
    constructor(r = 0, g = 0, b = 0, alpha = 1.0) {
        this.onResetEvent(r, g, b, alpha);
    }

    /**
     * @ignore
     */
    onResetEvent(r = 0, g = 0, b = 0, alpha = 1.0) {
        if (typeof (this.glArray) === "undefined") {
            // Color components in a Float32Array suitable for WebGL
            this.glArray = new Float32Array([ 0.0, 0.0, 0.0, 1.0 ]);
        }

        return this.setColor(r, g, b, alpha);
    }

    /**
     * Color Red Component [0 .. 255]
     * @type {number}
     * @memberof Color
     */
    get r() {
        return ~~(this.glArray[0] * 255);
    }

    set r(value) {
        this.glArray[0] = clamp(~~value || 0, 0, 255) / 255.0;
    }


    /**
     * Color Green Component [0 .. 255]
     * @type {number}
     * @memberof Color
     */
    get g() {
        return ~~(this.glArray[1] * 255);
    }

    set g(value) {
        this.glArray[1] = clamp(~~value || 0, 0, 255) / 255.0;
    }


    /**
     * Color Blue Component [0 .. 255]
     * @type {number}
     * @memberof Color
     */
    get b() {
        return ~~(this.glArray[2] * 255);
    }
    set b(value) {
        this.glArray[2] = clamp(~~value || 0, 0, 255) / 255.0;
    }

    /**
     * Color Alpha Component [0.0 .. 1.0]
     * @type {number}
     * @memberof Color
     */
    get alpha() {
        return this.glArray[3];
    }

    set alpha(value) {
        this.glArray[3] = typeof(value) === "undefined" ? 1.0 : clamp(+value, 0, 1.0);
    }


    /**
     * Set this color to the specified value.
     * @name setColor
     * @memberof Color
     * @param {number} r red component [0 .. 255]
     * @param {number} g green component [0 .. 255]
     * @param {number} b blue component [0 .. 255]
     * @param {number} [alpha=1.0] alpha value [0.0 .. 1.0]
     * @returns {Color} Reference to this object for method chaining
     */
    setColor(r, g, b, alpha = 1.0) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.alpha = alpha;
        return this;
    }

    /**
     * Create a new copy of this color object.
     * @name clone
     * @memberof Color
     * @returns {Color} Reference to the newly cloned object
     */
    clone() {
        return pool.pull("Color").copy(this);
    }

    /**
     * Copy a color object or CSS color into this one.
     * @name copy
     * @memberof Color
     * @param {Color|string} color
     * @returns {Color} Reference to this object for method chaining
     */
    copy(color) {
        if (color instanceof Color) {
            this.glArray.set(color.glArray);
            return this;
        }

        return this.parseCSS(color);
    }

    /**
     * Blend this color with the given one using addition.
     * @name add
     * @memberof Color
     * @param {Color} color
     * @returns {Color} Reference to this object for method chaining
     */
    add(color) {
        this.glArray[0] = clamp(this.glArray[0] + color.glArray[0], 0, 1);
        this.glArray[1] = clamp(this.glArray[1] + color.glArray[1], 0, 1);
        this.glArray[2] = clamp(this.glArray[2] + color.glArray[2], 0, 1);
        this.glArray[3] = (this.glArray[3] + color.glArray[3]) / 2;

        return this;
    }

    /**
     * Darken this color value by 0..1
     * @name darken
     * @memberof Color
     * @param {number} scale
     * @returns {Color} Reference to this object for method chaining
     */
    darken(scale) {
        scale = clamp(scale, 0, 1);
        this.glArray[0] *= scale;
        this.glArray[1] *= scale;
        this.glArray[2] *= scale;

        return this;
    }

    /**
     * Linearly interpolate between this color and the given one.
     * @name lerp
     * @memberof Color
     * @param {Color} color
     * @param {number} alpha with alpha = 0 being this color, and alpha = 1 being the given one.
     * @returns {Color} Reference to this object for method chaining
     */
    lerp(color, alpha) {
        alpha = clamp(alpha, 0, 1);
        this.glArray[0] += (color.glArray[0] - this.glArray[0]) * alpha;
        this.glArray[1] += (color.glArray[1] - this.glArray[1]) * alpha;
        this.glArray[2] += (color.glArray[2] - this.glArray[2]) * alpha;

        return this;
    }

    /**
     * Lighten this color value by 0..1
     * @name lighten
     * @memberof Color
     * @param {number} scale
     * @returns {Color} Reference to this object for method chaining
     */
    lighten(scale) {
        scale = clamp(scale, 0, 1);
        this.glArray[0] = clamp(this.glArray[0] + (1 - this.glArray[0]) * scale, 0, 1);
        this.glArray[1] = clamp(this.glArray[1] + (1 - this.glArray[1]) * scale, 0, 1);
        this.glArray[2] = clamp(this.glArray[2] + (1 - this.glArray[2]) * scale, 0, 1);

        return this;
    }

    /**
     * Generate random r,g,b values for this color object
     * @name random
     * @memberof Color
     * @param {number} [min=0] minimum value for the random range
     * @param {number} [max=255] maxmium value for the random range
     * @returns {Color} Reference to this object for method chaining
     */
    random(min = 0, max = 255) {
        if (min < 0) {
            min = 0;
        }
        if (max > 255) {
            max = 255;
        }

        return this.setColor(
            random$1(min, max),
            random$1(min, max),
            random$1(min, max),
            this.alpha
        );
    }

    /**
     * Return true if the r,g,b,a values of this color are equal with the
     * given one.
     * @name equals
     * @memberof Color
     * @param {Color} color
     * @returns {boolean}
     */
    equals(color) {
        return (
            (this.glArray[0] === color.glArray[0]) &&
            (this.glArray[1] === color.glArray[1]) &&
            (this.glArray[2] === color.glArray[2]) &&
            (this.glArray[3] === color.glArray[3])
        );
    }

    /**
     * Parse a CSS color string and set this color to the corresponding
     * r,g,b values
     * @name parseCSS
     * @memberof Color
     * @param {string} cssColor
     * @returns {Color} Reference to this object for method chaining
     */
    parseCSS(cssColor) {
        // TODO : Memoize this function by caching its input

        if (cssToRGB.has(cssColor)) {
            return this.setColor.apply(this, cssToRGB.get(cssColor));
        }

        return this.parseRGB(cssColor);
    }

    /**
     * Parse an RGB or RGBA CSS color string
     * @name parseRGB
     * @memberof Color
     * @param {string} rgbColor
     * @returns {Color} Reference to this object for method chaining
     */
    parseRGB(rgbColor) {
        // TODO : Memoize this function by caching its input

        var match = rgbaRx.exec(rgbColor);
        if (match) {
            return this.setColor(+match[1], +match[2], +match[3], +match[5]);
        }

        return this.parseHex(rgbColor);
    }

    /**
     * Parse a Hex color ("#RGB", "#RGBA" or "#RRGGBB", "#RRGGBBAA" format) and set this color to
     * the corresponding r,g,b,a values
     * @name parseHex
     * @memberof Color
     * @param {string} hexColor
     * @param {boolean} [argb = false] true if format is #ARGB, or #AARRGGBB (as opposed to #RGBA or #RGGBBAA)
     * @returns {Color} Reference to this object for method chaining
     */
    parseHex(hexColor, argb = false) {
        // TODO : Memoize this function by caching its input

        var match;
        if ((match = hex8Rx.exec(hexColor))) {
            // #AARRGGBB or #RRGGBBAA
            return this.setColor(
                parseInt(match[argb === false ? 1 : 2], 16), // r
                parseInt(match[argb === false ? 2 : 3], 16), // g
                parseInt(match[argb === false ? 3 : 4], 16), // b
                (clamp(parseInt(match[argb === false ? 4 : 1], 16), 0, 255) / 255.0).toFixed(1) // a
            );
        }

        if ((match = hex6Rx.exec(hexColor))) {
            // #RRGGBB
            return this.setColor(
                parseInt(match[1], 16),
                parseInt(match[2], 16),
                parseInt(match[3], 16)
            );
        }

        if ((match = hex4Rx.exec(hexColor))) {
            // #ARGB or #RGBA
            var r = match[argb === false ? 1 : 2];
            var g = match[argb === false ? 2 : 3];
            var b = match[argb === false ? 3 : 4];
            var a = match[argb === false ? 4 : 1];
            return this.setColor(
                parseInt(r + r, 16), // r
                parseInt(g + g, 16), // g
                parseInt(b + b, 16), // b
                (clamp(parseInt(a + a, 16), 0, 255) / 255.0).toFixed(1) // a
            );
        }

        if ((match = hex3Rx.exec(hexColor))) {
            // #RGB
            return this.setColor(
                parseInt(match[1] + match[1], 16),
                parseInt(match[2] + match[2], 16),
                parseInt(match[3] + match[3], 16)
            );
        }

        throw new Error(
            "invalid parameter: " + hexColor
        );
    }

    /**
     * Pack this color into a Uint32 ARGB representation
     * @name toUint32
     * @memberof Color
     * @param {number} [alpha=1.0] alpha value [0.0 .. 1.0]
     * @returns {number}
     */
    toUint32(alpha = this.alpha) {
        var ur = this.r & 0xff;
        var ug = this.g & 0xff;
        var ub = this.b & 0xff;
        var ua = (alpha * 255) & 0xff;

        return (ua << 24) + (ur << 16) + (ug << 8) + ub;
    }

    /**
     * return an array representation of this object
     * @name toArray
     * @memberof Color
     * @returns {Float32Array}
     */
    toArray() {
        return this.glArray;
    }


    /**
     * Get the color in "#RRGGBB" format
     * @name toHex
     * @memberof Color
     * @returns {string}
     */
    toHex() {
        // TODO : Memoize this function by caching its result until any of
        // the r,g,b,a values are changed

        return "#" + toHex(this.r) + toHex(this.g) + toHex(this.b);
    }

    /**
     * Get the color in "#RRGGBBAA" format
     * @name toHex8
     * @memberof Color
     * @returns {string}
     */
    toHex8(alpha = this.alpha) {
        // TODO : Memoize this function by caching its result until any of
        // the r,g,b,a values are changed

        return "#" + toHex(this.r) + toHex(this.g) + toHex(this.b) + toHex(alpha * 255);
    }

    /**
     * Get the color in "rgb(R,G,B)" format
     * @name toRGB
     * @memberof Color
     * @returns {string}
     */
    toRGB() {
        // TODO : Memoize this function by caching its result until any of
        // the r,g,b,a values are changed

        return "rgb(" +
            this.r + "," +
            this.g + "," +
            this.b +
        ")";
    }

    /**
     * Get the color in "rgba(R,G,B,A)" format
     * @name toRGBA
     * @memberof Color
     * @param {number} [alpha=1.0] alpha value [0.0 .. 1.0]
     * @returns {string}
     */
    toRGBA(alpha = this.alpha) {
        // TODO : Memoize this function by caching its result until any of
        // the r,g,b,a values are changed

        return "rgba(" +
            this.r + "," +
            this.g + "," +
            this.b + "," +
            alpha +
        ")";
    }
}

/**
 * @classdesc
 * a 4x4 Matrix3d Object
 */
class Matrix3d {
    /**
     * @param {(Matrix3d|...number)} args An instance of me.Matrix3d to copy from, or individual Matrix components (See {@link Matrix3d.setTransform}). If not arguments are given, the matrix will be set to Identity.
     */
    constructor(...args) {
        this.onResetEvent(...args);
    }

    /**
     * @ignore
     */
    onResetEvent() {
        if (typeof this.val === "undefined") {
            this.val = new Float32Array(16);
        }

        if (arguments.length && arguments[0] instanceof Matrix3d) {
            this.copy(arguments[0]);
        }
        else if (arguments.length === 16) {
            this.setTransform.apply(this, arguments);
        }
        else {
            this.identity();
        }
    }

    /**
     * tx component of the matrix
     * @public
     * @type {number}
     * @name tx
     * @memberof Matrix3d
     */
    get tx() {
        return this.val[12];
    }

    /**
     * ty component of the matrix
     * @public
     * @type {number}
     * @name ty
     * @memberof Matrix3d
     */
    get ty() {
        return this.val[13];
    }

    /**
     * ty component of the matrix
     * @public
     * @type {number}
     * @name tz
     * @memberof Matrix3d
     */
    get tz() {
        return this.val[14];
    }

    /**
     * reset the transformation matrix to the identity matrix (no transformation).<br>
     * the identity matrix and parameters position : <br>
     * <img src="images/identity-matrix_2x.png"/>
     * @name identity
     * @memberof Matrix3d
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    identity() {
        return this.setTransform(
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        );
    }

    /**
     * set the matrix to the specified value
     * @name setTransform
     * @memberof Matrix3d
     * @param {number} m00
     * @param {number} m01
     * @param {number} m02
     * @param {number} m03
     * @param {number} m10
     * @param {number} m11
     * @param {number} m12
     * @param {number} m13
     * @param {number} m20
     * @param {number} m21
     * @param {number} m22
     * @param {number} m23
     * @param {number} m30
     * @param {number} m31
     * @param {number} m32
     * @param {number} m33
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    setTransform(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        var a = this.val;

        a[0] = m00;
        a[1] = m01;
        a[2] = m02;
        a[3] = m03;
        a[4] = m10;
        a[5] = m11;
        a[6] = m12;
        a[7] = m13;
        a[8] = m20;
        a[9] = m21;
        a[10] = m22;
        a[11] = m23;
        a[12] = m30;
        a[13] = m31;
        a[14] = m32;
        a[15] = m33;

        return this;
    }

    /**
     * Copies over the values from another me.Matrix3d.
     * @name copy
     * @memberof Matrix3d
     * @param {Matrix3d} m the matrix object to copy from
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    copy(m) {
        this.val.set(m.val);
        return this;
    }

    /**
     * Copies over the upper-left 2x2 values from the given me.Matrix2d
     * @name fromMat2d
     * @memberof Matrix3d
     * @param {Matrix2d} m the matrix object to copy from
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    fromMat2d(m) {
        var b = m.val;
        return this.setTransform(
            b[0], b[3], b[6], 0,
            b[1], b[4], b[7], 0,
            b[2], b[5], b[8], 0,
            0,    0,    0,    1

        );
    }

    /**
     * multiply both matrix
     * @name multiply
     * @memberof Matrix3d
     * @param {Matrix3d} m Other matrix
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    multiply(m) {
        var a = this.val;
        var b = m.val;

        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];

        a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[4];
        b1 = b[5];
        b2 = b[6];
        b3 = b[7];

        a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[8];
        b1 = b[9];
        b2 = b[10];
        b3 = b[11];

        a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[12];
        b1 = b[13];
        b2 = b[14];
        b3 = b[15];

        a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        return this;
    }

    /**
     * Transpose the value of this matrix.
     * @name transpose
     * @memberof Matrix3d
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    transpose() {
        var a = this.val,
            a01 = a[1],
            a02 = a[2],
            a03 = a[3],
            a12 = a[6],
            a13 = a[7],
            a23 = a[11];

         a[1] = a[4];
         a[2] = a[8];
         a[3] = a[12];
         a[4] = a01;
         a[6] = a[9];
         a[7] = a[13];
         a[8] = a02;
         a[9] = a12;
         a[11] = a[14];
         a[12] = a03;
         a[13] = a13;
         a[14] = a23;

         return this;
    }

    /**
     * invert this matrix, causing it to apply the opposite transformation.
     * @name invert
     * @memberof Matrix3d
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    invert() {
         var a = this.val;

         var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
         var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
         var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
         var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

         var b00 = a00 * a11 - a01 * a10;
         var b01 = a00 * a12 - a02 * a10;
         var b02 = a00 * a13 - a03 * a10;
         var b03 = a01 * a12 - a02 * a11;

         var b04 = a01 * a13 - a03 * a11;
         var b05 = a02 * a13 - a03 * a12;
         var b06 = a20 * a31 - a21 * a30;
         var b07 = a20 * a32 - a22 * a30;

         var b08 = a20 * a33 - a23 * a30;
         var b09 = a21 * a32 - a22 * a31;
         var b10 = a21 * a33 - a23 * a31;
         var b11 = a22 * a33 - a23 * a32;

         // Calculate the determinant
         var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

         if (!det)
         {
             return null;
         }

         det = 1 / det;

         a[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
         a[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
         a[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
         a[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
         a[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
         a[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
         a[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
         a[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
         a[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
         a[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
         a[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
         a[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
         a[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
         a[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
         a[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
         a[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

         return this;
    }

    /**
     * apply the current transform to the given 2d or 3d vector
     * @name apply
     * @memberof Matrix3d
     * @param {Vector2d|Vector3d} v the vector object to be transformed
     * @returns {Vector2d|Vector3d} result vector object.
     */
     apply(v) {
        var a = this.val,
        x = v.x,
        y = v.y,
        z = (typeof v.z !== "undefined") ? v.z : 1;

        var w = (a[3] * x + a[7] * y + a[11] * z + a[15]) || 1.0;

        v.x = (a[0] * x + a[4] * y + a[8] * z + a[12]) / w;
        v.y = (a[1] * x + a[5] * y + a[9] * z + a[13]) / w;

        if (typeof v.z !== "undefined") {
            v.z = (a[2] * x + a[6] * y + a[10] * z + a[14]) / w;
        }

        return v;
     }

     /**
      * apply the inverted current transform to the given 2d or 3d vector
      * @name applyInverse
      * @memberof Matrix3d
      * @param {Vector2d|Vector3d} v the vector object to be transformed
      * @returns {Vector2d|Vector3d} result vector object.
      */
     applyInverse(v) {
         // invert the current matrix
         var im = pool.pull("Matrix3d", this).invert();

         // apply the inverted matrix
         im.apply(v);

         pool.push(im);

         return v;
     }

    /**
     * generate an orthogonal projection matrix, with the result replacing the current matrix
     * <img src="images/glOrtho.gif"/><br>
     * @name ortho
     * @memberof Matrix3d
     * @param {number} left farthest left on the x-axis
     * @param {number} right farthest right on the x-axis
     * @param {number} bottom farthest down on the y-axis
     * @param {number} top farthest up on the y-axis
     * @param {number} near distance to the near clipping plane along the -Z axis
     * @param {number} far distance to the far clipping plane along the -Z axis
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    ortho(left, right, bottom, top, near, far) {
        var a = this.val;
        var leftRight = 1.0 / (left - right);
        var bottomTop = 1.0 / (bottom - top);
        var nearFar = 1.0 / (near - far);

        a[0] = -2.0 * leftRight;
        a[1] = 0.0;
        a[2] = 0.0;
        a[3] = 0.0;
        a[4] = 0.0;
        a[5] = -2.0 * bottomTop;
        a[6] = 0.0;
        a[7] = 0.0;
        a[8] = 0.0;
        a[9] = 0.0;
        a[10] = 2.0 * nearFar;
        a[11] = 0.0;
        a[12] = (left + right) * leftRight;
        a[13] = (top + bottom) * bottomTop;
        a[14] = (far + near) * nearFar;
        a[15] = 1.0;

        return this;
    }

    /**
     * scale the matrix
     * @name scale
     * @memberof Matrix3d
     * @param {number} x a number representing the abscissa of the scaling vector.
     * @param {number} [y=x] a number representing the ordinate of the scaling vector.
     * @param {number} [z=0] a number representing the depth vector
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    scale(x, y, z) {
        var a = this.val,
           _x = x,
           _y = typeof(y) === "undefined" ? _x : y,
           _z = typeof(z) === "undefined" ?  0 : z;

        a[0] = a[0] * _x;
        a[1] = a[1] * _x;
        a[2] = a[2] * _x;
        a[3] = a[3] * _x;

        a[4] = a[4] * _y;
        a[5] = a[5] * _y;
        a[6] = a[6] * _y;
        a[7] = a[7] * _y;

        a[8] = a[8] * _z;
        a[9] = a[9] * _z;
        a[10] = a[10] * _z;
        a[11] = a[11] * _z;

        return this;
    }

    /**
     * adds a 2D scaling transformation.
     * @name scaleV
     * @memberof Matrix3d
     * @param {Vector2d|Vector3d} v scaling vector
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    scaleV(v) {
        return this.scale(v.x, v.y, v.z);
    }

    /**
     * specifies a 2D scale operation using the [sx, 1] scaling vector
     * @name scaleX
     * @memberof Matrix3d
     * @param {number} x x scaling vector
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    scaleX(x) {
        return this.scale(x, 1);
    }

    /**
     * specifies a 2D scale operation using the [1,sy] scaling vector
     * @name scaleY
     * @memberof Matrix3d
     * @param {number} y y scaling vector
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    scaleY(y) {
        return this.scale(1, y);
    }

    /**
     * rotate this matrix (counter-clockwise) by the specified angle (in radians).
     * @name rotate
     * @memberof Matrix3d
     * @param {number} angle Rotation angle in radians.
     * @param {Vector3d} v the axis to rotate around
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    rotate(angle, v) {
        if (angle !== 0) {
            var a = this.val,
                x = v.x,
                y = v.y,
                z = v.z;

            var len = Math.sqrt(x * x + y * y + z * z);

            var s, c, t;
            var a00, a01, a02, a03;
            var a10, a11, a12, a13;
            var a20, a21, a22, a23;
            var b00, b01, b02;
            var b10, b11, b12;
            var b20, b21, b22;

            if (len < EPSILON) {
                return null;
            }

            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;

            s = Math.sin(angle);
            c = Math.cos(angle);
            t = 1 - c;

            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];

            // Construct the elements of the rotation matrix
            b00 = x * x * t + c;
            b01 = y * x * t + z * s;
            b02 = z * x * t - y * s;
            b10 = x * y * t - z * s;
            b11 = y * y * t + c;
            b12 = z * y * t + x * s;
            b20 = x * z * t + y * s;
            b21 = y * z * t - x * s;
            b22 = z * z * t + c;

            // Perform rotation-specific matrix multiplication
            a[0] = a00 * b00 + a10 * b01 + a20 * b02;
            a[1] = a01 * b00 + a11 * b01 + a21 * b02;
            a[2] = a02 * b00 + a12 * b01 + a22 * b02;
            a[3] = a03 * b00 + a13 * b01 + a23 * b02;
            a[4] = a00 * b10 + a10 * b11 + a20 * b12;
            a[5] = a01 * b10 + a11 * b11 + a21 * b12;
            a[6] = a02 * b10 + a12 * b11 + a22 * b12;
            a[7] = a03 * b10 + a13 * b11 + a23 * b12;
            a[8] = a00 * b20 + a10 * b21 + a20 * b22;
            a[9] = a01 * b20 + a11 * b21 + a21 * b22;
            a[10] = a02 * b20 + a12 * b21 + a22 * b22;
            a[11] = a03 * b20 + a13 * b21 + a23 * b22;
        }
        return this;
    }

    /**
     * translate the matrix position using the given vector
     * @name translate
     * @memberof Matrix3d
     * @method
     * @param {number} x a number representing the abscissa of the vector.
     * @param {number} [y=x] a number representing the ordinate of the vector.
     * @param {number} [z=0] a number representing the depth of the vector
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    /**
     * translate the matrix by a vector on the horizontal and vertical axis
     * @name translateV
     * @memberof Matrix3d
     * @param {Vector2d|Vector3d} v the vector to translate the matrix by
     * @returns {Matrix3d} Reference to this object for method chaining
     */
    translate() {
        var a = this.val;
        var _x, _y, _z;

        if (arguments.length > 1 ) {
            // x, y (, z)
            _x = arguments[0];
            _y = arguments[1];
            _z = typeof(arguments[2]) === "undefined" ?  0 : arguments[2];
        } else {
            // 2d/3d vector
            _x = arguments[0].x;
            _y = arguments[0].y;
            _z = typeof(arguments[0].z) === "undefined" ? 0 : arguments[0].z;
        }

        a[12] = a[0] * _x + a[4] * _y + a[8] * _z + a[12];
        a[13] = a[1] * _x + a[5] * _y + a[9] * _z + a[13];
        a[14] = a[2] * _x + a[6] * _y + a[10] * _z + a[14];
        a[15] = a[3] * _x + a[7] * _y + a[11] * _z + a[15];

        return this;
    }

    /**
     * returns true if the matrix is an identity matrix.
     * @name isIdentity
     * @memberof Matrix3d
     * @returns {boolean}
     */
    isIdentity() {
        var a = this.val;

        return (
            (a[0] === 1) &&
            (a[1] === 0) &&
            (a[2] === 0) &&
            (a[3] === 0) &&
            (a[4] === 0) &&
            (a[5] === 1) &&
            (a[6] === 0) &&
            (a[7] === 0) &&
            (a[8] === 0) &&
            (a[9] === 0) &&
            (a[10] === 1) &&
            (a[11] === 0) &&
            (a[12] === 0) &&
            (a[13] === 0) &&
            (a[14] === 0) &&
            (a[15] === 1)
        );
    }

    /**
     * return true if the two matrices are identical
     * @name equals
     * @memberof Matrix3d
     * @param {Matrix3d} m the other matrix
     * @returns {boolean} true if both are equals
     */
    equals(m) {
        var b = m.val;
        var a = this.val;

        return (
            (a[0] === b[0]) &&
            (a[1] === b[1]) &&
            (a[2] === b[2]) &&
            (a[3] === b[3]) &&
            (a[4] === b[4]) &&
            (a[5] === b[5]) &&
            (a[6] === b[6]) &&
            (a[7] === b[7]) &&
            (a[8] === b[8]) &&
            (a[9] === b[9]) &&
            (a[10] === b[10]) &&
            (a[11] === b[11]) &&
            (a[12] === b[12]) &&
            (a[13] === b[13]) &&
            (a[14] === b[14]) &&
            (a[15] === b[15])
        );
    }

    /**
     * Clone the Matrix
     * @name clone
     * @memberof Matrix3d
     * @returns {Matrix3d}
     */
    clone() {
        return pool.pull("Matrix3d", this);
    }

    /**
     * return an array representation of this Matrix
     * @name toArray
     * @memberof Matrix3d
     * @returns {Float32Array}
     */
    toArray() {
        return this.val;
    }

    /**
     * convert the object to a string representation
     * @name toString
     * @memberof Matrix3d
     * @returns {string}
     */
    toString() {
        var a = this.val;

        return "me.Matrix3d(" +
            a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " +
            a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " +
            a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " +
            a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] +
        ")";
    }
}

/**
 * @classdesc
 * a Matrix2d Object.<br>
 * the identity matrix and parameters position : <br>
 * <img src="images/identity-matrix_2x.png"/>
 */
class Matrix2d {
    /**
     * @param {(Matrix2d|Matrix3d|...number)} args an instance of me.Matrix2d or me.Matrix3d to copy from, or individual matrix components (See {@link Matrix2d.setTransform}). If not arguments are given, the matrix will be set to Identity.
     */
    constructor(...args) {
        this.onResetEvent(...args);
    }

    /**
     * @ignore
     */
    onResetEvent() {
        if (typeof(this.val) === "undefined") {
            this.val = new Float32Array(9);
        }

        if (arguments.length && arguments[0] instanceof Matrix2d) {
            this.copy(arguments[0]);
        }
        else if (arguments.length && arguments[0] instanceof Matrix3d) {
            this.fromMat3d(arguments[0]);
        }
        else if (arguments.length >= 6) {
            this.setTransform.apply(this, arguments);
        }
        else {
            this.identity();
        }
        return this;
    }

    /**
     * tx component of the matrix
     * @public
     * @type {number}
     * @see Matrix2d.translate
     * @name tx
     * @memberof Matrix2d
     */
    get tx() {
        return this.val[6];
    }

    /**
     * ty component of the matrix
     * @public
     * @type {number}
     * @see Matrix2d.translate
     * @name ty
     * @memberof Matrix2d
     */
    get ty() {
        return this.val[7];
    }

    /**
     * reset the transformation matrix to the identity matrix (no transformation).<br>
     * the identity matrix and parameters position : <br>
     * <img src="images/identity-matrix_2x.png"/>
     * @name identity
     * @memberof Matrix2d
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    identity() {
        this.setTransform(
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        );
        return this;
    }

    /**
     * set the matrix to the specified value
     * @name setTransform
     * @memberof Matrix2d
     * @param {number} a
     * @param {number} b
     * @param {number} c
     * @param {number} d
     * @param {number} e
     * @param {number} f
     * @param {number} [g=0]
     * @param {number} [h=0]
     * @param {number} [i=1]
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    setTransform() {
        var a = this.val;

        if (arguments.length === 9) {
            a[0] = arguments[0]; // a - m00
            a[1] = arguments[1]; // b - m10
            a[2] = arguments[2]; // c - m20
            a[3] = arguments[3]; // d - m01
            a[4] = arguments[4]; // e - m11
            a[5] = arguments[5]; // f - m21
            a[6] = arguments[6]; // g - m02
            a[7] = arguments[7]; // h - m12
            a[8] = arguments[8]; // i - m22
        } else if (arguments.length === 6) {
            a[0] = arguments[0]; // a
            a[1] = arguments[2]; // c
            a[2] = arguments[4]; // e
            a[3] = arguments[1]; // b
            a[4] = arguments[3]; // d
            a[5] = arguments[5]; // f
            a[6] = 0; // g
            a[7] = 0; // h
            a[8] = 1; // i
        }

        return this;
    }

    /**
     * Copies over the values from another me.Matrix2d.
     * @name copy
     * @memberof Matrix2d
     * @param {Matrix2d} m the matrix object to copy from
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    copy(m) {
        this.val.set(m.val);
        return this;
    }

    /**
     * Copies over the upper-left 3x3 values from the given me.Matrix3d
     * @name fromMat3d
     * @memberof Matrix2d
     * @param {Matrix3d} m the matrix object to copy from
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    fromMat3d(m) {
        var b = m.val;
        var a = this.val;

        a[0] = b[0];
        a[1] = b[1];
        a[2] = b[2];
        a[3] = b[4];
        a[4] = b[5];
        a[5] = b[6];
        a[6] = b[8];
        a[7] = b[9];
        a[8] = b[10];

        return this;
    }

    /**
     * multiply both matrix
     * @name multiply
     * @memberof Matrix2d
     * @param {Matrix2d} m the other matrix
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    multiply(m) {
        var b = m.val;
        var a = this.val,
            a0 = a[0],
            a1 = a[1],
            a3 = a[3],
            a4 = a[4],
            b0 = b[0],
            b1 = b[1],
            b3 = b[3],
            b4 = b[4],
            b6 = b[6],
            b7 = b[7];

        a[0] = a0 * b0 + a3 * b1;
        a[1] = a1 * b0 + a4 * b1;
        a[3] = a0 * b3 + a3 * b4;
        a[4] = a1 * b3 + a4 * b4;
        a[6] += a0 * b6 + a3 * b7;
        a[7] += a1 * b6 + a4 * b7;

        return this;
    }

    /**
     * Transpose the value of this matrix.
     * @name transpose
     * @memberof Matrix2d
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    transpose() {
        var a = this.val,
            a1 = a[1],
            a2 = a[2],
            a5 = a[5];

        a[1] = a[3];
        a[2] = a[6];
        a[3] = a1;
        a[5] = a[7];
        a[6] = a2;
        a[7] = a5;

        return this;
    }

    /**
     * invert this matrix, causing it to apply the opposite transformation.
     * @name invert
     * @memberof Matrix2d
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    invert() {
        var val = this.val;

        var a = val[ 0 ], b = val[ 1 ], c = val[ 2 ],
            d = val[ 3 ], e = val[ 4 ], f = val[ 5 ],
            g = val[ 6 ], h = val[ 7 ], i = val[ 8 ];

        var ta = i * e - f * h,
            td = f * g - i * d,
            tg = h * d - e * g;

        var n = a * ta + b * td + c * tg;

        val[ 0 ] = ta / n;
        val[ 1 ] = ( c * h - i * b ) / n;
        val[ 2 ] = ( f * b - c * e ) / n;

        val[ 3 ] = td / n;
        val[ 4 ] = ( i * a - c * g ) / n;
        val[ 5 ] = ( c * d - f * a ) / n;

        val[ 6 ] = tg / n;
        val[ 7 ] = ( b * g - h * a ) / n;
        val[ 8 ] = ( e * a - b * d ) / n;

        return this;
    }

   /**
    * apply the current transform to the given 2d or 3d vector
    * @name apply
    * @memberof Matrix2d
    * @param {Vector2d|Vector3d} v the vector object to be transformed
    * @returns {Vector2d|Vector3d} result vector object.
    */
    apply(v) {
        var a = this.val,
            x = v.x,
            y = v.y,
            z = (typeof v.z !== "undefined") ? v.z : 1;

        v.x = x * a[0] + y * a[3] + z * a[6];
        v.y = x * a[1] + y * a[4] + z * a[7];

        if (typeof v.z !== "undefined") {
            v.z = x * a[2] + y * a[5] + z * a[8];
        }

        return v;
    }

    /**
     * apply the inverted current transform to the given 2d vector
     * @name applyInverse
     * @memberof Matrix2d
     * @param {Vector2d} v the vector object to be transformed
     * @returns {Vector2d} result vector object.
     */
    applyInverse(v) {
        var a = this.val,
            x = v.x,
            y = v.y;

        var invD = 1 / ((a[0] * a[4]) + (a[3] * -a[1]));

        v.x = (a[4] * invD * x) + (-a[3] * invD * y) + (((a[7] * a[3]) - (a[6] * a[4])) * invD);
        v.y = (a[0] * invD * y) + (-a[1] * invD * x) + (((-a[7] * a[0]) + (a[6] * a[1])) * invD);

        return v;
    }

    /**
     * scale the matrix
     * @name scale
     * @memberof Matrix2d
     * @param {number} x a number representing the abscissa of the scaling vector.
     * @param {number} [y=x] a number representing the ordinate of the scaling vector.
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    scale(x, y) {
        var a = this.val,
           _x = x,
           _y = typeof(y) === "undefined" ? _x : y;

        a[0] *= _x;
        a[1] *= _x;
        a[3] *= _y;
        a[4] *= _y;

        return this;
    }

    /**
     * adds a 2D scaling transformation.
     * @name scaleV
     * @memberof Matrix2d
     * @param {Vector2d} v scaling vector
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    scaleV(v) {
        return this.scale(v.x, v.y);
    }

    /**
     * specifies a 2D scale operation using the [sx, 1] scaling vector
     * @name scaleX
     * @memberof Matrix2d
     * @param {number} x x scaling vector
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    scaleX(x) {
        return this.scale(x, 1);
    }

    /**
     * specifies a 2D scale operation using the [1,sy] scaling vector
     * @name scaleY
     * @memberof Matrix2d
     * @param {number} y y scaling vector
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    scaleY(y) {
        return this.scale(1, y);
    }

    /**
     * rotate the matrix (counter-clockwise) by the specified angle (in radians).
     * @name rotate
     * @memberof Matrix2d
     * @param {number} angle Rotation angle in radians.
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    rotate(angle) {
        if (angle !== 0) {
            var a = this.val,
                a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a10 = a[3],
                a11 = a[4],
                a12 = a[5],
                s = Math.sin(angle),
                c = Math.cos(angle);

            a[0] = c * a00 + s * a10;
            a[1] = c * a01 + s * a11;
            a[2] = c * a02 + s * a12;

            a[3] = c * a10 - s * a00;
            a[4] = c * a11 - s * a01;
            a[5] = c * a12 - s * a02;
        }
        return this;
    }

    /**
     * translate the matrix position on the horizontal and vertical axis
     * @name translate
     * @memberof Matrix2d
     * @method
     * @param {number} x the x coordindates to translate the matrix by
     * @param {number} y the y coordindates to translate the matrix by
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    /**
     * translate the matrix by a vector on the horizontal and vertical axis
     * @name translateV
     * @memberof Matrix2d
     * @param {Vector2d} v the vector to translate the matrix by
     * @returns {Matrix2d} Reference to this object for method chaining
     */
    translate() {
        var a = this.val;
        var _x, _y;

        if (arguments.length === 2) {
            // x, y
            _x = arguments[0];
            _y = arguments[1];
        } else {
            // vector
            _x = arguments[0].x;
            _y = arguments[0].y;
        }

        a[6] += a[0] * _x + a[3] * _y;
        a[7] += a[1] * _x + a[4] * _y;

        return this;
    }

    /**
     * returns true if the matrix is an identity matrix.
     * @name isIdentity
     * @memberof Matrix2d
     * @returns {boolean}
     */
    isIdentity() {
        var a = this.val;

        return (
            a[0] === 1 &&
            a[1] === 0 &&
            a[2] === 0 &&
            a[3] === 0 &&
            a[4] === 1 &&
            a[5] === 0 &&
            a[6] === 0 &&
            a[7] === 0 &&
            a[8] === 1
        );
    }

    /**
     * return true if the two matrices are identical
     * @name equals
     * @memberof Matrix2d
     * @param {Matrix2d} m the other matrix
     * @returns {boolean} true if both are equals
     */
    equals(m) {
        var b = m.val;
        var a = this.val;

        return (
            (a[0] === b[0]) &&
            (a[1] === b[1]) &&
            (a[2] === b[2]) &&
            (a[3] === b[3]) &&
            (a[4] === b[4]) &&
            (a[5] === b[5]) &&
            (a[6] === b[6]) &&
            (a[7] === b[7]) &&
            (a[8] === b[8])
        );
    }

    /**
     * Clone the Matrix
     * @name clone
     * @memberof Matrix2d
     * @returns {Matrix2d}
     */
    clone() {
        return pool.pull("Matrix2d", this);
    }

    /**
     * return an array representation of this Matrix
     * @name toArray
     * @memberof Matrix2d
     * @returns {Float32Array}
     */
    toArray() {
        return this.val;
    }

    /**
     * convert the object to a string representation
     * @name toString
     * @memberof Matrix2d
     * @returns {string}
     */
    toString() {
        var a = this.val;

        return "me.Matrix2d(" +
            a[0] + ", " + a[1] + ", " + a[2] + ", " +
            a[3] + ", " + a[4] + ", " + a[5] + ", " +
            a[6] + ", " + a[7] + ", " + a[8] +
        ")";
    }
}

var eventemitter3 = {exports: {}};

(function (module) {

	var has = Object.prototype.hasOwnProperty
	  , prefix = '~';

	/**
	 * Constructor to create a storage for our `EE` objects.
	 * An `Events` instance is a plain object whose properties are event names.
	 *
	 * @constructor
	 * @private
	 */
	function Events() {}

	//
	// We try to not inherit from `Object.prototype`. In some engines creating an
	// instance in this way is faster than calling `Object.create(null)` directly.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// character to make sure that the built-in object properties are not
	// overridden or used as an attack vector.
	//
	if (Object.create) {
	  Events.prototype = Object.create(null);

	  //
	  // This hack is needed because the `__proto__` property is still inherited in
	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
	  //
	  if (!new Events().__proto__) prefix = false;
	}

	/**
	 * Representation of a single event listener.
	 *
	 * @param {Function} fn The listener function.
	 * @param {*} context The context to invoke the listener with.
	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
	 * @constructor
	 * @private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Add a listener for a given event.
	 *
	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} context The context to invoke the listener with.
	 * @param {Boolean} once Specify if the listener is a one-time listener.
	 * @returns {EventEmitter}
	 * @private
	 */
	function addListener(emitter, event, fn, context, once) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('The listener must be a function');
	  }

	  var listener = new EE(fn, context || emitter, once)
	    , evt = prefix ? prefix + event : event;

	  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
	  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
	  else emitter._events[evt] = [emitter._events[evt], listener];

	  return emitter;
	}

	/**
	 * Clear event by name.
	 *
	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	 * @param {(String|Symbol)} evt The Event name.
	 * @private
	 */
	function clearEvent(emitter, evt) {
	  if (--emitter._eventsCount === 0) emitter._events = new Events();
	  else delete emitter._events[evt];
	}

	/**
	 * Minimal `EventEmitter` interface that is molded against the Node.js
	 * `EventEmitter` interface.
	 *
	 * @constructor
	 * @public
	 */
	function EventEmitter() {
	  this._events = new Events();
	  this._eventsCount = 0;
	}

	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var names = []
	    , events
	    , name;

	  if (this._eventsCount === 0) return names;

	  for (name in (events = this._events)) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }

	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }

	  return names;
	};

	/**
	 * Return the listeners registered for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Array} The registered listeners.
	 * @public
	 */
	EventEmitter.prototype.listeners = function listeners(event) {
	  var evt = prefix ? prefix + event : event
	    , handlers = this._events[evt];

	  if (!handlers) return [];
	  if (handlers.fn) return [handlers.fn];

	  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
	    ee[i] = handlers[i].fn;
	  }

	  return ee;
	};

	/**
	 * Return the number of listeners listening to a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Number} The number of listeners.
	 * @public
	 */
	EventEmitter.prototype.listenerCount = function listenerCount(event) {
	  var evt = prefix ? prefix + event : event
	    , listeners = this._events[evt];

	  if (!listeners) return 0;
	  if (listeners.fn) return 1;
	  return listeners.length;
	};

	/**
	 * Calls each of the listeners registered for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Boolean} `true` if the event had listeners, else `false`.
	 * @public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return false;

	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;

	  if (listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }

	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }

	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;

	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }

	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }

	  return true;
	};

	/**
	 * Add a listener for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  return addListener(this, event, fn, context, false);
	};

	/**
	 * Add a one-time listener for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  return addListener(this, event, fn, context, true);
	};

	/**
	 * Remove the listeners of a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn Only remove the listeners that match this function.
	 * @param {*} context Only remove the listeners that have this context.
	 * @param {Boolean} once Only remove one-time listeners.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return this;
	  if (!fn) {
	    clearEvent(this, evt);
	    return this;
	  }

	  var listeners = this._events[evt];

	  if (listeners.fn) {
	    if (
	      listeners.fn === fn &&
	      (!once || listeners.once) &&
	      (!context || listeners.context === context)
	    ) {
	      clearEvent(this, evt);
	    }
	  } else {
	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
	      if (
	        listeners[i].fn !== fn ||
	        (once && !listeners[i].once) ||
	        (context && listeners[i].context !== context)
	      ) {
	        events.push(listeners[i]);
	      }
	    }

	    //
	    // Reset the array, or remove it completely if we have no more listeners.
	    //
	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
	    else clearEvent(this, evt);
	  }

	  return this;
	};

	/**
	 * Remove all listeners, or those of the specified event.
	 *
	 * @param {(String|Symbol)} [event] The event name.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  var evt;

	  if (event) {
	    evt = prefix ? prefix + event : event;
	    if (this._events[evt]) clearEvent(this, evt);
	  } else {
	    this._events = new Events();
	    this._eventsCount = 0;
	  }

	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;

	//
	// Allow `EventEmitter` to be imported as module namespace.
	//
	EventEmitter.EventEmitter = EventEmitter;

	//
	// Expose the module.
	//
	{
	  module.exports = EventEmitter;
	}
} (eventemitter3));

var EventEmitter = eventemitter3.exports;

/**
 * an event system based on nodeJS EventEmitter interface
 * @namespace event
 */

// internal instance of the event emiter
var eventEmitter = new EventEmitter();

/**
 * event when the DOM is Ready is booting
 * @public
 * @constant
 * @type {string}
 * @name DOM_READY
 * @memberof event
 * @see event.on
 */
const DOM_READY = "dom_ready";

/**
 * event when the system is booting
 * @public
 * @constant
 * @type {string}
 * @name BOOT
 * @memberof event
 * @see event.on
 */
const BOOT = "me.boot";

/**
 * event when the game is paused <br>
 * Data passed : none <br>
 * @public
 * @constant
 * @type {string}
 * @name STATE_PAUSE
 * @memberof event
 * @see event.on
 */
const STATE_PAUSE = "me.state.onPause";

/**
 * event for when the game is resumed <br>
 * Data passed : {number} time in ms the game was paused
 * @public
 * @constant
 * @type {string}
 * @name STATE_RESUME
 * @memberof event
 * @see event.on
 */
const STATE_RESUME = "me.state.onResume";

/**
 * event when the game is stopped <br>
 * Data passed : none <br>
 * @public
 * @constant
 * @type {string}
 * @name STATE_STOP
 * @memberof event
 * @see event.on
 */
const STATE_STOP = "me.state.onStop";

/**
 * event for when the game is restarted <br>
 * Data passed : {number} time in ms the game was stopped
 * @public
 * @constant
 * @type {string}
 * @name STATE_RESTART
 * @memberof event
 * @see event.on
 */
const STATE_RESTART = "me.state.onRestart";

/**
 * event for when the changing to a different stage
 * @public
 * @constant
 * @type {string}
 * @name STATE_CHANGE
 * @memberof event
 * @see event.on
 */
const STATE_CHANGE = "me.state.onChange";

/**
 * event for when the video is initialized<br>
 * Data passed : none <br>
 * @public
 * @constant
 * @type {string}
 * @name VIDEO_INIT
 * @memberof event
 * @see video.init
 * @see event.on
 */
const VIDEO_INIT = "me.video.onInit";

/**
 * event for when the game manager is initialized <br>
 * Data passed : none <br>
 * @public
 * @constant
 * @type {string}
 * @name GAME_INIT
 * @memberof event
 * @see event.on
 */
const GAME_INIT = "me.game.onInit";

/**
 * event for when the game manager is resetted <br>
 * Data passed : none <br>
 * @public
 * @constant
 * @type {string}
 * @name GAME_RESET
 * @memberof event
 * @see event.on
 */
const GAME_RESET = "me.game.onReset";

/**
 * event for when the engine is about to start a new game loop
 * Data passed : {number} time the current time stamp
 * @public
 * @constant
 * @type {string}
 * @name GAME_BEFORE_UPDATE
 * @memberof event
 * @see event.on
 */
const GAME_BEFORE_UPDATE = "me.game.beforeUpdate";

/**
 * event for the end of the update loop
 * Data passed : {number} time the current time stamp
 * @public
 * @constant
 * @type {string}
 * @name GAME_AFTER_UPDATE
 * @memberof event
 * @see event.on
 */
const GAME_AFTER_UPDATE = "me.game.afterUpdate";

/**
 * Event for when the game is updated (will be impacted by frame skip, frame interpolation and pause/resume state) <br>
 * Data passed : {number} time the current time stamp
 * @public
 * @constant
 * @type {string}
 * @name GAME_UPDATE
 * @memberof event
 * @see event.on
 */
const GAME_UPDATE = "me.game.onUpdate";

/**
 * Event for the end of the draw loop
 * Data passed : {number} time the current time stamp
 * @public
 * @constant
 * @type {string}
 * @name GAME_BEFORE_DRAW
 * @memberof event
 * @see event.on
 */
const GAME_BEFORE_DRAW = "me.game.beforeDraw";

/**
 * Event for the start of the draw loop
 * Data passed : {number} time the current time stamp
 * @public
 * @constant
 * @type {string}
 * @name GAME_AFTER_DRAW
 * @memberof event
 * @see event.on
 */
const GAME_AFTER_DRAW = "me.game.afterDraw";

/**
 * Event for when a level is loaded <br>
 * Data passed : {string} Level Name
 * @public
 * @constant
 * @type {string}
 * @name LEVEL_LOADED
 * @memberof event
 * @see event.on
 */
const LEVEL_LOADED = "me.game.onLevelLoaded";

/**
 * Event for when everything has loaded <br>
 * Data passed : none <br>
 * @public
 * @constant
 * @type {string}
 * @name LOADER_COMPLETE
 * @memberof event
 * @see event.on
 */
const LOADER_COMPLETE = "me.loader.onload";

/**
 * Event for displaying a load progress indicator <br>
 * Data passed : {number} [0 .. 1], {Resource} resource object<br>
 * @public
 * @constant
 * @type {string}
 * @name LOADER_PROGRESS
 * @memberof event
 * @see event.on
 */
const LOADER_PROGRESS = "me.loader.onProgress";

/**
 * Event for pressing a binded key <br>
 * Data passed : {string} user-defined action, {number} keyCode,
 * {boolean} edge state <br>
 * Edge-state is for detecting "locked" key bindings. When a locked key
 * is pressed and held, the first event will have the third argument
 * set true. Subsequent events will continue firing with the third
 * argument set false.
 * @public
 * @constant
 * @type {string}
 * @name KEYDOWN
 * @memberof event
 * @see event.on
 * @example
 * me.input.bindKey(me.input.KEY.X, "jump", true); // Edge-triggered
 * me.input.bindKey(me.input.KEY.Z, "shoot"); // Level-triggered
 * me.event.on(me.event.KEYDOWN, (action, keyCode, edge) => {
 *   // Checking bound keys
 *   if (action === "jump") {
 *       if (edge) {
 *           this.doJump();
 *       }
 *
 *       // Make character fall slower when holding the jump key
 *       this.vel.y = this.body.gravity;
 *   }
 * });
 */
const KEYDOWN = "me.input.keydown";

/**
 * Event for releasing a binded key <br>
 * Data passed : {string} user-defined action, {number} keyCode
 * @public
 * @constant
 * @type {string}
 * @name KEYUP
 * @memberof event
 * @see event.on
 * @example
 * me.event.on(me.event.KEYUP, (action, keyCode) => {
 *   // Checking unbound keys
 *   if (keyCode == me.input.KEY.ESC) {
 *       if (me.state.isPaused()) {
 *           me.state.resume();
 *       }
 *       else {
 *           me.state.pause();
 *       }
 *   }
 * });
 */
const KEYUP = "me.input.keyup";

/**
 * Event for when a gamepad is connected <br>
 * Data passed : {object} gamepad object
 * @public
 * @constant
 * @type {string}
 * @name GAMEPAD_CONNECTED
 * @memberof event
 * @see event.on
 */
const GAMEPAD_CONNECTED = "gamepad.connected";

/**
 * Event for when a gamepad is disconnected <br>
 * Data passed : {object} gamepad object
 * @public
 * @constant
 * @type {string}
 * @name GAMEPAD_DISCONNECTED
 * @memberof event
 * @see event.on
 */
const GAMEPAD_DISCONNECTED = "gamepad.disconnected";

/**
 * Event for when gamepad button/axis state is updated <br>
 * Data passed : {number} index <br>
 * Data passed : {string} type : "axes" or "buttons" <br>
 * Data passed : {number} button <br>
 * Data passed : {number} current.value <br>
 * Data passed : {boolean} current.pressed
 * @public
 * @constant
 * @type {string}
 * @name GAMEPAD_UPDATE
 * @memberof event
 * @see event.on
 */
const GAMEPAD_UPDATE = "gamepad.update";

/**
 * Event for pointermove events on the screen area <br>
 * Data passed : {me.Pointer} a Pointer object
 * @public
 * @constant
 * @type {string}
 * @name POINTERMOVE
 * @memberof event
 * @see event.on
 */
const POINTERMOVE = "me.event.pointermove";

/**
 * Event for onPointerLockChange event <br>
 * Data passed : {boolean} pointer lock status (true/false)
 * @public
 * @constant
 * @type {string}
 * @name POINTERLOCKCHANGE
 * @memberof event
 * @see event.on
 */
const POINTERLOCKCHANGE = "me.event.pointerlockChange";

/**
 * Event for dragstart events on a Draggable entity <br>
 * Data passed:
 * {object} the drag event <br>
 * {object} the Draggable entity
 * @public
 * @constant
 * @type {string}
 * @name DRAGSTART
 * @memberof event
 * @see event.on
 */
const DRAGSTART = "me.game.dragstart";

/**
 * Event for dragend events on a Draggable entity <br>
 * Data passed:
 * {object} the drag event <br>
 * {object} the Draggable entity
 * @public
 * @constant
 * @type {string}
 * @name DRAGEND
 * @memberof event
 * @see event.on
 */
const DRAGEND = "me.game.dragend";

/**
 * Event for when the (browser) window is resized <br>
 * Data passed : {Event} Event object
 * @public
 * @constant
 * @type {string}
 * @name WINDOW_ONRESIZE
 * @memberof event
 * @see event.on
 */
const WINDOW_ONRESIZE = "globalThis.onresize";

/**
 * Event for when the canvas is resized <br>
 * (this usually follows a WINDOW_ONRESIZE event).<br>
 * Data passed : {number} canvas width <br>
 * Data passed : {number} canvas height
 * @public
 * @constant
 * @type {string}
 * @name CANVAS_ONRESIZE
 * @memberof event
 * @see event.on
 */
const CANVAS_ONRESIZE = "canvas.onresize";

/**
 * Event for when the viewport is resized <br>
 * (this usually follows a WINDOW_ONRESIZE event, when using the `flex` scaling mode is used and after the viewport was updated).<br>
 * Data passed : {number} viewport width <br>
 * Data passed : {number} viewport height
 * @public
 * @constant
 * @type {string}
 * @name VIEWPORT_ONRESIZE
 * @memberof event
 * @see event.on
 */
const VIEWPORT_ONRESIZE = "viewport.onresize";

/**
 * Event for when the device is rotated <br>
 * Data passed : {Event} Event object <br>
 * @public
 * @constant
 * @type {string}
 * @name WINDOW_ONORIENTATION_CHANGE
 * @memberof event
 * @see event.on
 */
const WINDOW_ONORIENTATION_CHANGE = "globalThis.orientationchange";

/**
 * Event for when the (browser) window is scrolled <br>
 * Data passed : {Event} Event object
 * @public
 * @constant
 * @type {string}
 * @name WINDOW_ONSCROLL
 * @memberof event
 * @see event.on
 */
const WINDOW_ONSCROLL = "globalThis.onscroll";

/**
 * Event for when the viewport position is updated <br>
 * Data passed : {me.Vector2d} viewport position vector
 * @public
 * @constant
 * @type {string}
 * @name VIEWPORT_ONCHANGE
 * @memberof event
 * @see event.on
 */
const VIEWPORT_ONCHANGE = "viewport.onchange";

/**
 * Event for when the current context is lost <br>
 * Data passed : {me.Renderer} the current renderer instance
 * @public
 * @constant
 * @type {string}
 * @name WEBGL_ONCONTEXT_LOST
 * @memberof event
 * @see event.on
 */
const ONCONTEXT_LOST = "renderer.contextlost";

/**
 * Event for when the current context is restored <br>
 * Data passed : {me.Renderer} the current renderer instance`
 * @public
 * @constant
 * @type {string}
 * @name ONCONTEXT_RESTORED
 * @memberof event
 * @see event.on
 */
const ONCONTEXT_RESTORED = "renderer.contextrestored";

/**
 * calls each of the listeners registered for a given event.
 * @function event.emit
 * @param {string|symbol} eventName The event name.
 * @param {object} [...arguments] arguments to be passed to all listeners
 * @returns {boolean} true if the event had listeners, false otherwise.
 * @example
 * me.event.emit("event-name", a, b, c);
 */
function emit(eventName, ...args) {
    return eventEmitter.emit(eventName, ...args);
}
/**
 * Add a listener for a given event.
 * @function event.on
 * @param {string|symbol} eventName The event name.
 * @param {Function} listener The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 * @example
 * me.event.on("event-name", myFunction, this);
 */
function on(eventName, listener, context) {
    return eventEmitter.on(eventName, listener, context);
}
/**
 * Add a one-time listener for a given event.
 * @function event.once
 * @param {string|symbol} eventName The event name.
 * @param {Function} listener The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 * @example
 * me.event.once("event-name", myFunction, this);
 */
function once(eventName, listener, context) {
    return eventEmitter.once(eventName, listener, context);
}
/**
 * remove the given listener for a given event.
 * @function event.off
 * @param {string|symbol} eventName The event name.
 * @param {Function} listener The listener function.
 * @returns {EventEmitter} `this`.
 * @public
 * @example
 * me.event.off("event-name", myFunction);
 */
function off(eventName, listener) {
    return eventEmitter.off(eventName, listener);
}

var event = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DOM_READY: DOM_READY,
	BOOT: BOOT,
	STATE_PAUSE: STATE_PAUSE,
	STATE_RESUME: STATE_RESUME,
	STATE_STOP: STATE_STOP,
	STATE_RESTART: STATE_RESTART,
	STATE_CHANGE: STATE_CHANGE,
	VIDEO_INIT: VIDEO_INIT,
	GAME_INIT: GAME_INIT,
	GAME_RESET: GAME_RESET,
	GAME_BEFORE_UPDATE: GAME_BEFORE_UPDATE,
	GAME_AFTER_UPDATE: GAME_AFTER_UPDATE,
	GAME_UPDATE: GAME_UPDATE,
	GAME_BEFORE_DRAW: GAME_BEFORE_DRAW,
	GAME_AFTER_DRAW: GAME_AFTER_DRAW,
	LEVEL_LOADED: LEVEL_LOADED,
	LOADER_COMPLETE: LOADER_COMPLETE,
	LOADER_PROGRESS: LOADER_PROGRESS,
	KEYDOWN: KEYDOWN,
	KEYUP: KEYUP,
	GAMEPAD_CONNECTED: GAMEPAD_CONNECTED,
	GAMEPAD_DISCONNECTED: GAMEPAD_DISCONNECTED,
	GAMEPAD_UPDATE: GAMEPAD_UPDATE,
	POINTERMOVE: POINTERMOVE,
	POINTERLOCKCHANGE: POINTERLOCKCHANGE,
	DRAGSTART: DRAGSTART,
	DRAGEND: DRAGEND,
	WINDOW_ONRESIZE: WINDOW_ONRESIZE,
	CANVAS_ONRESIZE: CANVAS_ONRESIZE,
	VIEWPORT_ONRESIZE: VIEWPORT_ONRESIZE,
	WINDOW_ONORIENTATION_CHANGE: WINDOW_ONORIENTATION_CHANGE,
	WINDOW_ONSCROLL: WINDOW_ONSCROLL,
	VIEWPORT_ONCHANGE: VIEWPORT_ONCHANGE,
	ONCONTEXT_LOST: ONCONTEXT_LOST,
	ONCONTEXT_RESTORED: ONCONTEXT_RESTORED,
	emit: emit,
	on: on,
	once: once,
	off: off
});

var howler = {};

/*!
 *  howler.js v2.2.3
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function (exports) {
	(function() {

	  /** Global Methods **/
	  /***************************************************************************/

	  /**
	   * Create the global controller. All contained methods and properties apply
	   * to all sounds that are currently playing or will be in the future.
	   */
	  var HowlerGlobal = function() {
	    this.init();
	  };
	  HowlerGlobal.prototype = {
	    /**
	     * Initialize the global Howler object.
	     * @return {Howler}
	     */
	    init: function() {
	      var self = this || Howler;

	      // Create a global ID counter.
	      self._counter = 1000;

	      // Pool of unlocked HTML5 Audio objects.
	      self._html5AudioPool = [];
	      self.html5PoolSize = 10;

	      // Internal properties.
	      self._codecs = {};
	      self._howls = [];
	      self._muted = false;
	      self._volume = 1;
	      self._canPlayEvent = 'canplaythrough';
	      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;

	      // Public properties.
	      self.masterGain = null;
	      self.noAudio = false;
	      self.usingWebAudio = true;
	      self.autoSuspend = true;
	      self.ctx = null;

	      // Set to false to disable the auto audio unlocker.
	      self.autoUnlock = true;

	      // Setup the various state values for global tracking.
	      self._setup();

	      return self;
	    },

	    /**
	     * Get/set the global volume for all sounds.
	     * @param  {Float} vol Volume from 0.0 to 1.0.
	     * @return {Howler/Float}     Returns self or current volume.
	     */
	    volume: function(vol) {
	      var self = this || Howler;
	      vol = parseFloat(vol);

	      // If we don't have an AudioContext created yet, run the setup.
	      if (!self.ctx) {
	        setupAudioContext();
	      }

	      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
	        self._volume = vol;

	        // Don't update any of the nodes if we are muted.
	        if (self._muted) {
	          return self;
	        }

	        // When using Web Audio, we just need to adjust the master gain.
	        if (self.usingWebAudio) {
	          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
	        }

	        // Loop through and change volume for all HTML5 audio nodes.
	        for (var i=0; i<self._howls.length; i++) {
	          if (!self._howls[i]._webAudio) {
	            // Get all of the sounds in this Howl group.
	            var ids = self._howls[i]._getSoundIds();

	            // Loop through all sounds and change the volumes.
	            for (var j=0; j<ids.length; j++) {
	              var sound = self._howls[i]._soundById(ids[j]);

	              if (sound && sound._node) {
	                sound._node.volume = sound._volume * vol;
	              }
	            }
	          }
	        }

	        return self;
	      }

	      return self._volume;
	    },

	    /**
	     * Handle muting and unmuting globally.
	     * @param  {Boolean} muted Is muted or not.
	     */
	    mute: function(muted) {
	      var self = this || Howler;

	      // If we don't have an AudioContext created yet, run the setup.
	      if (!self.ctx) {
	        setupAudioContext();
	      }

	      self._muted = muted;

	      // With Web Audio, we just need to mute the master gain.
	      if (self.usingWebAudio) {
	        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
	      }

	      // Loop through and mute all HTML5 Audio nodes.
	      for (var i=0; i<self._howls.length; i++) {
	        if (!self._howls[i]._webAudio) {
	          // Get all of the sounds in this Howl group.
	          var ids = self._howls[i]._getSoundIds();

	          // Loop through all sounds and mark the audio node as muted.
	          for (var j=0; j<ids.length; j++) {
	            var sound = self._howls[i]._soundById(ids[j]);

	            if (sound && sound._node) {
	              sound._node.muted = (muted) ? true : sound._muted;
	            }
	          }
	        }
	      }

	      return self;
	    },

	    /**
	     * Handle stopping all sounds globally.
	     */
	    stop: function() {
	      var self = this || Howler;

	      // Loop through all Howls and stop them.
	      for (var i=0; i<self._howls.length; i++) {
	        self._howls[i].stop();
	      }

	      return self;
	    },

	    /**
	     * Unload and destroy all currently loaded Howl objects.
	     * @return {Howler}
	     */
	    unload: function() {
	      var self = this || Howler;

	      for (var i=self._howls.length-1; i>=0; i--) {
	        self._howls[i].unload();
	      }

	      // Create a new AudioContext to make sure it is fully reset.
	      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
	        self.ctx.close();
	        self.ctx = null;
	        setupAudioContext();
	      }

	      return self;
	    },

	    /**
	     * Check for codec support of specific extension.
	     * @param  {String} ext Audio file extention.
	     * @return {Boolean}
	     */
	    codecs: function(ext) {
	      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
	    },

	    /**
	     * Setup various state values for global tracking.
	     * @return {Howler}
	     */
	    _setup: function() {
	      var self = this || Howler;

	      // Keeps track of the suspend/resume state of the AudioContext.
	      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';

	      // Automatically begin the 30-second suspend process
	      self._autoSuspend();

	      // Check if audio is available.
	      if (!self.usingWebAudio) {
	        // No audio is available on this system if noAudio is set to true.
	        if (typeof Audio !== 'undefined') {
	          try {
	            var test = new Audio();

	            // Check if the canplaythrough event is available.
	            if (typeof test.oncanplaythrough === 'undefined') {
	              self._canPlayEvent = 'canplay';
	            }
	          } catch(e) {
	            self.noAudio = true;
	          }
	        } else {
	          self.noAudio = true;
	        }
	      }

	      // Test to make sure audio isn't disabled in Internet Explorer.
	      try {
	        var test = new Audio();
	        if (test.muted) {
	          self.noAudio = true;
	        }
	      } catch (e) {}

	      // Check for supported codecs.
	      if (!self.noAudio) {
	        self._setupCodecs();
	      }

	      return self;
	    },

	    /**
	     * Check for browser support for various codecs and cache the results.
	     * @return {Howler}
	     */
	    _setupCodecs: function() {
	      var self = this || Howler;
	      var audioTest = null;

	      // Must wrap in a try/catch because IE11 in server mode throws an error.
	      try {
	        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
	      } catch (err) {
	        return self;
	      }

	      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
	        return self;
	      }

	      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');

	      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
	      var ua = self._navigator ? self._navigator.userAgent : '';
	      var checkOpera = ua.match(/OPR\/([0-6].)/g);
	      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);
	      var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;
	      var safariVersion = ua.match(/Version\/(.*?) /);
	      var isOldSafari = (checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15);

	      self._codecs = {
	        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
	        mpeg: !!mpegTest,
	        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
	        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
	        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
	        wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),
	        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
	        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
	        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
	        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
	        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
	        weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
	        webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
	        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
	        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
	      };

	      return self;
	    },

	    /**
	     * Some browsers/devices will only allow audio to be played after a user interaction.
	     * Attempt to automatically unlock audio on the first user interaction.
	     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
	     * @return {Howler}
	     */
	    _unlockAudio: function() {
	      var self = this || Howler;

	      // Only run this if Web Audio is supported and it hasn't already been unlocked.
	      if (self._audioUnlocked || !self.ctx) {
	        return;
	      }

	      self._audioUnlocked = false;
	      self.autoUnlock = false;

	      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
	      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
	      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
	      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
	        self._mobileUnloaded = true;
	        self.unload();
	      }

	      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
	      // http://stackoverflow.com/questions/24119684
	      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);

	      // Call this method on touch start to create and play a buffer,
	      // then check if the audio actually played to determine if
	      // audio has now been unlocked on iOS, Android, etc.
	      var unlock = function(e) {
	        // Create a pool of unlocked HTML5 Audio objects that can
	        // be used for playing sounds without user interaction. HTML5
	        // Audio objects must be individually unlocked, as opposed
	        // to the WebAudio API which only needs a single activation.
	        // This must occur before WebAudio setup or the source.onended
	        // event will not fire.
	        while (self._html5AudioPool.length < self.html5PoolSize) {
	          try {
	            var audioNode = new Audio();

	            // Mark this Audio object as unlocked to ensure it can get returned
	            // to the unlocked pool when released.
	            audioNode._unlocked = true;

	            // Add the audio node to the pool.
	            self._releaseHtml5Audio(audioNode);
	          } catch (e) {
	            self.noAudio = true;
	            break;
	          }
	        }

	        // Loop through any assigned audio nodes and unlock them.
	        for (var i=0; i<self._howls.length; i++) {
	          if (!self._howls[i]._webAudio) {
	            // Get all of the sounds in this Howl group.
	            var ids = self._howls[i]._getSoundIds();

	            // Loop through all sounds and unlock the audio nodes.
	            for (var j=0; j<ids.length; j++) {
	              var sound = self._howls[i]._soundById(ids[j]);

	              if (sound && sound._node && !sound._node._unlocked) {
	                sound._node._unlocked = true;
	                sound._node.load();
	              }
	            }
	          }
	        }

	        // Fix Android can not play in suspend state.
	        self._autoResume();

	        // Create an empty buffer.
	        var source = self.ctx.createBufferSource();
	        source.buffer = self._scratchBuffer;
	        source.connect(self.ctx.destination);

	        // Play the empty buffer.
	        if (typeof source.start === 'undefined') {
	          source.noteOn(0);
	        } else {
	          source.start(0);
	        }

	        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
	        if (typeof self.ctx.resume === 'function') {
	          self.ctx.resume();
	        }

	        // Setup a timeout to check that we are unlocked on the next event loop.
	        source.onended = function() {
	          source.disconnect(0);

	          // Update the unlocked state and prevent this check from happening again.
	          self._audioUnlocked = true;

	          // Remove the touch start listener.
	          document.removeEventListener('touchstart', unlock, true);
	          document.removeEventListener('touchend', unlock, true);
	          document.removeEventListener('click', unlock, true);
	          document.removeEventListener('keydown', unlock, true);

	          // Let all sounds know that audio has been unlocked.
	          for (var i=0; i<self._howls.length; i++) {
	            self._howls[i]._emit('unlock');
	          }
	        };
	      };

	      // Setup a touch start listener to attempt an unlock in.
	      document.addEventListener('touchstart', unlock, true);
	      document.addEventListener('touchend', unlock, true);
	      document.addEventListener('click', unlock, true);
	      document.addEventListener('keydown', unlock, true);

	      return self;
	    },

	    /**
	     * Get an unlocked HTML5 Audio object from the pool. If none are left,
	     * return a new Audio object and throw a warning.
	     * @return {Audio} HTML5 Audio object.
	     */
	    _obtainHtml5Audio: function() {
	      var self = this || Howler;

	      // Return the next object from the pool if one exists.
	      if (self._html5AudioPool.length) {
	        return self._html5AudioPool.pop();
	      }

	      //.Check if the audio is locked and throw a warning.
	      var testPlay = new Audio().play();
	      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {
	        testPlay.catch(function() {
	          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
	        });
	      }

	      return new Audio();
	    },

	    /**
	     * Return an activated HTML5 Audio object to the pool.
	     * @return {Howler}
	     */
	    _releaseHtml5Audio: function(audio) {
	      var self = this || Howler;

	      // Don't add audio to the pool if we don't know if it has been unlocked.
	      if (audio._unlocked) {
	        self._html5AudioPool.push(audio);
	      }

	      return self;
	    },

	    /**
	     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
	     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
	     * @return {Howler}
	     */
	    _autoSuspend: function() {
	      var self = this;

	      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
	        return;
	      }

	      // Check if any sounds are playing.
	      for (var i=0; i<self._howls.length; i++) {
	        if (self._howls[i]._webAudio) {
	          for (var j=0; j<self._howls[i]._sounds.length; j++) {
	            if (!self._howls[i]._sounds[j]._paused) {
	              return self;
	            }
	          }
	        }
	      }

	      if (self._suspendTimer) {
	        clearTimeout(self._suspendTimer);
	      }

	      // If no sound has played after 30 seconds, suspend the context.
	      self._suspendTimer = setTimeout(function() {
	        if (!self.autoSuspend) {
	          return;
	        }

	        self._suspendTimer = null;
	        self.state = 'suspending';

	        // Handle updating the state of the audio context after suspending.
	        var handleSuspension = function() {
	          self.state = 'suspended';

	          if (self._resumeAfterSuspend) {
	            delete self._resumeAfterSuspend;
	            self._autoResume();
	          }
	        };

	        // Either the state gets suspended or it is interrupted.
	        // Either way, we need to update the state to suspended.
	        self.ctx.suspend().then(handleSuspension, handleSuspension);
	      }, 30000);

	      return self;
	    },

	    /**
	     * Automatically resume the Web Audio AudioContext when a new sound is played.
	     * @return {Howler}
	     */
	    _autoResume: function() {
	      var self = this;

	      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
	        return;
	      }

	      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {
	        clearTimeout(self._suspendTimer);
	        self._suspendTimer = null;
	      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {
	        self.ctx.resume().then(function() {
	          self.state = 'running';

	          // Emit to all Howls that the audio has resumed.
	          for (var i=0; i<self._howls.length; i++) {
	            self._howls[i]._emit('resume');
	          }
	        });

	        if (self._suspendTimer) {
	          clearTimeout(self._suspendTimer);
	          self._suspendTimer = null;
	        }
	      } else if (self.state === 'suspending') {
	        self._resumeAfterSuspend = true;
	      }

	      return self;
	    }
	  };

	  // Setup the global audio controller.
	  var Howler = new HowlerGlobal();

	  /** Group Methods **/
	  /***************************************************************************/

	  /**
	   * Create an audio group controller.
	   * @param {Object} o Passed in properties for this group.
	   */
	  var Howl = function(o) {
	    var self = this;

	    // Throw an error if no source is provided.
	    if (!o.src || o.src.length === 0) {
	      console.error('An array of source files must be passed with any new Howl.');
	      return;
	    }

	    self.init(o);
	  };
	  Howl.prototype = {
	    /**
	     * Initialize a new Howl group object.
	     * @param  {Object} o Passed in properties for this group.
	     * @return {Howl}
	     */
	    init: function(o) {
	      var self = this;

	      // If we don't have an AudioContext created yet, run the setup.
	      if (!Howler.ctx) {
	        setupAudioContext();
	      }

	      // Setup user-defined default properties.
	      self._autoplay = o.autoplay || false;
	      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
	      self._html5 = o.html5 || false;
	      self._muted = o.mute || false;
	      self._loop = o.loop || false;
	      self._pool = o.pool || 5;
	      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;
	      self._rate = o.rate || 1;
	      self._sprite = o.sprite || {};
	      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
	      self._volume = o.volume !== undefined ? o.volume : 1;
	      self._xhr = {
	        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',
	        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
	        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,
	      };

	      // Setup all other default properties.
	      self._duration = 0;
	      self._state = 'unloaded';
	      self._sounds = [];
	      self._endTimers = {};
	      self._queue = [];
	      self._playLock = false;

	      // Setup event listeners.
	      self._onend = o.onend ? [{fn: o.onend}] : [];
	      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
	      self._onload = o.onload ? [{fn: o.onload}] : [];
	      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
	      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];
	      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
	      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
	      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
	      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
	      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
	      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
	      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
	      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];
	      self._onresume = [];

	      // Web Audio or HTML5 Audio?
	      self._webAudio = Howler.usingWebAudio && !self._html5;

	      // Automatically try to enable audio.
	      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {
	        Howler._unlockAudio();
	      }

	      // Keep track of this Howl group in the global controller.
	      Howler._howls.push(self);

	      // If they selected autoplay, add a play event to the load queue.
	      if (self._autoplay) {
	        self._queue.push({
	          event: 'play',
	          action: function() {
	            self.play();
	          }
	        });
	      }

	      // Load the source file unless otherwise specified.
	      if (self._preload && self._preload !== 'none') {
	        self.load();
	      }

	      return self;
	    },

	    /**
	     * Load the audio file.
	     * @return {Howler}
	     */
	    load: function() {
	      var self = this;
	      var url = null;

	      // If no audio is available, quit immediately.
	      if (Howler.noAudio) {
	        self._emit('loaderror', null, 'No audio support.');
	        return;
	      }

	      // Make sure our source is in an array.
	      if (typeof self._src === 'string') {
	        self._src = [self._src];
	      }

	      // Loop through the sources and pick the first one that is compatible.
	      for (var i=0; i<self._src.length; i++) {
	        var ext, str;

	        if (self._format && self._format[i]) {
	          // If an extension was specified, use that instead.
	          ext = self._format[i];
	        } else {
	          // Make sure the source is a string.
	          str = self._src[i];
	          if (typeof str !== 'string') {
	            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
	            continue;
	          }

	          // Extract the file extension from the URL or base64 data URI.
	          ext = /^data:audio\/([^;,]+);/i.exec(str);
	          if (!ext) {
	            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
	          }

	          if (ext) {
	            ext = ext[1].toLowerCase();
	          }
	        }

	        // Log a warning if no extension was found.
	        if (!ext) {
	          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
	        }

	        // Check if this extension is available.
	        if (ext && Howler.codecs(ext)) {
	          url = self._src[i];
	          break;
	        }
	      }

	      if (!url) {
	        self._emit('loaderror', null, 'No codec support for selected audio sources.');
	        return;
	      }

	      self._src = url;
	      self._state = 'loading';

	      // If the hosting page is HTTPS and the source isn't,
	      // drop down to HTML5 Audio to avoid Mixed Content errors.
	      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
	        self._html5 = true;
	        self._webAudio = false;
	      }

	      // Create a new sound object and add it to the pool.
	      new Sound(self);

	      // Load and decode the audio data for playback.
	      if (self._webAudio) {
	        loadBuffer(self);
	      }

	      return self;
	    },

	    /**
	     * Play a sound or resume previous playback.
	     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
	     * @param  {Boolean} internal Internal Use: true prevents event firing.
	     * @return {Number}          Sound ID.
	     */
	    play: function(sprite, internal) {
	      var self = this;
	      var id = null;

	      // Determine if a sprite, sound id or nothing was passed
	      if (typeof sprite === 'number') {
	        id = sprite;
	        sprite = null;
	      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
	        // If the passed sprite doesn't exist, do nothing.
	        return null;
	      } else if (typeof sprite === 'undefined') {
	        // Use the default sound sprite (plays the full audio length).
	        sprite = '__default';

	        // Check if there is a single paused sound that isn't ended.
	        // If there is, play that sound. If not, continue as usual.
	        if (!self._playLock) {
	          var num = 0;
	          for (var i=0; i<self._sounds.length; i++) {
	            if (self._sounds[i]._paused && !self._sounds[i]._ended) {
	              num++;
	              id = self._sounds[i]._id;
	            }
	          }

	          if (num === 1) {
	            sprite = null;
	          } else {
	            id = null;
	          }
	        }
	      }

	      // Get the selected node, or get one from the pool.
	      var sound = id ? self._soundById(id) : self._inactiveSound();

	      // If the sound doesn't exist, do nothing.
	      if (!sound) {
	        return null;
	      }

	      // Select the sprite definition.
	      if (id && !sprite) {
	        sprite = sound._sprite || '__default';
	      }

	      // If the sound hasn't loaded, we must wait to get the audio's duration.
	      // We also need to wait to make sure we don't run into race conditions with
	      // the order of function calls.
	      if (self._state !== 'loaded') {
	        // Set the sprite value on this sound.
	        sound._sprite = sprite;

	        // Mark this sound as not ended in case another sound is played before this one loads.
	        sound._ended = false;

	        // Add the sound to the queue to be played on load.
	        var soundId = sound._id;
	        self._queue.push({
	          event: 'play',
	          action: function() {
	            self.play(soundId);
	          }
	        });

	        return soundId;
	      }

	      // Don't play the sound if an id was passed and it is already playing.
	      if (id && !sound._paused) {
	        // Trigger the play event, in order to keep iterating through queue.
	        if (!internal) {
	          self._loadQueue('play');
	        }

	        return sound._id;
	      }

	      // Make sure the AudioContext isn't suspended, and resume it if it is.
	      if (self._webAudio) {
	        Howler._autoResume();
	      }

	      // Determine how long to play for and where to start playing.
	      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
	      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
	      var timeout = (duration * 1000) / Math.abs(sound._rate);
	      var start = self._sprite[sprite][0] / 1000;
	      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
	      sound._sprite = sprite;

	      // Mark the sound as ended instantly so that this async playback
	      // doesn't get grabbed by another call to play while this one waits to start.
	      sound._ended = false;

	      // Update the parameters of the sound.
	      var setParams = function() {
	        sound._paused = false;
	        sound._seek = seek;
	        sound._start = start;
	        sound._stop = stop;
	        sound._loop = !!(sound._loop || self._sprite[sprite][2]);
	      };

	      // End the sound instantly if seek is at the end.
	      if (seek >= stop) {
	        self._ended(sound);
	        return;
	      }

	      // Begin the actual playback.
	      var node = sound._node;
	      if (self._webAudio) {
	        // Fire this when the sound is ready to play to begin Web Audio playback.
	        var playWebAudio = function() {
	          self._playLock = false;
	          setParams();
	          self._refreshBuffer(sound);

	          // Setup the playback params.
	          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
	          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
	          sound._playStart = Howler.ctx.currentTime;

	          // Play the sound using the supported method.
	          if (typeof node.bufferSource.start === 'undefined') {
	            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
	          } else {
	            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
	          }

	          // Start a new timer if none is present.
	          if (timeout !== Infinity) {
	            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	          }

	          if (!internal) {
	            setTimeout(function() {
	              self._emit('play', sound._id);
	              self._loadQueue();
	            }, 0);
	          }
	        };

	        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {
	          playWebAudio();
	        } else {
	          self._playLock = true;

	          // Wait for the audio context to resume before playing.
	          self.once('resume', playWebAudio);

	          // Cancel the end timer.
	          self._clearTimer(sound._id);
	        }
	      } else {
	        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
	        var playHtml5 = function() {
	          node.currentTime = seek;
	          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
	          node.volume = sound._volume * Howler.volume();
	          node.playbackRate = sound._rate;

	          // Some browsers will throw an error if this is called without user interaction.
	          try {
	            var play = node.play();

	            // Support older browsers that don't support promises, and thus don't have this issue.
	            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
	              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
	              self._playLock = true;

	              // Set param values immediately.
	              setParams();

	              // Releases the lock and executes queued actions.
	              play
	                .then(function() {
	                  self._playLock = false;
	                  node._unlocked = true;
	                  if (!internal) {
	                    self._emit('play', sound._id);
	                  } else {
	                    self._loadQueue();
	                  }
	                })
	                .catch(function() {
	                  self._playLock = false;
	                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
	                    'on mobile devices and Chrome where playback was not within a user interaction.');

	                  // Reset the ended and paused values.
	                  sound._ended = true;
	                  sound._paused = true;
	                });
	            } else if (!internal) {
	              self._playLock = false;
	              setParams();
	              self._emit('play', sound._id);
	            }

	            // Setting rate before playing won't work in IE, so we set it again here.
	            node.playbackRate = sound._rate;

	            // If the node is still paused, then we can assume there was a playback issue.
	            if (node.paused) {
	              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
	                'on mobile devices and Chrome where playback was not within a user interaction.');
	              return;
	            }

	            // Setup the end timer on sprites or listen for the ended event.
	            if (sprite !== '__default' || sound._loop) {
	              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	            } else {
	              self._endTimers[sound._id] = function() {
	                // Fire ended on this audio node.
	                self._ended(sound);

	                // Clear this listener.
	                node.removeEventListener('ended', self._endTimers[sound._id], false);
	              };
	              node.addEventListener('ended', self._endTimers[sound._id], false);
	            }
	          } catch (err) {
	            self._emit('playerror', sound._id, err);
	          }
	        };

	        // If this is streaming audio, make sure the src is set and load again.
	        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {
	          node.src = self._src;
	          node.load();
	        }

	        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
	        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);
	        if (node.readyState >= 3 || loadedNoReadyState) {
	          playHtml5();
	        } else {
	          self._playLock = true;
	          self._state = 'loading';

	          var listener = function() {
	            self._state = 'loaded';
	            
	            // Begin playback.
	            playHtml5();

	            // Clear this listener.
	            node.removeEventListener(Howler._canPlayEvent, listener, false);
	          };
	          node.addEventListener(Howler._canPlayEvent, listener, false);

	          // Cancel the end timer.
	          self._clearTimer(sound._id);
	        }
	      }

	      return sound._id;
	    },

	    /**
	     * Pause playback and save current position.
	     * @param  {Number} id The sound ID (empty to pause all in group).
	     * @return {Howl}
	     */
	    pause: function(id) {
	      var self = this;

	      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
	      if (self._state !== 'loaded' || self._playLock) {
	        self._queue.push({
	          event: 'pause',
	          action: function() {
	            self.pause(id);
	          }
	        });

	        return self;
	      }

	      // If no id is passed, get all ID's to be paused.
	      var ids = self._getSoundIds(id);

	      for (var i=0; i<ids.length; i++) {
	        // Clear the end timer.
	        self._clearTimer(ids[i]);

	        // Get the sound.
	        var sound = self._soundById(ids[i]);

	        if (sound && !sound._paused) {
	          // Reset the seek position.
	          sound._seek = self.seek(ids[i]);
	          sound._rateSeek = 0;
	          sound._paused = true;

	          // Stop currently running fades.
	          self._stopFade(ids[i]);

	          if (sound._node) {
	            if (self._webAudio) {
	              // Make sure the sound has been created.
	              if (!sound._node.bufferSource) {
	                continue;
	              }

	              if (typeof sound._node.bufferSource.stop === 'undefined') {
	                sound._node.bufferSource.noteOff(0);
	              } else {
	                sound._node.bufferSource.stop(0);
	              }

	              // Clean up the buffer source.
	              self._cleanBuffer(sound._node);
	            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
	              sound._node.pause();
	            }
	          }
	        }

	        // Fire the pause event, unless `true` is passed as the 2nd argument.
	        if (!arguments[1]) {
	          self._emit('pause', sound ? sound._id : null);
	        }
	      }

	      return self;
	    },

	    /**
	     * Stop playback and reset to start.
	     * @param  {Number} id The sound ID (empty to stop all in group).
	     * @param  {Boolean} internal Internal Use: true prevents event firing.
	     * @return {Howl}
	     */
	    stop: function(id, internal) {
	      var self = this;

	      // If the sound hasn't loaded, add it to the load queue to stop when capable.
	      if (self._state !== 'loaded' || self._playLock) {
	        self._queue.push({
	          event: 'stop',
	          action: function() {
	            self.stop(id);
	          }
	        });

	        return self;
	      }

	      // If no id is passed, get all ID's to be stopped.
	      var ids = self._getSoundIds(id);

	      for (var i=0; i<ids.length; i++) {
	        // Clear the end timer.
	        self._clearTimer(ids[i]);

	        // Get the sound.
	        var sound = self._soundById(ids[i]);

	        if (sound) {
	          // Reset the seek position.
	          sound._seek = sound._start || 0;
	          sound._rateSeek = 0;
	          sound._paused = true;
	          sound._ended = true;

	          // Stop currently running fades.
	          self._stopFade(ids[i]);

	          if (sound._node) {
	            if (self._webAudio) {
	              // Make sure the sound's AudioBufferSourceNode has been created.
	              if (sound._node.bufferSource) {
	                if (typeof sound._node.bufferSource.stop === 'undefined') {
	                  sound._node.bufferSource.noteOff(0);
	                } else {
	                  sound._node.bufferSource.stop(0);
	                }

	                // Clean up the buffer source.
	                self._cleanBuffer(sound._node);
	              }
	            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
	              sound._node.currentTime = sound._start || 0;
	              sound._node.pause();

	              // If this is a live stream, stop download once the audio is stopped.
	              if (sound._node.duration === Infinity) {
	                self._clearSound(sound._node);
	              }
	            }
	          }

	          if (!internal) {
	            self._emit('stop', sound._id);
	          }
	        }
	      }

	      return self;
	    },

	    /**
	     * Mute/unmute a single sound or all sounds in this Howl group.
	     * @param  {Boolean} muted Set to true to mute and false to unmute.
	     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
	     * @return {Howl}
	     */
	    mute: function(muted, id) {
	      var self = this;

	      // If the sound hasn't loaded, add it to the load queue to mute when capable.
	      if (self._state !== 'loaded'|| self._playLock) {
	        self._queue.push({
	          event: 'mute',
	          action: function() {
	            self.mute(muted, id);
	          }
	        });

	        return self;
	      }

	      // If applying mute/unmute to all sounds, update the group's value.
	      if (typeof id === 'undefined') {
	        if (typeof muted === 'boolean') {
	          self._muted = muted;
	        } else {
	          return self._muted;
	        }
	      }

	      // If no id is passed, get all ID's to be muted.
	      var ids = self._getSoundIds(id);

	      for (var i=0; i<ids.length; i++) {
	        // Get the sound.
	        var sound = self._soundById(ids[i]);

	        if (sound) {
	          sound._muted = muted;

	          // Cancel active fade and set the volume to the end value.
	          if (sound._interval) {
	            self._stopFade(sound._id);
	          }

	          if (self._webAudio && sound._node) {
	            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
	          } else if (sound._node) {
	            sound._node.muted = Howler._muted ? true : muted;
	          }

	          self._emit('mute', sound._id);
	        }
	      }

	      return self;
	    },

	    /**
	     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
	     *   volume() -> Returns the group's volume value.
	     *   volume(id) -> Returns the sound id's current volume.
	     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
	     *   volume(vol, id) -> Sets the volume of passed sound id.
	     * @return {Howl/Number} Returns self or current volume.
	     */
	    volume: function() {
	      var self = this;
	      var args = arguments;
	      var vol, id;

	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // Return the value of the groups' volume.
	        return self._volume;
	      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
	        // First check if this is an ID, and if not, assume it is a new volume.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          vol = parseFloat(args[0]);
	        }
	      } else if (args.length >= 2) {
	        vol = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }

	      // Update the volume or return the current volume.
	      var sound;
	      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
	        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
	        if (self._state !== 'loaded'|| self._playLock) {
	          self._queue.push({
	            event: 'volume',
	            action: function() {
	              self.volume.apply(self, args);
	            }
	          });

	          return self;
	        }

	        // Set the group volume.
	        if (typeof id === 'undefined') {
	          self._volume = vol;
	        }

	        // Update one or all volumes.
	        id = self._getSoundIds(id);
	        for (var i=0; i<id.length; i++) {
	          // Get the sound.
	          sound = self._soundById(id[i]);

	          if (sound) {
	            sound._volume = vol;

	            // Stop currently running fades.
	            if (!args[2]) {
	              self._stopFade(id[i]);
	            }

	            if (self._webAudio && sound._node && !sound._muted) {
	              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
	            } else if (sound._node && !sound._muted) {
	              sound._node.volume = vol * Howler.volume();
	            }

	            self._emit('volume', sound._id);
	          }
	        }
	      } else {
	        sound = id ? self._soundById(id) : self._sounds[0];
	        return sound ? sound._volume : 0;
	      }

	      return self;
	    },

	    /**
	     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
	     * @param  {Number} from The value to fade from (0.0 to 1.0).
	     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
	     * @param  {Number} len  Time in milliseconds to fade.
	     * @param  {Number} id   The sound id (omit to fade all sounds).
	     * @return {Howl}
	     */
	    fade: function(from, to, len, id) {
	      var self = this;

	      // If the sound hasn't loaded, add it to the load queue to fade when capable.
	      if (self._state !== 'loaded' || self._playLock) {
	        self._queue.push({
	          event: 'fade',
	          action: function() {
	            self.fade(from, to, len, id);
	          }
	        });

	        return self;
	      }

	      // Make sure the to/from/len values are numbers.
	      from = Math.min(Math.max(0, parseFloat(from)), 1);
	      to = Math.min(Math.max(0, parseFloat(to)), 1);
	      len = parseFloat(len);

	      // Set the volume to the start position.
	      self.volume(from, id);

	      // Fade the volume of one or all sounds.
	      var ids = self._getSoundIds(id);
	      for (var i=0; i<ids.length; i++) {
	        // Get the sound.
	        var sound = self._soundById(ids[i]);

	        // Create a linear fade or fall back to timeouts with HTML5 Audio.
	        if (sound) {
	          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
	          if (!id) {
	            self._stopFade(ids[i]);
	          }

	          // If we are using Web Audio, let the native methods do the actual fade.
	          if (self._webAudio && !sound._muted) {
	            var currentTime = Howler.ctx.currentTime;
	            var end = currentTime + (len / 1000);
	            sound._volume = from;
	            sound._node.gain.setValueAtTime(from, currentTime);
	            sound._node.gain.linearRampToValueAtTime(to, end);
	          }

	          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
	        }
	      }

	      return self;
	    },

	    /**
	     * Starts the internal interval to fade a sound.
	     * @param  {Object} sound Reference to sound to fade.
	     * @param  {Number} from The value to fade from (0.0 to 1.0).
	     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
	     * @param  {Number} len  Time in milliseconds to fade.
	     * @param  {Number} id   The sound id to fade.
	     * @param  {Boolean} isGroup   If true, set the volume on the group.
	     */
	    _startFadeInterval: function(sound, from, to, len, id, isGroup) {
	      var self = this;
	      var vol = from;
	      var diff = to - from;
	      var steps = Math.abs(diff / 0.01);
	      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);
	      var lastTick = Date.now();

	      // Store the value being faded to.
	      sound._fadeTo = to;

	      // Update the volume value on each interval tick.
	      sound._interval = setInterval(function() {
	        // Update the volume based on the time since the last tick.
	        var tick = (Date.now() - lastTick) / len;
	        lastTick = Date.now();
	        vol += diff * tick;

	        // Round to within 2 decimal points.
	        vol = Math.round(vol * 100) / 100;

	        // Make sure the volume is in the right bounds.
	        if (diff < 0) {
	          vol = Math.max(to, vol);
	        } else {
	          vol = Math.min(to, vol);
	        }

	        // Change the volume.
	        if (self._webAudio) {
	          sound._volume = vol;
	        } else {
	          self.volume(vol, sound._id, true);
	        }

	        // Set the group's volume.
	        if (isGroup) {
	          self._volume = vol;
	        }

	        // When the fade is complete, stop it and fire event.
	        if ((to < from && vol <= to) || (to > from && vol >= to)) {
	          clearInterval(sound._interval);
	          sound._interval = null;
	          sound._fadeTo = null;
	          self.volume(to, sound._id);
	          self._emit('fade', sound._id);
	        }
	      }, stepLen);
	    },

	    /**
	     * Internal method that stops the currently playing fade when
	     * a new fade starts, volume is changed or the sound is stopped.
	     * @param  {Number} id The sound id.
	     * @return {Howl}
	     */
	    _stopFade: function(id) {
	      var self = this;
	      var sound = self._soundById(id);

	      if (sound && sound._interval) {
	        if (self._webAudio) {
	          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
	        }

	        clearInterval(sound._interval);
	        sound._interval = null;
	        self.volume(sound._fadeTo, id);
	        sound._fadeTo = null;
	        self._emit('fade', id);
	      }

	      return self;
	    },

	    /**
	     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   loop() -> Returns the group's loop value.
	     *   loop(id) -> Returns the sound id's loop value.
	     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
	     *   loop(loop, id) -> Sets the loop value of passed sound id.
	     * @return {Howl/Boolean} Returns self or current loop value.
	     */
	    loop: function() {
	      var self = this;
	      var args = arguments;
	      var loop, id, sound;

	      // Determine the values for loop and id.
	      if (args.length === 0) {
	        // Return the grou's loop value.
	        return self._loop;
	      } else if (args.length === 1) {
	        if (typeof args[0] === 'boolean') {
	          loop = args[0];
	          self._loop = loop;
	        } else {
	          // Return this sound's loop value.
	          sound = self._soundById(parseInt(args[0], 10));
	          return sound ? sound._loop : false;
	        }
	      } else if (args.length === 2) {
	        loop = args[0];
	        id = parseInt(args[1], 10);
	      }

	      // If no id is passed, get all ID's to be looped.
	      var ids = self._getSoundIds(id);
	      for (var i=0; i<ids.length; i++) {
	        sound = self._soundById(ids[i]);

	        if (sound) {
	          sound._loop = loop;
	          if (self._webAudio && sound._node && sound._node.bufferSource) {
	            sound._node.bufferSource.loop = loop;
	            if (loop) {
	              sound._node.bufferSource.loopStart = sound._start || 0;
	              sound._node.bufferSource.loopEnd = sound._stop;

	              // If playing, restart playback to ensure looping updates.
	              if (self.playing(ids[i])) {
	                self.pause(ids[i], true);
	                self.play(ids[i], true);
	              }
	            }
	          }
	        }
	      }

	      return self;
	    },

	    /**
	     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   rate() -> Returns the first sound node's current playback rate.
	     *   rate(id) -> Returns the sound id's current playback rate.
	     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
	     *   rate(rate, id) -> Sets the playback rate of passed sound id.
	     * @return {Howl/Number} Returns self or the current playback rate.
	     */
	    rate: function() {
	      var self = this;
	      var args = arguments;
	      var rate, id;

	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // We will simply return the current rate of the first node.
	        id = self._sounds[0]._id;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new rate value.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          rate = parseFloat(args[0]);
	        }
	      } else if (args.length === 2) {
	        rate = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }

	      // Update the playback rate or return the current value.
	      var sound;
	      if (typeof rate === 'number') {
	        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
	        if (self._state !== 'loaded' || self._playLock) {
	          self._queue.push({
	            event: 'rate',
	            action: function() {
	              self.rate.apply(self, args);
	            }
	          });

	          return self;
	        }

	        // Set the group rate.
	        if (typeof id === 'undefined') {
	          self._rate = rate;
	        }

	        // Update one or all volumes.
	        id = self._getSoundIds(id);
	        for (var i=0; i<id.length; i++) {
	          // Get the sound.
	          sound = self._soundById(id[i]);

	          if (sound) {
	            // Keep track of our position when the rate changed and update the playback
	            // start position so we can properly adjust the seek position for time elapsed.
	            if (self.playing(id[i])) {
	              sound._rateSeek = self.seek(id[i]);
	              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
	            }
	            sound._rate = rate;

	            // Change the playback rate.
	            if (self._webAudio && sound._node && sound._node.bufferSource) {
	              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
	            } else if (sound._node) {
	              sound._node.playbackRate = rate;
	            }

	            // Reset the timers.
	            var seek = self.seek(id[i]);
	            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
	            var timeout = (duration * 1000) / Math.abs(sound._rate);

	            // Start a new end timer if sound is already playing.
	            if (self._endTimers[id[i]] || !sound._paused) {
	              self._clearTimer(id[i]);
	              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
	            }

	            self._emit('rate', sound._id);
	          }
	        }
	      } else {
	        sound = self._soundById(id);
	        return sound ? sound._rate : self._rate;
	      }

	      return self;
	    },

	    /**
	     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   seek() -> Returns the first sound node's current seek position.
	     *   seek(id) -> Returns the sound id's current seek position.
	     *   seek(seek) -> Sets the seek position of the first sound node.
	     *   seek(seek, id) -> Sets the seek position of passed sound id.
	     * @return {Howl/Number} Returns self or the current seek position.
	     */
	    seek: function() {
	      var self = this;
	      var args = arguments;
	      var seek, id;

	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // We will simply return the current position of the first node.
	        if (self._sounds.length) {
	          id = self._sounds[0]._id;
	        }
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new seek position.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else if (self._sounds.length) {
	          id = self._sounds[0]._id;
	          seek = parseFloat(args[0]);
	        }
	      } else if (args.length === 2) {
	        seek = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }

	      // If there is no ID, bail out.
	      if (typeof id === 'undefined') {
	        return 0;
	      }

	      // If the sound hasn't loaded, add it to the load queue to seek when capable.
	      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {
	        self._queue.push({
	          event: 'seek',
	          action: function() {
	            self.seek.apply(self, args);
	          }
	        });

	        return self;
	      }

	      // Get the sound.
	      var sound = self._soundById(id);

	      if (sound) {
	        if (typeof seek === 'number' && seek >= 0) {
	          // Pause the sound and update position for restarting playback.
	          var playing = self.playing(id);
	          if (playing) {
	            self.pause(id, true);
	          }

	          // Move the position of the track and cancel timer.
	          sound._seek = seek;
	          sound._ended = false;
	          self._clearTimer(id);

	          // Update the seek position for HTML5 Audio.
	          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
	            sound._node.currentTime = seek;
	          }

	          // Seek and emit when ready.
	          var seekAndEmit = function() {
	            // Restart the playback if the sound was playing.
	            if (playing) {
	              self.play(id, true);
	            }

	            self._emit('seek', id);
	          };

	          // Wait for the play lock to be unset before emitting (HTML5 Audio).
	          if (playing && !self._webAudio) {
	            var emitSeek = function() {
	              if (!self._playLock) {
	                seekAndEmit();
	              } else {
	                setTimeout(emitSeek, 0);
	              }
	            };
	            setTimeout(emitSeek, 0);
	          } else {
	            seekAndEmit();
	          }
	        } else {
	          if (self._webAudio) {
	            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
	            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
	            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
	          } else {
	            return sound._node.currentTime;
	          }
	        }
	      }

	      return self;
	    },

	    /**
	     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
	     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
	     * @return {Boolean} True if playing and false if not.
	     */
	    playing: function(id) {
	      var self = this;

	      // Check the passed sound ID (if any).
	      if (typeof id === 'number') {
	        var sound = self._soundById(id);
	        return sound ? !sound._paused : false;
	      }

	      // Otherwise, loop through all sounds and check if any are playing.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (!self._sounds[i]._paused) {
	          return true;
	        }
	      }

	      return false;
	    },

	    /**
	     * Get the duration of this sound. Passing a sound id will return the sprite duration.
	     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
	     * @return {Number} Audio duration in seconds.
	     */
	    duration: function(id) {
	      var self = this;
	      var duration = self._duration;

	      // If we pass an ID, get the sound and return the sprite length.
	      var sound = self._soundById(id);
	      if (sound) {
	        duration = self._sprite[sound._sprite][1] / 1000;
	      }

	      return duration;
	    },

	    /**
	     * Returns the current loaded state of this Howl.
	     * @return {String} 'unloaded', 'loading', 'loaded'
	     */
	    state: function() {
	      return this._state;
	    },

	    /**
	     * Unload and destroy the current Howl object.
	     * This will immediately stop all sound instances attached to this group.
	     */
	    unload: function() {
	      var self = this;

	      // Stop playing any active sounds.
	      var sounds = self._sounds;
	      for (var i=0; i<sounds.length; i++) {
	        // Stop the sound if it is currently playing.
	        if (!sounds[i]._paused) {
	          self.stop(sounds[i]._id);
	        }

	        // Remove the source or disconnect.
	        if (!self._webAudio) {
	          // Set the source to 0-second silence to stop any downloading (except in IE).
	          self._clearSound(sounds[i]._node);

	          // Remove any event listeners.
	          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
	          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
	          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);

	          // Release the Audio object back to the pool.
	          Howler._releaseHtml5Audio(sounds[i]._node);
	        }

	        // Empty out all of the nodes.
	        delete sounds[i]._node;

	        // Make sure all timers are cleared out.
	        self._clearTimer(sounds[i]._id);
	      }

	      // Remove the references in the global Howler object.
	      var index = Howler._howls.indexOf(self);
	      if (index >= 0) {
	        Howler._howls.splice(index, 1);
	      }

	      // Delete this sound from the cache (if no other Howl is using it).
	      var remCache = true;
	      for (i=0; i<Howler._howls.length; i++) {
	        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
	          remCache = false;
	          break;
	        }
	      }

	      if (cache && remCache) {
	        delete cache[self._src];
	      }

	      // Clear global errors.
	      Howler.noAudio = false;

	      // Clear out `self`.
	      self._state = 'unloaded';
	      self._sounds = [];
	      self = null;

	      return null;
	    },

	    /**
	     * Listen to a custom event.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to call.
	     * @param  {Number}   id    (optional) Only listen to events for this sound.
	     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
	     * @return {Howl}
	     */
	    on: function(event, fn, id, once) {
	      var self = this;
	      var events = self['_on' + event];

	      if (typeof fn === 'function') {
	        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
	      }

	      return self;
	    },

	    /**
	     * Remove a custom event. Call without parameters to remove all events.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
	     * @param  {Number}   id    (optional) Only remove events for this sound.
	     * @return {Howl}
	     */
	    off: function(event, fn, id) {
	      var self = this;
	      var events = self['_on' + event];
	      var i = 0;

	      // Allow passing just an event and ID.
	      if (typeof fn === 'number') {
	        id = fn;
	        fn = null;
	      }

	      if (fn || id) {
	        // Loop through event store and remove the passed function.
	        for (i=0; i<events.length; i++) {
	          var isId = (id === events[i].id);
	          if (fn === events[i].fn && isId || !fn && isId) {
	            events.splice(i, 1);
	            break;
	          }
	        }
	      } else if (event) {
	        // Clear out all events of this type.
	        self['_on' + event] = [];
	      } else {
	        // Clear out all events of every type.
	        var keys = Object.keys(self);
	        for (i=0; i<keys.length; i++) {
	          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
	            self[keys[i]] = [];
	          }
	        }
	      }

	      return self;
	    },

	    /**
	     * Listen to a custom event and remove it once fired.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to call.
	     * @param  {Number}   id    (optional) Only listen to events for this sound.
	     * @return {Howl}
	     */
	    once: function(event, fn, id) {
	      var self = this;

	      // Setup the event listener.
	      self.on(event, fn, id, 1);

	      return self;
	    },

	    /**
	     * Emit all events of a specific type and pass the sound id.
	     * @param  {String} event Event name.
	     * @param  {Number} id    Sound ID.
	     * @param  {Number} msg   Message to go with event.
	     * @return {Howl}
	     */
	    _emit: function(event, id, msg) {
	      var self = this;
	      var events = self['_on' + event];

	      // Loop through event store and fire all functions.
	      for (var i=events.length-1; i>=0; i--) {
	        // Only fire the listener if the correct ID is used.
	        if (!events[i].id || events[i].id === id || event === 'load') {
	          setTimeout(function(fn) {
	            fn.call(this, id, msg);
	          }.bind(self, events[i].fn), 0);

	          // If this event was setup with `once`, remove it.
	          if (events[i].once) {
	            self.off(event, events[i].fn, events[i].id);
	          }
	        }
	      }

	      // Pass the event type into load queue so that it can continue stepping.
	      self._loadQueue(event);

	      return self;
	    },

	    /**
	     * Queue of actions initiated before the sound has loaded.
	     * These will be called in sequence, with the next only firing
	     * after the previous has finished executing (even if async like play).
	     * @return {Howl}
	     */
	    _loadQueue: function(event) {
	      var self = this;

	      if (self._queue.length > 0) {
	        var task = self._queue[0];

	        // Remove this task if a matching event was passed.
	        if (task.event === event) {
	          self._queue.shift();
	          self._loadQueue();
	        }

	        // Run the task if no event type is passed.
	        if (!event) {
	          task.action();
	        }
	      }

	      return self;
	    },

	    /**
	     * Fired when playback ends at the end of the duration.
	     * @param  {Sound} sound The sound object to work with.
	     * @return {Howl}
	     */
	    _ended: function(sound) {
	      var self = this;
	      var sprite = sound._sprite;

	      // If we are using IE and there was network latency we may be clipping
	      // audio before it completes playing. Lets check the node to make sure it
	      // believes it has completed, before ending the playback.
	      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
	        setTimeout(self._ended.bind(self, sound), 100);
	        return self;
	      }

	      // Should this sound loop?
	      var loop = !!(sound._loop || self._sprite[sprite][2]);

	      // Fire the ended event.
	      self._emit('end', sound._id);

	      // Restart the playback for HTML5 Audio loop.
	      if (!self._webAudio && loop) {
	        self.stop(sound._id, true).play(sound._id);
	      }

	      // Restart this timer if on a Web Audio loop.
	      if (self._webAudio && loop) {
	        self._emit('play', sound._id);
	        sound._seek = sound._start || 0;
	        sound._rateSeek = 0;
	        sound._playStart = Howler.ctx.currentTime;

	        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
	        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	      }

	      // Mark the node as paused.
	      if (self._webAudio && !loop) {
	        sound._paused = true;
	        sound._ended = true;
	        sound._seek = sound._start || 0;
	        sound._rateSeek = 0;
	        self._clearTimer(sound._id);

	        // Clean up the buffer source.
	        self._cleanBuffer(sound._node);

	        // Attempt to auto-suspend AudioContext if no sounds are still playing.
	        Howler._autoSuspend();
	      }

	      // When using a sprite, end the track.
	      if (!self._webAudio && !loop) {
	        self.stop(sound._id, true);
	      }

	      return self;
	    },

	    /**
	     * Clear the end timer for a sound playback.
	     * @param  {Number} id The sound ID.
	     * @return {Howl}
	     */
	    _clearTimer: function(id) {
	      var self = this;

	      if (self._endTimers[id]) {
	        // Clear the timeout or remove the ended listener.
	        if (typeof self._endTimers[id] !== 'function') {
	          clearTimeout(self._endTimers[id]);
	        } else {
	          var sound = self._soundById(id);
	          if (sound && sound._node) {
	            sound._node.removeEventListener('ended', self._endTimers[id], false);
	          }
	        }

	        delete self._endTimers[id];
	      }

	      return self;
	    },

	    /**
	     * Return the sound identified by this ID, or return null.
	     * @param  {Number} id Sound ID
	     * @return {Object}    Sound object or null.
	     */
	    _soundById: function(id) {
	      var self = this;

	      // Loop through all sounds and find the one with this ID.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (id === self._sounds[i]._id) {
	          return self._sounds[i];
	        }
	      }

	      return null;
	    },

	    /**
	     * Return an inactive sound from the pool or create a new one.
	     * @return {Sound} Sound playback object.
	     */
	    _inactiveSound: function() {
	      var self = this;

	      self._drain();

	      // Find the first inactive node to recycle.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (self._sounds[i]._ended) {
	          return self._sounds[i].reset();
	        }
	      }

	      // If no inactive node was found, create a new one.
	      return new Sound(self);
	    },

	    /**
	     * Drain excess inactive sounds from the pool.
	     */
	    _drain: function() {
	      var self = this;
	      var limit = self._pool;
	      var cnt = 0;
	      var i = 0;

	      // If there are less sounds than the max pool size, we are done.
	      if (self._sounds.length < limit) {
	        return;
	      }

	      // Count the number of inactive sounds.
	      for (i=0; i<self._sounds.length; i++) {
	        if (self._sounds[i]._ended) {
	          cnt++;
	        }
	      }

	      // Remove excess inactive sounds, going in reverse order.
	      for (i=self._sounds.length - 1; i>=0; i--) {
	        if (cnt <= limit) {
	          return;
	        }

	        if (self._sounds[i]._ended) {
	          // Disconnect the audio source when using Web Audio.
	          if (self._webAudio && self._sounds[i]._node) {
	            self._sounds[i]._node.disconnect(0);
	          }

	          // Remove sounds until we have the pool size.
	          self._sounds.splice(i, 1);
	          cnt--;
	        }
	      }
	    },

	    /**
	     * Get all ID's from the sounds pool.
	     * @param  {Number} id Only return one ID if one is passed.
	     * @return {Array}    Array of IDs.
	     */
	    _getSoundIds: function(id) {
	      var self = this;

	      if (typeof id === 'undefined') {
	        var ids = [];
	        for (var i=0; i<self._sounds.length; i++) {
	          ids.push(self._sounds[i]._id);
	        }

	        return ids;
	      } else {
	        return [id];
	      }
	    },

	    /**
	     * Load the sound back into the buffer source.
	     * @param  {Sound} sound The sound object to work with.
	     * @return {Howl}
	     */
	    _refreshBuffer: function(sound) {
	      var self = this;

	      // Setup the buffer source for playback.
	      sound._node.bufferSource = Howler.ctx.createBufferSource();
	      sound._node.bufferSource.buffer = cache[self._src];

	      // Connect to the correct node.
	      if (sound._panner) {
	        sound._node.bufferSource.connect(sound._panner);
	      } else {
	        sound._node.bufferSource.connect(sound._node);
	      }

	      // Setup looping and playback rate.
	      sound._node.bufferSource.loop = sound._loop;
	      if (sound._loop) {
	        sound._node.bufferSource.loopStart = sound._start || 0;
	        sound._node.bufferSource.loopEnd = sound._stop || 0;
	      }
	      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);

	      return self;
	    },

	    /**
	     * Prevent memory leaks by cleaning up the buffer source after playback.
	     * @param  {Object} node Sound's audio node containing the buffer source.
	     * @return {Howl}
	     */
	    _cleanBuffer: function(node) {
	      var self = this;
	      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;

	      if (Howler._scratchBuffer && node.bufferSource) {
	        node.bufferSource.onended = null;
	        node.bufferSource.disconnect(0);
	        if (isIOS) {
	          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}
	        }
	      }
	      node.bufferSource = null;

	      return self;
	    },

	    /**
	     * Set the source to a 0-second silence to stop any downloading (except in IE).
	     * @param  {Object} node Audio node to clear.
	     */
	    _clearSound: function(node) {
	      var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
	      if (!checkIE) {
	        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
	      }
	    }
	  };

	  /** Single Sound Methods **/
	  /***************************************************************************/

	  /**
	   * Setup the sound object, which each node attached to a Howl group is contained in.
	   * @param {Object} howl The Howl parent group.
	   */
	  var Sound = function(howl) {
	    this._parent = howl;
	    this.init();
	  };
	  Sound.prototype = {
	    /**
	     * Initialize a new Sound object.
	     * @return {Sound}
	     */
	    init: function() {
	      var self = this;
	      var parent = self._parent;

	      // Setup the default parameters.
	      self._muted = parent._muted;
	      self._loop = parent._loop;
	      self._volume = parent._volume;
	      self._rate = parent._rate;
	      self._seek = 0;
	      self._paused = true;
	      self._ended = true;
	      self._sprite = '__default';

	      // Generate a unique ID for this sound.
	      self._id = ++Howler._counter;

	      // Add itself to the parent's pool.
	      parent._sounds.push(self);

	      // Create the new node.
	      self.create();

	      return self;
	    },

	    /**
	     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
	     * @return {Sound}
	     */
	    create: function() {
	      var self = this;
	      var parent = self._parent;
	      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;

	      if (parent._webAudio) {
	        // Create the gain node for controlling volume (the source will connect to this).
	        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
	        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
	        self._node.paused = true;
	        self._node.connect(Howler.masterGain);
	      } else if (!Howler.noAudio) {
	        // Get an unlocked Audio object from the pool.
	        self._node = Howler._obtainHtml5Audio();

	        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
	        self._errorFn = self._errorListener.bind(self);
	        self._node.addEventListener('error', self._errorFn, false);

	        // Listen for 'canplaythrough' event to let us know the sound is ready.
	        self._loadFn = self._loadListener.bind(self);
	        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);

	        // Listen for the 'ended' event on the sound to account for edge-case where
	        // a finite sound has a duration of Infinity.
	        self._endFn = self._endListener.bind(self);
	        self._node.addEventListener('ended', self._endFn, false);

	        // Setup the new audio node.
	        self._node.src = parent._src;
	        self._node.preload = parent._preload === true ? 'auto' : parent._preload;
	        self._node.volume = volume * Howler.volume();

	        // Begin loading the source.
	        self._node.load();
	      }

	      return self;
	    },

	    /**
	     * Reset the parameters of this sound to the original state (for recycle).
	     * @return {Sound}
	     */
	    reset: function() {
	      var self = this;
	      var parent = self._parent;

	      // Reset all of the parameters of this sound.
	      self._muted = parent._muted;
	      self._loop = parent._loop;
	      self._volume = parent._volume;
	      self._rate = parent._rate;
	      self._seek = 0;
	      self._rateSeek = 0;
	      self._paused = true;
	      self._ended = true;
	      self._sprite = '__default';

	      // Generate a new ID so that it isn't confused with the previous sound.
	      self._id = ++Howler._counter;

	      return self;
	    },

	    /**
	     * HTML5 Audio error listener callback.
	     */
	    _errorListener: function() {
	      var self = this;

	      // Fire an error event and pass back the code.
	      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

	      // Clear the event listener.
	      self._node.removeEventListener('error', self._errorFn, false);
	    },

	    /**
	     * HTML5 Audio canplaythrough listener callback.
	     */
	    _loadListener: function() {
	      var self = this;
	      var parent = self._parent;

	      // Round up the duration to account for the lower precision in HTML5 Audio.
	      parent._duration = Math.ceil(self._node.duration * 10) / 10;

	      // Setup a sprite if none is defined.
	      if (Object.keys(parent._sprite).length === 0) {
	        parent._sprite = {__default: [0, parent._duration * 1000]};
	      }

	      if (parent._state !== 'loaded') {
	        parent._state = 'loaded';
	        parent._emit('load');
	        parent._loadQueue();
	      }

	      // Clear the event listener.
	      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
	    },

	    /**
	     * HTML5 Audio ended listener callback.
	     */
	    _endListener: function() {
	      var self = this;
	      var parent = self._parent;

	      // Only handle the `ended`` event if the duration is Infinity.
	      if (parent._duration === Infinity) {
	        // Update the parent duration to match the real audio duration.
	        // Round up the duration to account for the lower precision in HTML5 Audio.
	        parent._duration = Math.ceil(self._node.duration * 10) / 10;

	        // Update the sprite that corresponds to the real duration.
	        if (parent._sprite.__default[1] === Infinity) {
	          parent._sprite.__default[1] = parent._duration * 1000;
	        }

	        // Run the regular ended method.
	        parent._ended(self);
	      }

	      // Clear the event listener since the duration is now correct.
	      self._node.removeEventListener('ended', self._endFn, false);
	    }
	  };

	  /** Helper Methods **/
	  /***************************************************************************/

	  var cache = {};

	  /**
	   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
	   * @param  {Howl} self
	   */
	  var loadBuffer = function(self) {
	    var url = self._src;

	    // Check if the buffer has already been cached and use it instead.
	    if (cache[url]) {
	      // Set the duration from the cache.
	      self._duration = cache[url].duration;

	      // Load the sound into this Howl.
	      loadSound(self);

	      return;
	    }

	    if (/^data:[^;]+;base64,/.test(url)) {
	      // Decode the base64 data URI without XHR, since some browsers don't support it.
	      var data = atob(url.split(',')[1]);
	      var dataView = new Uint8Array(data.length);
	      for (var i=0; i<data.length; ++i) {
	        dataView[i] = data.charCodeAt(i);
	      }

	      decodeAudioData(dataView.buffer, self);
	    } else {
	      // Load the buffer from the URL.
	      var xhr = new XMLHttpRequest();
	      xhr.open(self._xhr.method, url, true);
	      xhr.withCredentials = self._xhr.withCredentials;
	      xhr.responseType = 'arraybuffer';

	      // Apply any custom headers to the request.
	      if (self._xhr.headers) {
	        Object.keys(self._xhr.headers).forEach(function(key) {
	          xhr.setRequestHeader(key, self._xhr.headers[key]);
	        });
	      }

	      xhr.onload = function() {
	        // Make sure we get a successful response back.
	        var code = (xhr.status + '')[0];
	        if (code !== '0' && code !== '2' && code !== '3') {
	          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
	          return;
	        }

	        decodeAudioData(xhr.response, self);
	      };
	      xhr.onerror = function() {
	        // If there is an error, switch to HTML5 Audio.
	        if (self._webAudio) {
	          self._html5 = true;
	          self._webAudio = false;
	          self._sounds = [];
	          delete cache[url];
	          self.load();
	        }
	      };
	      safeXhrSend(xhr);
	    }
	  };

	  /**
	   * Send the XHR request wrapped in a try/catch.
	   * @param  {Object} xhr XHR to send.
	   */
	  var safeXhrSend = function(xhr) {
	    try {
	      xhr.send();
	    } catch (e) {
	      xhr.onerror();
	    }
	  };

	  /**
	   * Decode audio data from an array buffer.
	   * @param  {ArrayBuffer} arraybuffer The audio data.
	   * @param  {Howl}        self
	   */
	  var decodeAudioData = function(arraybuffer, self) {
	    // Fire a load error if something broke.
	    var error = function() {
	      self._emit('loaderror', null, 'Decoding audio data failed.');
	    };

	    // Load the sound on success.
	    var success = function(buffer) {
	      if (buffer && self._sounds.length > 0) {
	        cache[self._src] = buffer;
	        loadSound(self, buffer);
	      } else {
	        error();
	      }
	    };

	    // Decode the buffer into an audio source.
	    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {
	      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
	    } else {
	      Howler.ctx.decodeAudioData(arraybuffer, success, error);
	    }
	  };

	  /**
	   * Sound is now loaded, so finish setting everything up and fire the loaded event.
	   * @param  {Howl} self
	   * @param  {Object} buffer The decoded buffer sound source.
	   */
	  var loadSound = function(self, buffer) {
	    // Set the duration.
	    if (buffer && !self._duration) {
	      self._duration = buffer.duration;
	    }

	    // Setup a sprite if none is defined.
	    if (Object.keys(self._sprite).length === 0) {
	      self._sprite = {__default: [0, self._duration * 1000]};
	    }

	    // Fire the loaded event.
	    if (self._state !== 'loaded') {
	      self._state = 'loaded';
	      self._emit('load');
	      self._loadQueue();
	    }
	  };

	  /**
	   * Setup the audio context when available, or switch to HTML5 Audio mode.
	   */
	  var setupAudioContext = function() {
	    // If we have already detected that Web Audio isn't supported, don't run this step again.
	    if (!Howler.usingWebAudio) {
	      return;
	    }

	    // Check if we are using Web Audio and setup the AudioContext if we are.
	    try {
	      if (typeof AudioContext !== 'undefined') {
	        Howler.ctx = new AudioContext();
	      } else if (typeof webkitAudioContext !== 'undefined') {
	        Howler.ctx = new webkitAudioContext();
	      } else {
	        Howler.usingWebAudio = false;
	      }
	    } catch(e) {
	      Howler.usingWebAudio = false;
	    }

	    // If the audio context creation still failed, set using web audio to false.
	    if (!Howler.ctx) {
	      Howler.usingWebAudio = false;
	    }

	    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
	    // If it is, disable Web Audio as it causes crashing.
	    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
	    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
	    var version = appVersion ? parseInt(appVersion[1], 10) : null;
	    if (iOS && version && version < 9) {
	      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
	      if (Howler._navigator && !safari) {
	        Howler.usingWebAudio = false;
	      }
	    }

	    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
	    if (Howler.usingWebAudio) {
	      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
	      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
	      Howler.masterGain.connect(Howler.ctx.destination);
	    }

	    // Re-run the setup on Howler.
	    Howler._setup();
	  };

	  // Add support for CommonJS libraries such as browserify.
	  {
	    exports.Howler = Howler;
	    exports.Howl = Howl;
	  }

	  // Add to global in Node.js (for testing, etc).
	  if (typeof commonjsGlobal !== 'undefined') {
	    commonjsGlobal.HowlerGlobal = HowlerGlobal;
	    commonjsGlobal.Howler = Howler;
	    commonjsGlobal.Howl = Howl;
	    commonjsGlobal.Sound = Sound;
	  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.
	    window.HowlerGlobal = HowlerGlobal;
	    window.Howler = Howler;
	    window.Howl = Howl;
	    window.Sound = Sound;
	  }
	})();


	/*!
	 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
	 *  
	 *  howler.js v2.2.3
	 *  howlerjs.com
	 *
	 *  (c) 2013-2020, James Simpson of GoldFire Studios
	 *  goldfirestudios.com
	 *
	 *  MIT License
	 */

	(function() {

	  // Setup default properties.
	  HowlerGlobal.prototype._pos = [0, 0, 0];
	  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];

	  /** Global Methods **/
	  /***************************************************************************/

	  /**
	   * Helper method to update the stereo panning position of all current Howls.
	   * Future Howls will not use this value unless explicitly set.
	   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
	   * @return {Howler/Number}     Self or current stereo panning value.
	   */
	  HowlerGlobal.prototype.stereo = function(pan) {
	    var self = this;

	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }

	    // Loop through all Howls and update their stereo panning.
	    for (var i=self._howls.length-1; i>=0; i--) {
	      self._howls[i].stereo(pan);
	    }

	    return self;
	  };

	  /**
	   * Get/set the position of the listener in 3D cartesian space. Sounds using
	   * 3D position will be relative to the listener's position.
	   * @param  {Number} x The x-position of the listener.
	   * @param  {Number} y The y-position of the listener.
	   * @param  {Number} z The z-position of the listener.
	   * @return {Howler/Array}   Self or current listener position.
	   */
	  HowlerGlobal.prototype.pos = function(x, y, z) {
	    var self = this;

	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }

	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? self._pos[1] : y;
	    z = (typeof z !== 'number') ? self._pos[2] : z;

	    if (typeof x === 'number') {
	      self._pos = [x, y, z];

	      if (typeof self.ctx.listener.positionX !== 'undefined') {
	        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
	        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
	        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
	      } else {
	        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
	      }
	    } else {
	      return self._pos;
	    }

	    return self;
	  };

	  /**
	   * Get/set the direction the listener is pointing in the 3D cartesian space.
	   * A front and up vector must be provided. The front is the direction the
	   * face of the listener is pointing, and up is the direction the top of the
	   * listener is pointing. Thus, these values are expected to be at right angles
	   * from each other.
	   * @param  {Number} x   The x-orientation of the listener.
	   * @param  {Number} y   The y-orientation of the listener.
	   * @param  {Number} z   The z-orientation of the listener.
	   * @param  {Number} xUp The x-orientation of the top of the listener.
	   * @param  {Number} yUp The y-orientation of the top of the listener.
	   * @param  {Number} zUp The z-orientation of the top of the listener.
	   * @return {Howler/Array}     Returns self or the current orientation vectors.
	   */
	  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
	    var self = this;

	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }

	    // Set the defaults for optional 'y' & 'z'.
	    var or = self._orientation;
	    y = (typeof y !== 'number') ? or[1] : y;
	    z = (typeof z !== 'number') ? or[2] : z;
	    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
	    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
	    zUp = (typeof zUp !== 'number') ? or[5] : zUp;

	    if (typeof x === 'number') {
	      self._orientation = [x, y, z, xUp, yUp, zUp];

	      if (typeof self.ctx.listener.forwardX !== 'undefined') {
	        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
	        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
	        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
	        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
	        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
	        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
	      } else {
	        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
	      }
	    } else {
	      return or;
	    }

	    return self;
	  };

	  /** Group Methods **/
	  /***************************************************************************/

	  /**
	   * Add new properties to the core init.
	   * @param  {Function} _super Core init method.
	   * @return {Howl}
	   */
	  Howl.prototype.init = (function(_super) {
	    return function(o) {
	      var self = this;

	      // Setup user-defined default properties.
	      self._orientation = o.orientation || [1, 0, 0];
	      self._stereo = o.stereo || null;
	      self._pos = o.pos || null;
	      self._pannerAttr = {
	        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
	        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
	        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
	        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
	        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
	        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
	        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
	        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
	      };

	      // Setup event listeners.
	      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
	      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
	      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];

	      // Complete initilization with howler.js core's init function.
	      return _super.call(this, o);
	    };
	  })(Howl.prototype.init);

	  /**
	   * Get/set the stereo panning of the audio source for this sound or all in the group.
	   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Number}    Returns self or the current stereo panning value.
	   */
	  Howl.prototype.stereo = function(pan, id) {
	    var self = this;

	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }

	    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'stereo',
	        action: function() {
	          self.stereo(pan, id);
	        }
	      });

	      return self;
	    }

	    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
	    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';

	    // Setup the group's stereo panning if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's stereo panning if no parameters are passed.
	      if (typeof pan === 'number') {
	        self._stereo = pan;
	        self._pos = [pan, 0, 0];
	      } else {
	        return self._stereo;
	      }
	    }

	    // Change the streo panning of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);

	      if (sound) {
	        if (typeof pan === 'number') {
	          sound._stereo = pan;
	          sound._pos = [pan, 0, 0];

	          if (sound._node) {
	            // If we are falling back, make sure the panningModel is equalpower.
	            sound._pannerAttr.panningModel = 'equalpower';

	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner || !sound._panner.pan) {
	              setupPanner(sound, pannerType);
	            }

	            if (pannerType === 'spatial') {
	              if (typeof sound._panner.positionX !== 'undefined') {
	                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
	                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
	                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
	              } else {
	                sound._panner.setPosition(pan, 0, 0);
	              }
	            } else {
	              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
	            }
	          }

	          self._emit('stereo', sound._id);
	        } else {
	          return sound._stereo;
	        }
	      }
	    }

	    return self;
	  };

	  /**
	   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
	   * @param  {Number} x  The x-position of the audio source.
	   * @param  {Number} y  The y-position of the audio source.
	   * @param  {Number} z  The z-position of the audio source.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
	   */
	  Howl.prototype.pos = function(x, y, z, id) {
	    var self = this;

	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }

	    // If the sound hasn't loaded, add it to the load queue to change position when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'pos',
	        action: function() {
	          self.pos(x, y, z, id);
	        }
	      });

	      return self;
	    }

	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? 0 : y;
	    z = (typeof z !== 'number') ? -0.5 : z;

	    // Setup the group's spatial position if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's spatial position if no parameters are passed.
	      if (typeof x === 'number') {
	        self._pos = [x, y, z];
	      } else {
	        return self._pos;
	      }
	    }

	    // Change the spatial position of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);

	      if (sound) {
	        if (typeof x === 'number') {
	          sound._pos = [x, y, z];

	          if (sound._node) {
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner || sound._panner.pan) {
	              setupPanner(sound, 'spatial');
	            }

	            if (typeof sound._panner.positionX !== 'undefined') {
	              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
	              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
	              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
	            } else {
	              sound._panner.setPosition(x, y, z);
	            }
	          }

	          self._emit('pos', sound._id);
	        } else {
	          return sound._pos;
	        }
	      }
	    }

	    return self;
	  };

	  /**
	   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
	   * space. Depending on how direction the sound is, based on the `cone` attributes,
	   * a sound pointing away from the listener can be quiet or silent.
	   * @param  {Number} x  The x-orientation of the source.
	   * @param  {Number} y  The y-orientation of the source.
	   * @param  {Number} z  The z-orientation of the source.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
	   */
	  Howl.prototype.orientation = function(x, y, z, id) {
	    var self = this;

	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }

	    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'orientation',
	        action: function() {
	          self.orientation(x, y, z, id);
	        }
	      });

	      return self;
	    }

	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? self._orientation[1] : y;
	    z = (typeof z !== 'number') ? self._orientation[2] : z;

	    // Setup the group's spatial orientation if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's spatial orientation if no parameters are passed.
	      if (typeof x === 'number') {
	        self._orientation = [x, y, z];
	      } else {
	        return self._orientation;
	      }
	    }

	    // Change the spatial orientation of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);

	      if (sound) {
	        if (typeof x === 'number') {
	          sound._orientation = [x, y, z];

	          if (sound._node) {
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner) {
	              // Make sure we have a position to setup the node with.
	              if (!sound._pos) {
	                sound._pos = self._pos || [0, 0, -0.5];
	              }

	              setupPanner(sound, 'spatial');
	            }

	            if (typeof sound._panner.orientationX !== 'undefined') {
	              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
	              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
	              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
	            } else {
	              sound._panner.setOrientation(x, y, z);
	            }
	          }

	          self._emit('orientation', sound._id);
	        } else {
	          return sound._orientation;
	        }
	      }
	    }

	    return self;
	  };

	  /**
	   * Get/set the panner node's attributes for a sound or group of sounds.
	   * This method can optionall take 0, 1 or 2 arguments.
	   *   pannerAttr() -> Returns the group's values.
	   *   pannerAttr(id) -> Returns the sound id's values.
	   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
	   *   pannerAttr(o, id) -> Set's the values of passed sound id.
	   *
	   *   Attributes:
	   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
	   *                      inside of which there will be no volume reduction.
	   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
	   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
	   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
	   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
	   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
	   *                     listener. Can be `linear`, `inverse` or `exponential.
	   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
	   *                   will not be reduced any further.
	   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
	   *                   This is simply a variable of the distance model and has a different effect depending on which model
	   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
	   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
	   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, â]`
	   *                     with `inverse` and `exponential`.
	   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
	   *                     Can be `HRTF` or `equalpower`.
	   *
	   * @return {Howl/Object} Returns self or current panner attributes.
	   */
	  Howl.prototype.pannerAttr = function() {
	    var self = this;
	    var args = arguments;
	    var o, id, sound;

	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }

	    // Determine the values based on arguments.
	    if (args.length === 0) {
	      // Return the group's panner attribute values.
	      return self._pannerAttr;
	    } else if (args.length === 1) {
	      if (typeof args[0] === 'object') {
	        o = args[0];

	        // Set the grou's panner attribute values.
	        if (typeof id === 'undefined') {
	          if (!o.pannerAttr) {
	            o.pannerAttr = {
	              coneInnerAngle: o.coneInnerAngle,
	              coneOuterAngle: o.coneOuterAngle,
	              coneOuterGain: o.coneOuterGain,
	              distanceModel: o.distanceModel,
	              maxDistance: o.maxDistance,
	              refDistance: o.refDistance,
	              rolloffFactor: o.rolloffFactor,
	              panningModel: o.panningModel
	            };
	          }

	          self._pannerAttr = {
	            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
	            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
	            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
	            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
	            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
	            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
	            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
	            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
	          };
	        }
	      } else {
	        // Return this sound's panner attribute values.
	        sound = self._soundById(parseInt(args[0], 10));
	        return sound ? sound._pannerAttr : self._pannerAttr;
	      }
	    } else if (args.length === 2) {
	      o = args[0];
	      id = parseInt(args[1], 10);
	    }

	    // Update the values of the specified sounds.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      sound = self._soundById(ids[i]);

	      if (sound) {
	        // Merge the new values into the sound.
	        var pa = sound._pannerAttr;
	        pa = {
	          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
	          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
	          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
	          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
	          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
	          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
	          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
	          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
	        };

	        // Update the panner values or create a new panner if none exists.
	        var panner = sound._panner;
	        if (panner) {
	          panner.coneInnerAngle = pa.coneInnerAngle;
	          panner.coneOuterAngle = pa.coneOuterAngle;
	          panner.coneOuterGain = pa.coneOuterGain;
	          panner.distanceModel = pa.distanceModel;
	          panner.maxDistance = pa.maxDistance;
	          panner.refDistance = pa.refDistance;
	          panner.rolloffFactor = pa.rolloffFactor;
	          panner.panningModel = pa.panningModel;
	        } else {
	          // Make sure we have a position to setup the node with.
	          if (!sound._pos) {
	            sound._pos = self._pos || [0, 0, -0.5];
	          }

	          // Create a new panner node.
	          setupPanner(sound, 'spatial');
	        }
	      }
	    }

	    return self;
	  };

	  /** Single Sound Methods **/
	  /***************************************************************************/

	  /**
	   * Add new properties to the core Sound init.
	   * @param  {Function} _super Core Sound init method.
	   * @return {Sound}
	   */
	  Sound.prototype.init = (function(_super) {
	    return function() {
	      var self = this;
	      var parent = self._parent;

	      // Setup user-defined default properties.
	      self._orientation = parent._orientation;
	      self._stereo = parent._stereo;
	      self._pos = parent._pos;
	      self._pannerAttr = parent._pannerAttr;

	      // Complete initilization with howler.js core Sound's init function.
	      _super.call(this);

	      // If a stereo or position was specified, set it up.
	      if (self._stereo) {
	        parent.stereo(self._stereo);
	      } else if (self._pos) {
	        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
	      }
	    };
	  })(Sound.prototype.init);

	  /**
	   * Override the Sound.reset method to clean up properties from the spatial plugin.
	   * @param  {Function} _super Sound reset method.
	   * @return {Sound}
	   */
	  Sound.prototype.reset = (function(_super) {
	    return function() {
	      var self = this;
	      var parent = self._parent;

	      // Reset all spatial plugin properties on this sound.
	      self._orientation = parent._orientation;
	      self._stereo = parent._stereo;
	      self._pos = parent._pos;
	      self._pannerAttr = parent._pannerAttr;

	      // If a stereo or position was specified, set it up.
	      if (self._stereo) {
	        parent.stereo(self._stereo);
	      } else if (self._pos) {
	        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
	      } else if (self._panner) {
	        // Disconnect the panner.
	        self._panner.disconnect(0);
	        self._panner = undefined;
	        parent._refreshBuffer(self);
	      }

	      // Complete resetting of the sound.
	      return _super.call(this);
	    };
	  })(Sound.prototype.reset);

	  /** Helper Methods **/
	  /***************************************************************************/

	  /**
	   * Create a new panner node and save it on the sound.
	   * @param  {Sound} sound Specific sound to setup panning on.
	   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
	   */
	  var setupPanner = function(sound, type) {
	    type = type || 'spatial';

	    // Create the new panner node.
	    if (type === 'spatial') {
	      sound._panner = Howler.ctx.createPanner();
	      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
	      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
	      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
	      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
	      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
	      sound._panner.refDistance = sound._pannerAttr.refDistance;
	      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
	      sound._panner.panningModel = sound._pannerAttr.panningModel;

	      if (typeof sound._panner.positionX !== 'undefined') {
	        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
	        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
	        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
	      } else {
	        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
	      }

	      if (typeof sound._panner.orientationX !== 'undefined') {
	        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
	        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
	        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
	      } else {
	        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
	      }
	    } else {
	      sound._panner = Howler.ctx.createStereoPanner();
	      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
	    }

	    sound._panner.connect(sound._node);

	    // Update the connections.
	    if (!sound._paused) {
	      sound._parent.pause(sound._id, true).play(sound._id, true);
	    }
	  };
	})();
} (howler));

/**
 * @classdesc
 * A Vector2d object that provide notification by executing the given callback when the vector is changed.
 * @augments Vector2d
 */
class ObservableVector2d extends Vector2d {
    /**
     * @param {number} x x value of the vector
     * @param {number} y y value of the vector
     * @param {object} settings additional required parameters
     * @param {Function} settings.onUpdate the callback to be executed when the vector is changed
     * @param {Function} [settings.scope] the value to use as this when calling onUpdate
     */
    constructor(x = 0, y = 0, settings) {
        super(x, y);
        if (typeof(settings) === "undefined") {
            throw new Error(
                "undefined `onUpdate` callback"
            );
        }
        this.setCallback(settings.onUpdate, settings.scope);
    }

    /**
     * @ignore
     */
    onResetEvent(x = 0, y = 0, settings) {
        // init is call by the constructor and does not trigger the cb
        this.setMuted(x, y);
        if (typeof settings !== "undefined") {
            this.setCallback(settings.onUpdate, settings.scope);
        }
        return this;
    }

    /**
     * x value of the vector
     * @public
     * @type {number}
     * @name x
     * @memberof ObservableVector2d
     */

    get x() {
        return this._x;
    }

    set x(value) {
        var ret = this.onUpdate.call(this.scope, value, this._y, this._x, this._y);
        if (ret && "x" in ret) {
            this._x = ret.x;
        } else {
            this._x = value;
        }
    }


    /**
     * y value of the vector
     * @public
     * @type {number}
     * @name y
     * @memberof ObservableVector2d
     */

    get y() {
        return this._y;
    }

    set y(value) {
        var ret = this.onUpdate.call(this.scope, this._x, value, this._x, this._y);
        if (ret && "y" in ret) {
            this._y = ret.y;
        } else {
            this._y = value;
        }
    }

    /** @ignore */
    _set(x, y) {
        var ret = this.onUpdate.call(this.scope, x, y, this._x, this._y);
        if (ret && "x" in ret && "y" in ret) {
            this._x = ret.x;
            this._y = ret.y;
        } else {
          this._x = x;
          this._y = y;
       }
       return this;
    }

    /**
     * set the vector value without triggering the callback
     * @name setMuted
     * @memberof ObservableVector2d
     * @param {number} x x value of the vector
     * @param {number} y y value of the vector
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    setMuted(x, y) {
        this._x = x;
        this._y = y;
        return this;
    }

    /**
     * set the callback to be executed when the vector is changed
     * @name setCallback
     * @memberof ObservableVector2d
     * @param {Function} fn callback
     * @param {Function} [scope=null] scope
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    setCallback(fn, scope = null) {
        if (typeof(fn) !== "function") {
            throw new Error(
                "invalid `onUpdate` callback"
            );
        }
        this.onUpdate = fn;
        this.scope = scope;
        return this;
    }

    /**
     * Add the passed vector to this vector
     * @name add
     * @memberof ObservableVector2d
     * @param {ObservableVector2d} v
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    add(v) {
        return this._set(this._x + v.x, this._y + v.y);
    }

    /**
     * Substract the passed vector to this vector
     * @name sub
     * @memberof ObservableVector2d
     * @param {ObservableVector2d} v
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    sub(v) {
        return this._set(this._x - v.x, this._y - v.y);
    }

    /**
     * Multiply this vector values by the given scalar
     * @name scale
     * @memberof ObservableVector2d
     * @param {number} x
     * @param {number} [y=x]
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    scale(x, y) {
        return this._set(this._x * x, this._y * (typeof (y) !== "undefined" ? y : x));
    }

    /**
     * Multiply this vector values by the passed vector
     * @name scaleV
     * @memberof ObservableVector2d
     * @param {ObservableVector2d} v
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    scaleV(v) {
        return this._set(this._x * v.x, this._y * v.y);
    }

    /**
     * Divide this vector values by the passed value
     * @name div
     * @memberof ObservableVector2d
     * @param {number} n the value to divide the vector by
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    div(n) {
        return this._set(this._x / n, this._y / n);
    }

    /**
     * Update this vector values to absolute values
     * @name abs
     * @memberof ObservableVector2d
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    abs() {
        return this._set((this._x < 0) ? -this._x : this._x, (this._y < 0) ? -this._y : this._y);
    }

    /**
     * Clamp the vector value within the specified value range
     * @name clamp
     * @memberof ObservableVector2d
     * @param {number} low
     * @param {number} high
     * @returns {ObservableVector2d} new me.ObservableVector2d
     */
    clamp(low, high) {
        return new ObservableVector2d(clamp(this.x, low, high), clamp(this.y, low, high), {onUpdate: this.onUpdate, scope: this.scope});
    }

    /**
     * Clamp this vector value within the specified value range
     * @name clampSelf
     * @memberof ObservableVector2d
     * @param {number} low
     * @param {number} high
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    clampSelf(low, high) {
        return this._set(clamp(this._x, low, high), clamp(this._y, low, high));
    }

    /**
     * Update this vector with the minimum value between this and the passed vector
     * @name minV
     * @memberof ObservableVector2d
     * @param {ObservableVector2d} v
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    minV(v) {
        return this._set((this._x < v.x) ? this._x : v.x, (this._y < v.y) ? this._y : v.y);
    }

    /**
     * Update this vector with the maximum value between this and the passed vector
     * @name maxV
     * @memberof ObservableVector2d
     * @param {ObservableVector2d} v
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    maxV(v) {
        return this._set((this._x > v.x) ? this._x : v.x, (this._y > v.y) ? this._y : v.y);
    }

    /**
     * Floor the vector values
     * @name floor
     * @memberof ObservableVector2d
     * @returns {ObservableVector2d} new me.ObservableVector2d
     */
    floor() {
        return new ObservableVector2d(Math.floor(this._x), Math.floor(this._y), {onUpdate: this.onUpdate, scope: this.scope});
    }

    /**
     * Floor this vector values
     * @name floorSelf
     * @memberof ObservableVector2d
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    floorSelf() {
        return this._set(Math.floor(this._x), Math.floor(this._y));
    }

    /**
     * Ceil the vector values
     * @name ceil
     * @memberof ObservableVector2d
     * @returns {ObservableVector2d} new me.ObservableVector2d
     */
    ceil() {
        return new ObservableVector2d(Math.ceil(this._x), Math.ceil(this._y), {onUpdate: this.onUpdate, scope: this.scope});
    }

    /**
     * Ceil this vector values
     * @name ceilSelf
     * @memberof ObservableVector2d
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    ceilSelf() {
        return this._set(Math.ceil(this._x), Math.ceil(this._y));
    }

    /**
     * Negate the vector values
     * @name negate
     * @memberof ObservableVector2d
     * @returns {ObservableVector2d} new me.ObservableVector2d
     */
    negate() {
        return new ObservableVector2d(-this._x, -this._y, {onUpdate: this.onUpdate, scope: this.scope});
    }

    /**
     * Negate this vector values
     * @name negateSelf
     * @memberof ObservableVector2d
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    negateSelf() {
        return this._set(-this._x, -this._y);
    }

    /**
     * Copy the x,y values of the passed vector to this one
     * @name copy
     * @memberof ObservableVector2d
     * @param {ObservableVector2d} v
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    copy(v) {
        return this._set(v.x, v.y);
    }

    /**
     * return true if the two vectors are the same
     * @name equals
     * @memberof ObservableVector2d
     * @param {ObservableVector2d} v
     * @returns {boolean}
     */
    equals(v) {
        return ((this._x === v.x) && (this._y === v.y));
    }

    /**
     * change this vector to be perpendicular to what it was before.<br>
     * (Effectively rotates it 90 degrees in a clockwise direction)
     * @name perp
     * @memberof ObservableVector2d
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    perp() {
        return this._set(this._y, -this._x);
    }

    /**
     * Rotate this vector (counter-clockwise) by the specified angle (in radians).
     * @name rotate
     * @memberof ObservableVector2d
     * @param {number} angle The angle to rotate (in radians)
     * @param {Vector2d|ObservableVector2d} [v] an optional point to rotate around
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    rotate(angle, v) {
        var cx = 0;
        var cy = 0;

        if (typeof v === "object") {
            cx = v.x;
            cy = v.y;
        }

        var x = this._x - cx;
        var y = this._y - cy;

        var c = Math.cos(angle);
        var s = Math.sin(angle);

        return this._set(x * c - y * s + cx, x * s + y * c + cy);
    }

    /**
     * return the dot product of this vector and the passed one
     * @name dot
     * @memberof ObservableVector2d
     * @param {Vector2d|ObservableVector2d} v
     * @returns {number} The dot product.
     */
    dot(v) {
        return this._x * v.x + this._y * v.y;
    }

    /**
     * return the cross product of this vector and the passed one
     * @name cross
     * @memberof ObservableVector2d
     * @param {Vector2d|ObservableVector2d} v
     * @returns {number} The cross product.
     */
    cross(v) {
        return this._x * v.y - this._y * v.x;
    }

    /**
     * Linearly interpolate between this vector and the given one.
     * @name lerp
     * @memberof ObservableVector2d
     * @param {Vector2d|ObservableVector2d} v
     * @param {number} alpha distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
     * @returns {ObservableVector2d} Reference to this object for method chaining
     */
    lerp(v, alpha) {
        this._x += ( v.x - this._x ) * alpha;
        this._y += ( v.y - this._y ) * alpha;
        return this;
    }

    /**
     * return the distance between this vector and the passed one
     * @name distance
     * @memberof ObservableVector2d
     * @param {ObservableVector2d} v
     * @returns {number}
     */
    distance(v) {
        return Math.sqrt((this._x - v.x) * (this._x - v.x) + (this._y - v.y) * (this._y - v.y));
    }

    /**
     * return a clone copy of this vector
     * @name clone
     * @memberof ObservableVector2d
     * @returns {ObservableVector2d} new me.ObservableVector2d
     */
    clone() {
        return pool.pull("ObservableVector2d", this._x, this._y, {onUpdate: this.onUpdate, scope: this.scope});
    }

    /**
     * return a `me.Vector2d` copy of this `me.ObservableVector2d` object
     * @name toVector2d
     * @memberof ObservableVector2d
     * @returns {Vector2d} new me.Vector2d
     */
    toVector2d() {
        return pool.pull("Vector2d", this._x, this._y);
    }

    /**
     * convert the object to a string representation
     * @name toString
     * @memberof ObservableVector2d
     * @returns {string}
     */
    toString() {
        return "x:" + this._x + ",y:" + this._y;
    }
}

/**
 * @classdesc
 * a generic 3D Vector Object
 */
class Vector3d {
    /**
     * @param {number} [x=0] x value of the vector
     * @param {number} [y=0] y value of the vector
     * @param {number} [z=0] z value of the vector
     */
    constructor(x = 0, y = 0, z = 0) {
        this.onResetEvent(x, y, z);
    }

    /**
     * @ignore
     */
    onResetEvent(x = 0, y = 0, z = 0) {
        // this is to enable proper object pooling
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }

    /**
     * @ignore
     */
    _set(x, y, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }

    /**
     * set the Vector x and y properties to the given values<br>
     * @name set
     * @memberof Vector3d
     * @param {number} x
     * @param {number} y
     * @param {number} [z=0]
     * @returns {Vector3d} Reference to this object for method chaining
     */
    set(x, y, z) {
        if (x !== +x || y !== +y || (typeof z !== "undefined" && z !== +z)) {
            throw new Error(
                "invalid x, y, z parameters (not a number)"
            );
        }

        /**
         * x value of the vector
         * @public
         * @member {number}
         * @name x
         * @memberof Vector3d
         */
        //this.x = x;

        /**
         * y value of the vector
         * @public
         * @member {number}
         * @name y
         * @memberof Vector3d
         */
        //this.y = y;

        /**
         * z value of the vector
         * @public
         * @member {number}
         * @name z
         * @memberof Vector3d
         */
        //this.z = z;

        return this._set(x, y, z);
    }

    /**
     * set the Vector x and y properties to 0
     * @name setZero
     * @memberof Vector3d
     * @returns {Vector3d} Reference to this object for method chaining
     */
    setZero() {
        return this.set(0, 0, 0);
    }

    /**
     * set the Vector x and y properties using the passed vector
     * @name setV
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v
     * @returns {Vector3d} Reference to this object for method chaining
     */
    setV(v) {
        return this._set(v.x, v.y, v.z);
    }

    /**
     * Add the passed vector to this vector
     * @name add
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v
     * @returns {Vector3d} Reference to this object for method chaining
     */
    add(v) {
        return this._set(this.x + v.x, this.y + v.y, this.z + (v.z || 0));
    }

    /**
     * Substract the passed vector to this vector
     * @name sub
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v
     * @returns {Vector3d} Reference to this object for method chaining
     */
    sub(v) {
        return this._set(this.x - v.x, this.y - v.y, this.z - (v.z || 0));
    }

    /**
     * Multiply this vector values by the given scalar
     * @name scale
     * @memberof Vector3d
     * @param {number} x
     * @param {number} [y=x]
     * @param {number} [z=1]
     * @returns {Vector3d} Reference to this object for method chaining
     */
    scale(x, y, z) {
        y = (typeof (y) !== "undefined" ? y : x);
        return this._set(this.x * x, this.y * y, this.z * (z || 1));
    }

    /**
     * Multiply this vector values by the passed vector
     * @name scaleV
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v
     * @returns {Vector3d} Reference to this object for method chaining
     */
    scaleV(v) {
        return this.scale(v.x, v.y, v.z);
    }

    /**
     * Convert this vector into isometric coordinate space
     * @name toIso
     * @memberof Vector3d
     * @returns {Vector3d} Reference to this object for method chaining
     */
    toIso() {
        return this._set(this.x - this.y, (this.x + this.y) * 0.5, this.z);
    }

    /**
     * Convert this vector into 2d coordinate space
     * @name to2d
     * @memberof Vector3d
     * @returns {Vector3d} Reference to this object for method chaining
     */
    to2d() {
        return this._set(this.y + this.x / 2, this.y - this.x / 2, this.z);
    }

    /**
     * Divide this vector values by the passed value
     * @name div
     * @memberof Vector3d
     * @param {number} n the value to divide the vector by
     * @returns {Vector3d} Reference to this object for method chaining
     */
    div(n) {
        return this._set(this.x / n, this.y / n, this.z / n);
    }

    /**
     * Update this vector values to absolute values
     * @name abs
     * @memberof Vector3d
     * @returns {Vector3d} Reference to this object for method chaining
     */
    abs() {
        return this._set((this.x < 0) ? -this.x : this.x, (this.y < 0) ? -this.y : this.y, (this.z < 0) ? -this.z : this.z);
    }

    /**
     * Clamp the vector value within the specified value range
     * @name clamp
     * @memberof Vector3d
     * @param {number} low
     * @param {number} high
     * @returns {Vector3d} new me.Vector3d
     */
    clamp(low, high) {
        return new Vector3d(clamp(this.x, low, high), clamp(this.y, low, high), clamp(this.z, low, high));
    }

    /**
     * Clamp this vector value within the specified value range
     * @name clampSelf
     * @memberof Vector3d
     * @param {number} low
     * @param {number} high
     * @returns {Vector3d} Reference to this object for method chaining
     */
    clampSelf(low, high) {
        return this._set(clamp(this.x, low, high), clamp(this.y, low, high), clamp(this.z, low, high));
    }

    /**
     * Update this vector with the minimum value between this and the passed vector
     * @name minV
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v
     * @returns {Vector3d} Reference to this object for method chaining
     */
    minV(v) {
        var _vz = v.z || 0;
        return this._set((this.x < v.x) ? this.x : v.x, (this.y < v.y) ? this.y : v.y, (this.z < _vz) ? this.z : _vz);
    }

    /**
     * Update this vector with the maximum value between this and the passed vector
     * @name maxV
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v
     * @returns {Vector3d} Reference to this object for method chaining
     */
    maxV(v) {
        var _vz = v.z || 0;
        return this._set((this.x > v.x) ? this.x : v.x, (this.y > v.y) ? this.y : v.y, (this.z > _vz) ? this.z : _vz);
    }

    /**
     * Floor the vector values
     * @name floor
     * @memberof Vector3d
     * @returns {Vector3d} new me.Vector3d
     */
    floor() {
        return new Vector3d(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));
    }

    /**
     * Floor this vector values
     * @name floorSelf
     * @memberof Vector3d
     * @returns {Vector3d} Reference to this object for method chaining
     */
    floorSelf() {
        return this._set(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));
    }

    /**
     * Ceil the vector values
     * @name ceil
     * @memberof Vector3d
     * @returns {Vector3d} new me.Vector3d
     */
    ceil() {
        return new Vector3d(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));
    }

    /**
     * Ceil this vector values
     * @name ceilSelf
     * @memberof Vector3d
     * @returns {Vector3d} Reference to this object for method chaining
     */
    ceilSelf() {
        return this._set(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));
    }

    /**
     * Negate the vector values
     * @name negate
     * @memberof Vector3d
     * @returns {Vector3d} new me.Vector3d
     */
    negate() {
        return new Vector3d(-this.x, -this.y, -this.z);
    }

    /**
     * Negate this vector values
     * @name negateSelf
     * @memberof Vector3d
     * @returns {Vector3d} Reference to this object for method chaining
     */
    negateSelf() {
        return this._set(-this.x, -this.y, -this.z);
    }

    /**
     * Copy the components of the given vector into this one
     * @name copy
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v
     * @returns {Vector3d} Reference to this object for method chaining
     */
    copy(v) {
        return this._set(v.x, v.y, v.z || 0);
    }

    /**
     * return true if the two vectors are the same
     * @name equals
     * @memberof Vector3d
     * @method
     * @param {Vector2d|Vector3d} v
     * @returns {boolean}
     */
    /**
     * return true if this vector is equal to the given values
     * @name equals
     * @memberof Vector3d
     * @param {number} x
     * @param {number} y
     * @param {number} [z]
     * @returns {boolean}
     */
    equals() {
        var _x, _y, _z;
        if (arguments.length >= 2) {
            // x, y, z
            _x = arguments[0];
            _y = arguments[1];
            _z = arguments[2];
        } else {
            // vector
            _x = arguments[0].x;
            _y = arguments[0].y;
            _z = arguments[0].z;
        }

        if (typeof _z === "undefined") {
            _z = this.z;
        }

        return ((this.x === _x) && (this.y === _y) && (this.z === _z));
    }

    /**
     * normalize this vector (scale the vector so that its magnitude is 1)
     * @name normalize
     * @memberof Vector3d
     * @returns {Vector3d} Reference to this object for method chaining
     */
    normalize() {
        return this.div(this.length() || 1);
    }

    /**
     * change this vector to be perpendicular to what it was before.<br>
     * (Effectively rotates it 90 degrees in a clockwise direction around the z axis)
     * @name perp
     * @memberof Vector3d
     * @returns {Vector3d} Reference to this object for method chaining
     */
    perp() {
        return this._set(this.y, -this.x, this.z);
    }

    /**
     * Rotate this vector (counter-clockwise) by the specified angle (in radians) around the z axis
     * @name rotate
     * @memberof Vector3d
     * @param {number} angle The angle to rotate (in radians)
     * @param {Vector2d|ObservableVector2d} [v] an optional point to rotate around (on the same z axis)
     * @returns {Vector3d} Reference to this object for method chaining
     */
    rotate(angle, v) {
        var cx = 0;
        var cy = 0;

        if (typeof v === "object") {
            cx = v.x;
            cy = v.y;
        }

        // TODO also rotate on the z axis if the given vector is a 3d one
        var x = this.x - cx;
        var y = this.y - cy;

        var c = Math.cos(angle);
        var s = Math.sin(angle);

        return this._set(x * c - y * s + cx, x * s + y * c + cy, this.z);
    }

    /**
     * return the dot product of this vector and the passed one
     * @name dot
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v
     * @returns {number} The dot product.
     */
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * (typeof(v.z) !== "undefined" ? v.z : this.z);
    }

    /**
     * calculate the cross product of this vector and the passed one
     * @name cross
     * @memberof Vector3d
     * @param {Vector3d} v
     * @returns {Vector3d} Reference to this object for method chaining
     */
    cross(v) {
        var ax = this.x, ay = this.y, az = this.z;
        var bx = v.x, by = v.y, bz = v.z;

        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;

        return this;
    }

   /**
    * return the square length of this vector
    * @name length2
    * @memberof Vector3d
    * @returns {number} The length^2 of this vector.
    */
    length2() {
        return this.dot(this);
    }

    /**
     * return the length (magnitude) of this vector
     * @name length
     * @memberof Vector3d
     * @returns {number} the length of this vector
     */
    length() {
        return Math.sqrt(this.length2());
    }

    /**
     * Linearly interpolate between this vector and the given one.
     * @name lerp
     * @memberof Vector3d
     * @param {Vector3d} v
     * @param {number} alpha distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
     * @returns {Vector3d} Reference to this object for method chaining
     */
    lerp(v, alpha) {
        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        this.z += ( v.z - this.z ) * alpha;
        return this;
    }

    /**
     * return the distance between this vector and the passed one
     * @name distance
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v
     * @returns {number}
     */
    distance(v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - (v.z || 0);
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    /**
     * return the angle between this vector and the passed one
     * @name angle
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v
     * @returns {number} angle in radians
     */
    angle(v) {
        return Math.acos(clamp(this.dot(v) / (this.length() * v.length()), -1, 1));
    }

    /**
     * project this vector on to another vector.
     * @name project
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v The vector to project onto.
     * @returns {Vector3d} Reference to this object for method chaining
     */
    project(v) {
        var ratio = this.dot(v) / v.length2();
        return this.scale(ratio, ratio, ratio);
    }

    /**
     * Project this vector onto a vector of unit length.<br>
     * This is slightly more efficient than `project` when dealing with unit vectors.
     * @name projectN
     * @memberof Vector3d
     * @param {Vector2d|Vector3d} v The unit vector to project onto.
     * @returns {Vector3d} Reference to this object for method chaining
     */
    projectN(v) {
        var ratio = this.dot(v) / v.length2();
        return this.scale(ratio, ratio, ratio);
    }

    /**
     * return a clone copy of this vector
     * @name clone
     * @memberof Vector3d
     * @returns {Vector3d} new me.Vector3d
     */
    clone() {
        return pool.pull("Vector3d", this.x, this.y, this.z);
    }

    /**
     * convert the object to a string representation
     * @name toString
     * @memberof Vector3d
     * @returns {string}
     */
    toString() {
        return "x:" + this.x + ",y:" + this.y + ",z:" + this.z;
    }
}

/**
 * @classdesc
 * A Vector3d object that provide notification by executing the given callback when the vector is changed.
 * @augments Vector3d
 */
class ObservableVector3d extends Vector3d {
    /**
     * @param {number} x x value of the vector
     * @param {number} y y value of the vector
     * @param {number} z z value of the vector
     * @param {object} settings additional required parameters
     * @param {Function} settings.onUpdate the callback to be executed when the vector is changed
     * @param {object} [settings.scope] the value to use as this when calling onUpdate
     */
    constructor(x = 0, y = 0, z = 0, settings) {
        super(x, y, z);
        if (typeof(settings) === "undefined") {
            throw new Error(
                "undefined `onUpdate` callback"
            );
        }
        this.setCallback(settings.onUpdate, settings.scope);
    }

    /**
     * @ignore
     */
    onResetEvent(x = 0, y = 0, z = 0, settings) {
        // init is call by the constructor and does not trigger the cb
        this.setMuted(x, y, z);
        if (typeof settings !== "undefined") {
            this.setCallback(settings.onUpdate, settings.scope);
        }
        return this;
    }

    /**
     * x value of the vector
     * @public
     * @type {number}
     * @name x
     * @memberof ObservableVector3d
     */

    get x() {
        return this._x;
    }

    set x(value) {
        var ret = this.onUpdate.call(this.scope, value, this._y, this._z, this._x, this._y, this._z);
        if (ret && "x" in ret) {
            this._x = ret.x;
        } else {
            this._x = value;
        }
    }

    /**
     * y value of the vector
     * @public
     * @type {number}
     * @name y
     * @memberof ObservableVector3d
     */

    get y() {
        return this._y;
    }

    set y(value) {
        var ret = this.onUpdate.call(this.scope, this._x, value, this._z, this._x, this._y, this._z);
        if (ret && "y" in ret) {
            this._y = ret.y;
        } else {
            this._y = value;
        }
    }


    /**
     * z value of the vector
     * @public
     * @type {number}
     * @name z
     * @memberof ObservableVector3d
     */


    get z() {
        return this._z;
    }

    set z(value) {
        var ret = this.onUpdate.call(this.scope, this._x, this._y, value, this._x, this._y, this._z);
        if (ret && "z" in ret) {
            this._z = ret.z;
        } else {
            this._z = value;
        }
    }

    /**
     * @ignore
     */
    _set(x, y, z) {
        var ret = this.onUpdate.call(this.scope, x, y, z, this._x, this._y, this._z);
        if (ret && "x" in ret && "y" in ret && "z" in ret) {
            this._x = ret.x;
            this._y = ret.y;
            this._z = ret.z;
        } else {
          this._x = x;
          this._y = y;
          this._z = z || 0;
        }
        return this;
    }

    /**
     * set the vector value without triggering the callback
     * @name setMuted
     * @memberof ObservableVector3d
     * @param {number} x x value of the vector
     * @param {number} y y value of the vector
     * @param {number} [z=0] z value of the vector
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    setMuted(x, y, z) {
        this._x = x;
        this._y = y;
        this._z = z || 0;
        return this;
    }

    /**
     * set the callback to be executed when the vector is changed
     * @name setCallback
     * @memberof ObservableVector3d
     * @param {Function} fn callback
     * @param {Function} [scope=null] scope
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    setCallback(fn, scope = null) {
        if (typeof(fn) !== "function") {
            throw new Error(
                "invalid `onUpdate` callback"
            );
        }
        this.onUpdate = fn;
        this.scope = scope;
        return this;
    }

    /**
     * Add the passed vector to this vector
     * @name add
     * @memberof ObservableVector3d
     * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    add(v) {
        return this._set(this._x + v.x, this._y + v.y, this._z + (v.z || 0));
    }

    /**
     * Substract the passed vector to this vector
     * @name sub
     * @memberof ObservableVector3d
     * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    sub(v) {
        return this._set(this._x - v.x, this._y - v.y, this._z - (v.z || 0));
    }

    /**
     * Multiply this vector values by the given scalar
     * @name scale
     * @memberof ObservableVector3d
     * @param {number} x
     * @param {number} [y=x]
     * @param {number} [z=1]
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    scale(x, y, z) {
        y = (typeof (y) !== "undefined" ? y : x);
        return this._set(this._x * x, this._y * y, this._z * (z || 1));
    }

    /**
     * Multiply this vector values by the passed vector
     * @name scaleV
     * @memberof ObservableVector3d
     * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    scaleV(v) {
        return this._set(this._x * v.x, this._y * v.y, this._z * (v.z || 1));
    }

    /**
     * Divide this vector values by the passed value
     * @name div
     * @memberof ObservableVector3d
     * @param {number} n the value to divide the vector by
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    div(n) {
        return this._set(this._x / n, this._y / n, this._z / n);
    }

    /**
     * Update this vector values to absolute values
     * @name abs
     * @memberof ObservableVector3d
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    abs() {
        return this._set(
            (this._x < 0) ? -this._x : this._x,
            (this._y < 0) ? -this._y : this._y,
            (this._Z < 0) ? -this._z : this._z
        );
    }

    /**
     * Clamp the vector value within the specified value range
     * @name clamp
     * @memberof ObservableVector3d
     * @param {number} low
     * @param {number} high
     * @returns {ObservableVector3d} new me.ObservableVector3d
     */
    clamp(low, high) {
        return new ObservableVector3d(
            clamp(this._x, low, high),
            clamp(this._y, low, high),
            clamp(this._z, low, high),
            {onUpdate: this.onUpdate, scope: this.scope}
        );
    }

    /**
     * Clamp this vector value within the specified value range
     * @name clampSelf
     * @memberof ObservableVector3d
     * @param {number} low
     * @param {number} high
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    clampSelf(low, high) {
        return this._set(
            clamp(this._x, low, high),
            clamp(this._y, low, high),
            clamp(this._z, low, high)
        );
    }

    /**
     * Update this vector with the minimum value between this and the passed vector
     * @name minV
     * @memberof ObservableVector3d
     * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    minV(v) {
        var _vz = v.z || 0;
        return this._set(
            (this._x < v.x) ? this._x : v.x,
            (this._y < v.y) ? this._y : v.y,
            (this._z < _vz) ? this._z : _vz
        );
    }

    /**
     * Update this vector with the maximum value between this and the passed vector
     * @name maxV
     * @memberof ObservableVector3d
     * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    maxV(v) {
        var _vz = v.z || 0;
        return this._set(
            (this._x > v.x) ? this._x : v.x,
            (this._y > v.y) ? this._y : v.y,
            (this._z > _vz) ? this._z : _vz
        );
    }

    /**
     * Floor the vector values
     * @name floor
     * @memberof ObservableVector3d
     * @returns {ObservableVector3d} new me.ObservableVector3d
     */
    floor() {
        return new ObservableVector3d(
            Math.floor(this._x),
            Math.floor(this._y),
            Math.floor(this._z),
            {onUpdate: this.onUpdate, scope: this.scope}
        );
    }

    /**
     * Floor this vector values
     * @name floorSelf
     * @memberof ObservableVector3d
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    floorSelf() {
        return this._set(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
    }

    /**
     * Ceil the vector values
     * @name ceil
     * @memberof ObservableVector3d
     * @returns {ObservableVector3d} new me.ObservableVector3d
     */
    ceil() {
        return new ObservableVector3d(
            Math.ceil(this._x),
            Math.ceil(this._y),
            Math.ceil(this._z),
            {onUpdate: this.onUpdate, scope: this.scope}
        );
    }

    /**
     * Ceil this vector values
     * @name ceilSelf
     * @memberof ObservableVector3d
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    ceilSelf() {
        return this._set(Math.ceil(this._x), Math.ceil(this._y), Math.ceil(this._z));
    }

    /**
     * Negate the vector values
     * @name negate
     * @memberof ObservableVector3d
     * @returns {ObservableVector3d} new me.ObservableVector3d
     */
    negate() {
        return new ObservableVector3d(
            -this._x,
            -this._y,
            -this._z,
            {onUpdate: this.onUpdate, scope: this.scope}
        );
    }

    /**
     * Negate this vector values
     * @name negateSelf
     * @memberof ObservableVector3d
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    negateSelf() {
        return this._set(-this._x, -this._y, -this._z);
    }

    /**
     * Copy the components of the given vector into this one
     * @name copy
     * @memberof ObservableVector3d
     * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    copy(v) {
        return this._set(v.x, v.y, v.z || 0);
    }

    /**
     * return true if the two vectors are the same
     * @name equals
     * @memberof ObservableVector3d
     * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
     * @returns {boolean}
     */
    equals(v) {
        return ((this._x === v.x) && (this._y === v.y) && (this._z === (v.z || this._z)));
    }

    /**
     * change this vector to be perpendicular to what it was before.<br>
     * (Effectively rotates it 90 degrees in a clockwise direction)
     * @name perp
     * @memberof ObservableVector3d
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    perp() {
        return this._set(this._y, -this._x, this._z);
    }

    /**
     * Rotate this vector (counter-clockwise) by the specified angle (in radians).
     * @name rotate
     * @memberof ObservableVector3d
     * @param {number} angle The angle to rotate (in radians)
     * @param {Vector2d|ObservableVector2d} [v] an optional point to rotate around (on the same z axis)
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    rotate(angle, v) {
        var cx = 0;
        var cy = 0;

        if (typeof v === "object") {
            cx = v.x;
            cy = v.y;
        }

        // TODO also rotate on the z axis if the given vector is a 3d one
        var x = this.x - cx;
        var y = this.y - cy;

        var c = Math.cos(angle);
        var s = Math.sin(angle);

        return this._set(x * c - y * s + cx, x * s + y * c + cy, this.z);
    }

    /**
     * return the dot product of this vector and the passed one
     * @name dot
     * @memberof ObservableVector3d
     * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
     * @returns {number} The dot product.
     */
    dot(v) {
        return this._x * v.x + this._y * v.y + this._z * (v.z || 1);
    }

    /**
     * calculate the cross product of this vector and the passed one
     * @name cross
     * @memberof ObservableVector3d
     * @param {Vector3d|ObservableVector3d} v
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    cross(v) {
        var ax = this._x, ay = this._y, az = this._z;
        var bx = v.x, by = v.y, bz = v.z;

        return this._set(
            ay * bz - az * by,
            az * bx - ax * bz,
            ax * by - ay * bx
        );
    }

    /**
     * Linearly interpolate between this vector and the given one.
     * @name lerp
     * @memberof ObservableVector3d
     * @param {Vector3d|ObservableVector3d} v
     * @param {number} alpha distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
     * @returns {ObservableVector3d} Reference to this object for method chaining
     */
    lerp(v, alpha) {
        this._x += ( v.x - this._x ) * alpha;
        this._y += ( v.y - this._y ) * alpha;
        this._z += ( v.z - this._z ) * alpha;
        return this;
    }

    /**
     * return the distance between this vector and the passed one
     * @name distance
     * @memberof ObservableVector3d
     * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
     * @returns {number}
     */
    distance(v) {
        var dx = this._x - v.x;
        var dy = this._y - v.y;
        var dz = this._z - (v.z || 0);
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    /**
     * return a clone copy of this vector
     * @name clone
     * @memberof ObservableVector3d
     * @returns {ObservableVector3d} new me.ObservableVector3d
     */
    clone() {
        return pool.pull("ObservableVector3d",
            this._x,
            this._y,
            this._z,
            {onUpdate: this.onUpdate}
        );
    }

    /**
     * return a `me.Vector3d` copy of this `me.ObservableVector3d` object
     * @name toVector3d
     * @memberof ObservableVector3d
     * @returns {Vector3d} new me.Vector3d
     */
    toVector3d() {
        return pool.pull("Vector3d", this._x, this._y, this._z);
    }

    /**
     * convert the object to a string representation
     * @name toString
     * @memberof ObservableVector3d
     * @returns {string}
     */
    toString() {
        return "x:" + this._x + ",y:" + this._y + ",z:" + this._z;
    }
}

var earcut$1 = {exports: {}};

earcut$1.exports = earcut;
earcut$1.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    var filteredBridge = filterPoints(bridge, bridge.next);
    filterPoints(bridgeReverse, bridgeReverse.next);

    // Check if input node was removed by the filtering
    return outerNode === bridge ? filteredBridge : outerNode;
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node$1(a.i, a.x, a.y),
        b2 = new Node$1(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node$1(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node$1(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

/**
 * @classdesc
 * a polygon Object.<br>
 * Please do note that melonJS implements a simple Axis-Aligned Boxes collision algorithm, which requires all polygons used for collision to be convex with all vertices defined with clockwise winding.
 * A polygon is convex when all line segments connecting two points in the interior do not cross any edge of the polygon
 * (which means that all angles are less than 180 degrees), as described here below : <br>
 * <center><img src="images/convex_polygon.png"/></center><br>
 *
 * A polygon's `winding` is clockwise if its vertices (points) are declared turning to the right. The image above shows COUNTERCLOCKWISE winding.
 */
class Polygon {
    /**
     * @param {number} x origin point of the Polygon
     * @param {number} y origin point of the Polygon
     * @param {Vector2d[]} points array of vector defining the Polygon
     */
    constructor(x, y, points) {
        /**
         * origin point of the Polygon
         * @public
         * @type {Vector2d}
         * @name pos
         * @memberof Polygon
         */
        this.pos = pool.pull("Vector2d");

        /**
         * The bounding rectangle for this shape
         * @ignore
         * @member {Bounds}
         * @name _bounds
         * @memberof Polygon
         */
        this._bounds;

        /**
         * Array of points defining the Polygon <br>
         * Note: If you manually change `points`, you **must** call `recalc`afterwards so that the changes get applied correctly.
         * @public
         * @type {Vector2d[]}
         * @name points
         * @memberof Polygon
         */
        this.points = [];

        /**
         * The edges here are the direction of the `n`th edge of the polygon, relative to
         * the `n`th point. If you want to draw a given edge from the edge value, you must
         * first translate to the position of the starting point.
         * @ignore
         */
        this.edges = [];

        /**
         * a list of indices for all vertices composing this polygon (@see earcut)
         * @ignore
         */
        this.indices = [];

        /**
         * The normals here are the direction of the normal for the `n`th edge of the polygon, relative
         * to the position of the `n`th point. If you want to draw an edge normal, you must first
         * translate to the position of the starting point.
         * @ignore
         */
        this.normals = [];

        // the shape type
        this.shapeType = "Polygon";
        this.setShape(x, y, points);
    }

    /** @ignore */
    onResetEvent(x, y, points) {
        this.setShape(x, y, points);
    }

    /**
     * set new value to the Polygon
     * @name setShape
     * @memberof Polygon
     * @param {number} x position of the Polygon
     * @param {number} y position of the Polygon
     * @param {Vector2d[]|number[]} points array of vector or vertice defining the Polygon
     * @returns {Polygon} this instance for objecf chaining
     */
    setShape(x, y, points) {
        this.pos.set(x, y);
        this.setVertices(points);
        return this;
    }

    /**
     * set the vertices defining this Polygon
     * @name setVertices
     * @memberof Polygon
     * @param {Vector2d[]} vertices array of vector or vertice defining the Polygon
     * @returns {Polygon} this instance for objecf chaining
     */
    setVertices(vertices) {

        if (!Array.isArray(vertices)) {
            return this;
        }

        // convert given points to me.Vector2d if required
        if (!(vertices[0] instanceof Vector2d)) {
            this.points.length = 0;

            if (typeof vertices[0] === "object") {
                // array of {x,y} object
                vertices.forEach((vertice) => {
                   this.points.push(pool.pull("Vector2d", vertice.x, vertice.y));
                });

            } else {
                // it's a flat array
                for (var p = 0; p < vertices.length; p += 2) {
                    this.points.push(pool.pull("Vector2d", vertices[p], vertices[p + 1]));
                }
            }
        } else {
            // array of me.Vector2d
            this.points = vertices;
        }

        this.recalc();
        this.updateBounds();
        return this;
    }

    /**
     * apply the given transformation matrix to this Polygon
     * @name transform
     * @memberof Polygon
     * @param {Matrix2d} m the transformation matrix
     * @returns {Polygon} Reference to this object for method chaining
     */
    transform(m) {
        var points = this.points;
        var len = points.length;
        for (var i = 0; i < len; i++) {
            m.apply(points[i]);
        }
        this.recalc();
        this.updateBounds();
        return this;
    }

    /**
     * apply an isometric projection to this shape
     * @name toIso
     * @memberof Polygon
     * @returns {Polygon} Reference to this object for method chaining
     */
    toIso() {
        return this.rotate(Math.PI / 4).scale(Math.SQRT2, Math.SQRT1_2);
    }

    /**
     * apply a 2d projection to this shape
     * @name to2d
     * @memberof Polygon
     * @returns {Polygon} Reference to this object for method chaining
     */
    to2d() {
        return this.scale(Math.SQRT1_2, Math.SQRT2).rotate(-Math.PI / 4);
    }

    /**
     * Rotate this Polygon (counter-clockwise) by the specified angle (in radians).
     * @name rotate
     * @memberof Polygon
     * @param {number} angle The angle to rotate (in radians)
     * @param {Vector2d|ObservableVector2d} [v] an optional point to rotate around
     * @returns {Polygon} Reference to this object for method chaining
     */
    rotate(angle, v) {
        if (angle !== 0) {
            var points = this.points;
            var len = points.length;
            for (var i = 0; i < len; i++) {
                points[i].rotate(angle, v);
            }
            this.recalc();
            this.updateBounds();
        }
        return this;
    }

    /**
     * Scale this Polygon by the given scalar.
     * @name scale
     * @memberof Polygon
     * @param {number} x
     * @param {number} [y=x]
     * @returns {Polygon} Reference to this object for method chaining
     */
    scale(x, y) {
        y = typeof (y) !== "undefined" ? y : x;

        var points = this.points;
        var len = points.length;
        for (var i = 0; i < len; i++) {
            points[i].scale(x, y);
        }
        this.recalc();
        this.updateBounds();
        return this;
    }

    /**
     * Scale this Polygon by the given vector
     * @name scaleV
     * @memberof Polygon
     * @param {Vector2d} v
     * @returns {Polygon} Reference to this object for method chaining
     */
    scaleV(v) {
        return this.scale(v.x, v.y);
    }

    /**
     * Computes the calculated collision polygon.
     * This **must** be called if the `points` array, `angle`, or `offset` is modified manually.
     * @name recalc
     * @memberof Polygon
     * @returns {Polygon} Reference to this object for method chaining
     */
    recalc() {
        var i;
        var edges = this.edges;
        var normals = this.normals;
        var indices = this.indices;

        // Copy the original points array and apply the offset/angle
        var points = this.points;
        var len = points.length;

        if (len < 3) {
            throw new Error("Requires at least 3 points");
        }

        // Calculate the edges/normals
        for (i = 0; i < len; i++) {
            if (edges[i] === undefined) {
                edges[i] = pool.pull("Vector2d");
            }
            edges[i].copy(points[(i + 1) % len]).sub(points[i]);

            if (normals[i] === undefined) {
                normals[i] = pool.pull("Vector2d");
            }
            normals[i].copy(edges[i]).perp().normalize();
        }
        // trunc array
        edges.length = len;
        normals.length = len;
        // do not do anything here, indices will be computed by
        // getIndices if array is empty upon function call
        indices.length = 0;

        return this;
    }


    /**
     * returns a list of indices for all triangles defined in this polygon
     * @name getIndices
     * @memberof Polygon
     * @returns {Array} an array of vertex indices for all triangles forming this polygon.
     */
    getIndices() {
        if (this.indices.length === 0) {
            this.indices = earcut$1.exports(this.points.flatMap(p => [p.x, p.y]));
        }
        return this.indices;
    }

    /**
     * Returns true if the vertices composing this polygon form a convex shape (vertices must be in clockwise order).
     * @name isConvex
     * @memberof Polygon
     * @returns {boolean} true if the vertices are convex, false if not, null if not computable
     */
    isConvex() {
        // http://paulbourke.net/geometry/polygonmesh/
        // Copyright (c) Paul Bourke (use permitted)

        var flag = 0,
            vertices = this.points,
            n = vertices.length,
            i,
            j,
            k,
            z;

        if (n < 3) {
            return null;
        }

        for (i = 0; i < n; i++) {
            j = (i + 1) % n;
            k = (i + 2) % n;
            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);

            if (z < 0) {
                flag |= 1;
            } else if (z > 0) {
                flag |= 2;
            }

            if (flag === 3) {
                return false;
            }
        }

        if (flag !== 0) {
            return true;
        } else {
            return null;
        }
    }

    /**
     * translate the Polygon by the specified offset
     * @name translate
     * @memberof Polygon
     * @method
     * @param {number} x x offset
     * @param {number} y y offset
     * @returns {Polygon} this Polygon
     */
    /**
     * translate the Polygon by the specified vector
     * @name translate
     * @memberof Polygon
     * @param {Vector2d} v vector offset
     * @returns {Polygon} Reference to this object for method chaining
     */
    translate() {
        var _x, _y;

        if (arguments.length === 2) {
            // x, y
            _x = arguments[0];
            _y = arguments[1];
        } else {
            // vector
            _x = arguments[0].x;
            _y = arguments[0].y;
        }

        this.pos.x += _x;
        this.pos.y += _y;
        this.getBounds().translate(_x, _y);

        return this;
    }

    /**
     * Shifts the Polygon to the given position vector.
     * @name shift
     * @memberof Polygon
     * @method
     * @param {Vector2d} position
     */
    /**
     * Shifts the Polygon to the given x, y position.
     * @name shift
     * @memberof Polygon
     * @param {number} x
     * @param {number} y
     */
    shift() {
        var _x, _y;
        if (arguments.length === 2) {
            // x, y
            _x = arguments[0];
            _y = arguments[1];
        } else {
            // vector
            _x = arguments[0].x;
            _y = arguments[0].y;
        }
        this.pos.x = _x;
        this.pos.y = _y;
        this.updateBounds();
    }

    /**
     * Returns true if the polygon contains the given point.
     * (Note: it is highly recommended to first do a hit test on the corresponding <br>
     *  bounding rect, as the function can be highly consuming with complex shapes)
     * @name contains
     * @memberof Polygon
     * @method
     * @param {Vector2d} point
     * @returns {boolean} true if contains
     */

    /**
     * Returns true if the polygon contains the given point. <br>
     * (Note: it is highly recommended to first do a hit test on the corresponding <br>
     *  bounding rect, as the function can be highly consuming with complex shapes)
     * @name contains
     * @memberof Polygon
     * @param  {number} x x coordinate
     * @param  {number} y y coordinate
     * @returns {boolean} true if contains
     */
    contains() {
        var _x, _y;

        if (arguments.length === 2) {
          // x, y
          _x = arguments[0];
          _y = arguments[1];
        } else {
          // vector
          _x = arguments[0].x;
          _y = arguments[0].y;
        }

        var intersects = false;
        var posx = this.pos.x, posy = this.pos.y;
        var points = this.points;
        var len = points.length;

        //http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
        for (var i = 0, j = len - 1; i < len; j = i++) {
            var iy = points[i].y + posy, ix = points[i].x + posx,
                jy = points[j].y + posy, jx = points[j].x + posx;
            if (((iy > _y) !== (jy > _y)) && (_x < (jx - ix) * (_y - iy) / (jy - iy) + ix)) {
                intersects = !intersects;
            }
        }
        return intersects;
    }

    /**
     * returns the bounding box for this shape, the smallest Rectangle object completely containing this shape.
     * @name getBounds
     * @memberof Polygon
     * @returns {Bounds} this shape bounding box Rectangle object
     */
    getBounds() {
        if (typeof this._bounds === "undefined") {
            this._bounds = pool.pull("Bounds");
        }
        return this._bounds;
    }

    /**
     * update the bounding box for this shape.
     * @ignore
     * @name updateBounds
     * @memberof Polygon
     * @returns {Bounds} this shape bounding box Rectangle object
     */
    updateBounds() {
        var bounds = this.getBounds();

        bounds.update(this.points);
        bounds.translate(this.pos);

        return bounds;
    }

    /**
     * clone this Polygon
     * @name clone
     * @memberof Polygon
     * @returns {Polygon} new Polygon
     */
    clone() {
        var copy = [];
        this.points.forEach(function (point) {
            copy.push(point.clone());
        });
        return new Polygon(this.pos.x, this.pos.y, copy);
    }
}

/**
 * @classdesc
 * a rectangle Object
 * @augments Polygon
 */
class Rect extends Polygon {
    /**
     * @param {number} x position of the Rectangle
     * @param {number} y position of the Rectangle
     * @param {number} w width of the rectangle
     * @param {number} h height of the rectangle
     */
    constructor(x, y, w, h) {
        // parent constructor
        super(x, y, [
            pool.pull("Vector2d", 0, 0), // 0, 0
            pool.pull("Vector2d", w, 0), // 1, 0
            pool.pull("Vector2d", w, h), // 1, 1
            pool.pull("Vector2d", 0, h)  // 0, 1
        ]);
        this.shapeType = "Rectangle";
    }

    /** @ignore */
    onResetEvent(x, y, w, h) {
        this.setShape(x, y, w, h);
    }

    /**
     * set new value to the rectangle shape
     * @name setShape
     * @memberof Rect
     * @param {number} x position of the Rectangle
     * @param {number} y position of the Rectangle
     * @param {number|Vector2d[]} w width of the rectangle, or an array of vector defining the rectangle
     * @param {number} [h] height of the rectangle, if a numeral width parameter is specified
     * @returns {Rect} this rectangle
     */
    setShape(x, y, w, h) {
        var points = w; // assume w is an array by default

        this.pos.set(x, y);

        if (arguments.length === 4) {
            points = this.points;
            points[0].set(0, 0); // 0, 0
            points[1].set(w, 0); // 1, 0
            points[2].set(w, h); // 1, 1
            points[3].set(0, h); // 0, 1
        }

        this.setVertices(points);
        return this;
    }


    /**
     * left coordinate of the Rectangle
     * @public
     * @type {number}
     * @name left
     * @memberof Rect
     */
    get left() {
        return this.pos.x;
    }

    /**
     * right coordinate of the Rectangle
     * @public
     * @type {number}
     * @name right
     * @memberof Rect
     */
    get right() {
        var w = this.width;
        return (this.pos.x + w) || w;
    }

    /**
     * top coordinate of the Rectangle
     * @public
     * @type {number}
     * @name top
     * @memberof Rect
     */
    get top() {
        return this.pos.y;
    }

    /**
     * bottom coordinate of the Rectangle
     * @public
     * @type {number}
     * @name bottom
     * @memberof Rect
     */
    get bottom() {
        var h = this.height;
        return (this.pos.y + h) || h;
    }

    /**
     * width of the Rectangle
     * @public
     * @type {number}
     * @name width
     * @memberof Rect
     */
    get width() {
        return this.points[2].x;
    }
    set width(value) {
        this.points[1].x = this.points[2].x = value;
        this.recalc();
        this.updateBounds();
    }

    /**
     * height of the Rectangle
     * @public
     * @type {number}
     * @name height
     * @memberof Rect
     */
    get height() {
        return this.points[2].y;
    }
    set height(value) {
        this.points[2].y = this.points[3].y = value;
        this.recalc();
        this.updateBounds();
    }

    /**
     * absolute center of this rectangle on the horizontal axis
     * @public
     * @type {number}
     * @name centerX
     * @memberof Rect
     */
    get centerX() {
        if (isFinite(this.width)) {
            return this.pos.x + (this.width / 2);
        } else {
            return this.width;
        }
    }
    set centerX (value) {
        this.pos.x = value - (this.width / 2);
    }

    /**
     * absolute center of this rectangle on the vertical axis
     * @public
     * @type {number}
     * @name centerY
     * @memberof Rect
     */
    get centerY() {
        if (isFinite(this.height)) {
            return this.pos.y + (this.height / 2);
        } else {
            return this.height;
        }
    }
    set centerY(value) {
        this.pos.y = value - (this.height / 2);
    }

    /**
     * center the rectangle position around the given coordinates
     * @name centerOn
     * @memberof Rect
     * @param {number} x the x coordinate around which to center this rectangle
     * @param {number} y the y coordinate around which to center this rectangle
     * @returns {Rect} this rectangle
     */
    centerOn(x, y) {
        this.centerX = x;
        this.centerY = y;
        return this;
    }

    /**
     * resize the rectangle
     * @name resize
     * @memberof Rect
     * @param {number} w new width of the rectangle
     * @param {number} h new height of the rectangle
     * @returns {Rect} this rectangle
     */
    resize(w, h) {
        this.width = w;
        this.height = h;
        return this;
    }

    /**
     * scale the rectangle
     * @name scale
     * @memberof Rect
     * @param {number} x a number representing the abscissa of the scaling vector.
     * @param {number} [y=x] a number representing the ordinate of the scaling vector.
     * @returns {Rect} this rectangle
     */
    scale(x, y = x) {
        this.width *= x;
        this.height *= y;
        return this;
    }

    /**
     * clone this rectangle
     * @name clone
     * @memberof Rect
     * @returns {Rect} new rectangle
     */
    clone() {
        return new Rect(this.pos.x, this.pos.y, this.width, this.height);
    }

    /**
     * copy the position and size of the given rectangle into this one
     * @name copy
     * @memberof Rect
     * @param {Rect} rect Source rectangle
     * @returns {Rect} new rectangle
     */
    copy(rect) {
        return this.setShape(rect.pos.x, rect.pos.y, rect.width, rect.height);
    }

    /**
     * merge this rectangle with another one
     * @name union
     * @memberof Rect
     * @param {Rect} rect other rectangle to union with
     * @returns {Rect} the union(ed) rectangle
     */
    union(rect) {
        var x1 = Math.min(this.left, rect.left);
        var y1 = Math.min(this.top, rect.top);

        this.resize(
            Math.max(this.right, rect.right) - x1,
            Math.max(this.bottom, rect.bottom) - y1
        );

        this.pos.set(x1, y1);

        return this;
    }

    /**
     * check if this rectangle is intersecting with the specified one
     * @name overlaps
     * @memberof Rect
     * @param {Rect} rect
     * @returns {boolean} true if overlaps
     */
    overlaps(rect) {
        return (
            this.left < rect.right &&
            rect.left < this.right &&
            this.top < rect.bottom &&
            rect.top < this.bottom
        );
    }

    /**
     * Returns true if the rectangle contains the given rectangle
     * @name contains
     * @memberof Rect
     * @method
     * @param {Rect} rect
     * @returns {boolean} true if contains
     */

    /**
     * Returns true if the rectangle contains the given point
     * @name contains
     * @memberof Rect
     * @method
     * @param  {number} x x coordinate
     * @param  {number} y y coordinate
     * @returns {boolean} true if contains
     */

    /**
     * Returns true if the rectangle contains the given point
     * @name contains
     * @memberof Rect
     * @param {Vector2d} point
     * @returns {boolean} true if contains
     */
    contains() {
        var arg0 = arguments[0];
        var _x1, _x2, _y1, _y2;
        if (arguments.length === 2) {
             // x, y
             _x1 = _x2 = arg0;
             _y1 = _y2 = arguments[1];
         } else {
             if (arg0 instanceof Rect) {
                 // me.Rect
                 _x1 = arg0.left;
                 _x2 = arg0.right;
                 _y1 = arg0.top;
                 _y2 = arg0.bottom;
             } else {
                 // vector
                 _x1 = _x2 = arg0.x;
                 _y1 = _y2 = arg0.y;
             }
         }
         return (
             _x1 >= this.left &&
             _x2 <= this.right &&
             _y1 >= this.top &&
             _y2 <= this.bottom
         );
    }

    /**
     * check if this rectangle is identical to the specified one
     * @name equals
     * @memberof Rect
     * @param {Rect} rect
     * @returns {boolean} true if equals
     */
    equals(rect) {
        return (
            rect.left === this.left &&
            rect.right === this.right &&
            rect.top === this.top &&
            rect.bottom === this.bottom
        );
    }

    /**
     * determines whether all coordinates of this rectangle are finite numbers.
     * @name isFinite
     * @memberof Rect
     * @returns {boolean} false if all coordinates are positive or negative Infinity or NaN; otherwise, true.
     */
    isFinite() {
        return (isFinite(this.pos.x) && isFinite(this.pos.y) && isFinite(this.width) && isFinite(this.height));
    }

    /**
     * Returns a polygon whose edges are the same as this box.
     * @name toPolygon
     * @memberof Rect
     * @returns {Polygon} a new Polygon that represents this rectangle.
     */
    toPolygon() {
        return pool.pull("Polygon",
            this.pos.x, this.pos.y, this.points
        );
    }
}

// corresponding actions
var _keyStatus = {};

// lock enable flag for keys
var _keyLock = {};
// actual lock status of each key
var _keyLocked = {};

// List of binded keys being held
var _keyRefs = {};

// whether default event should be prevented for a given keypress
var _preventDefaultForKeys = {};

// list of binded keys
var _keyBindings = {};

/**
 * key down event
 * @ignore
 */
var keyDownEvent = function (e, keyCode, mouseButton) {

    keyCode = keyCode || e.keyCode || e.button;
    var action = _keyBindings[keyCode];

    // publish a message for keydown event
    emit(KEYDOWN,
        action,
        keyCode,
        action ? !_keyLocked[action] : true
    );

    if (action) {
        if (!_keyLocked[action]) {
            var trigger = (typeof mouseButton !== "undefined") ? mouseButton : keyCode;
            if (!_keyRefs[action][trigger]) {
                _keyStatus[action]++;
                _keyRefs[action][trigger] = true;
            }
        }
        // prevent event propagation
        if (_preventDefaultForKeys[keyCode] && (typeof e.preventDefault === "function")) {
            // "fake" events generated through triggerKeyEvent do not have a preventDefault fn
            return e.preventDefault();
        }
        else {
            return true;
        }
    }

    return true;
};


/**
 * key up event
 * @ignore
 */
var keyUpEvent = function (e, keyCode, mouseButton) {
    keyCode = keyCode || e.keyCode || e.button;
    var action = _keyBindings[keyCode];

    // publish a message for keydown event
    emit(KEYUP, action, keyCode);

    if (action) {
        var trigger = (typeof mouseButton !== "undefined") ? mouseButton : keyCode;
        _keyRefs[action][trigger] = undefined;

        if (_keyStatus[action] > 0) {
            _keyStatus[action]--;
        }

        _keyLocked[action] = false;

        // prevent event propagation
        if (_preventDefaultForKeys[keyCode] && (typeof e.preventDefault === "function")) {
            // "fake" events generated through triggerKeyEvent do not have a preventDefault fn
            return e.preventDefault();
        }
        else {
            return true;
        }
    }

    return true;
};

/*
 * PUBLIC STUFF
 */

 /**
  * the default target element for keyboard events (usually the window element in which the game is running)
  * @public
  * @type {EventTarget}
  * @name keyBoardEventTarget
  * @memberof input
  */
 var keyBoardEventTarget = null;

/**
 * standard keyboard constants
 * @public
 * @enum {number}
 * @namespace KEY
 * @memberof input
 */
const KEY = {
    "BACKSPACE" : 8,
    /** @memberof input.KEY */
    "TAB" : 9,
    /** @memberof input.KEY */
    "ENTER" : 13,
    /** @memberof input.KEY */
    "SHIFT" : 16,
    /** @memberof input.KEY */
    "CTRL" : 17,
    /** @memberof input.KEY */
    "ALT" : 18,
    /** @memberof input.KEY */
    "PAUSE" : 19,
    /** @memberof input.KEY */
    "CAPS_LOCK" : 20,
    /** @memberof input.KEY */
    "ESC" : 27,
    /** @memberof input.KEY */
    "SPACE" : 32,
    /** @memberof input.KEY */
    "PAGE_UP" : 33,
    /** @memberof input.KEY */
    "PAGE_DOWN" : 34,
    /** @memberof input.KEY */
    "END" : 35,
    /** @memberof input.KEY */
    "HOME" : 36,
    /** @memberof input.KEY */
    "LEFT" : 37,
    /** @memberof input.KEY */
    "UP" : 38,
    /** @memberof input.KEY */
    "RIGHT" : 39,
    /** @memberof input.KEY */
    "DOWN" : 40,
    /** @memberof input.KEY */
    "PRINT_SCREEN" : 42,
    /** @memberof input.KEY */
    "INSERT" : 45,
    /** @memberof input.KEY */
    "DELETE" : 46,
    /** @memberof input.KEY */
    "NUM0" : 48,
    /** @memberof input.KEY */
    "NUM1" : 49,
    /** @memberof input.KEY */
    "NUM2" : 50,
    /** @memberof input.KEY */
    "NUM3" : 51,
    /** @memberof input.KEY */
    "NUM4" : 52,
    /** @memberof input.KEY */
    "NUM5" : 53,
    /** @memberof input.KEY */
    "NUM6" : 54,
    /** @memberof input.KEY */
    "NUM7" : 55,
    /** @memberof input.KEY */
    "NUM8" : 56,
    /** @memberof input.KEY */
    "NUM9" : 57,
    /** @memberof input.KEY */
    "A" : 65,
    /** @memberof input.KEY */
    "B" : 66,
    /** @memberof input.KEY */
    "C" : 67,
    /** @memberof input.KEY */
    "D" : 68,
    /** @memberof input.KEY */
    "E" : 69,
    /** @memberof input.KEY */
    "F" : 70,
    /** @memberof input.KEY */
    "G" : 71,
    /** @memberof input.KEY */
    "H" : 72,
    /** @memberof input.KEY */
    "I" : 73,
    /** @memberof input.KEY */
    "J" : 74,
    /** @memberof input.KEY */
    "K" : 75,
    /** @memberof input.KEY */
    "L" : 76,
    /** @memberof input.KEY */
    "M" : 77,
    /** @memberof input.KEY */
    "N" : 78,
    /** @memberof input.KEY */
    "O" : 79,
    /** @memberof input.KEY */
    "P" : 80,
    /** @memberof input.KEY */
    "Q" : 81,
    /** @memberof input.KEY */
    "R" : 82,
    /** @memberof input.KEY */
    "S" : 83,
    /** @memberof input.KEY */
    "T" : 84,
    /** @memberof input.KEY */
    "U" : 85,
    /** @memberof input.KEY */
    "V" : 86,
    /** @memberof input.KEY */
    "W" : 87,
    /** @memberof input.KEY */
    "X" : 88,
    /** @memberof input.KEY */
    "Y" : 89,
    /** @memberof input.KEY */
    "Z" : 90,
    /** @memberof input.KEY */
    "WINDOW_KEY" : 91,
    /** @memberof input.KEY */
    "NUMPAD0" : 96,
    /** @memberof input.KEY */
    "NUMPAD1" : 97,
    /** @memberof input.KEY */
    "NUMPAD2" : 98,
    /** @memberof input.KEY */
    "NUMPAD3" : 99,
    /** @memberof input.KEY */
    "NUMPAD4" : 100,
    /** @memberof input.KEY */
    "NUMPAD5" : 101,
    /** @memberof input.KEY */
    "NUMPAD6" : 102,
    /** @memberof input.KEY */
    "NUMPAD7" : 103,
    /** @memberof input.KEY */
    "NUMPAD8" : 104,
    /** @memberof input.KEY */
    "NUMPAD9" : 105,
    /** @memberof input.KEY */
    "MULTIPLY" : 106,
    /** @memberof input.KEY */
    "ADD" : 107,
    /** @memberof input.KEY */
    "SUBSTRACT" : 109,
    /** @memberof input.KEY */
    "DECIMAL" : 110,
    /** @memberof input.KEY */
    "DIVIDE" : 111,
    /** @memberof input.KEY */
    "F1" : 112,
    /** @memberof input.KEY */
    "F2" : 113,
    /** @memberof input.KEY */
    "F3" : 114,
    /** @memberof input.KEY */
    "F4" : 115,
    /** @memberof input.KEY */
    "F5" : 116,
    /** @memberof input.KEY */
    "F6" : 117,
    /** @memberof input.KEY */
    "F7" : 118,
    /** @memberof input.KEY */
    "F8" : 119,
    /** @memberof input.KEY */
    "F9" : 120,
    /** @memberof input.KEY */
    "F10" : 121,
    /** @memberof input.KEY */
    "F11" : 122,
    /** @memberof input.KEY */
    "F12" : 123,
    /** @memberof input.KEY */
    "TILDE" : 126,
    /** @memberof input.KEY */
    "NUM_LOCK" : 144,
    /** @memberof input.KEY */
    "SCROLL_LOCK" : 145,
    /** @memberof input.KEY */
    "SEMICOLON" : 186,
    /** @memberof input.KEY */
    "PLUS" : 187,
    /** @memberof input.KEY */
    "COMMA" : 188,
    /** @memberof input.KEY */
    "MINUS" : 189,
    /** @memberof input.KEY */
    "PERIOD" : 190,
    /** @memberof input.KEY */
    "FORWAND_SLASH" : 191,
    /** @memberof input.KEY */
    "GRAVE_ACCENT" : 192,
    /** @memberof input.KEY */
    "OPEN_BRACKET" : 219,
    /** @memberof input.KEY */
    "BACK_SLASH" : 220,
    /** @memberof input.KEY */
    "CLOSE_BRACKET" : 221,
    /** @memberof input.KEY */
    "SINGLE_QUOTE" : 222
};

/**
 * enable keyboard event
 * @ignore
 */
function initKeyboardEvent() {
    // make sure the keyboard is enable
    if (keyBoardEventTarget === null && device.isMobile === false) {
        keyBoardEventTarget = globalThis;
        if (typeof keyBoardEventTarget.addEventListener === "function") {
            keyBoardEventTarget.addEventListener("keydown", keyDownEvent, false);
            keyBoardEventTarget.addEventListener("keyup", keyUpEvent, false);
        }
    }
}
/**
 * return the key press status of the specified action
 * @name isKeyPressed
 * @memberof input
 * @public
 * @param {string} action user defined corresponding action
 * @returns {boolean} true if pressed
 * @example
 * if (me.input.isKeyPressed('left')) {
 *    //do something
 * }
 * else if (me.input.isKeyPressed('right')) {
 *    //do something else...
 * }
 */
function isKeyPressed(action) {
    if (_keyStatus[action] && !_keyLocked[action]) {
        if (_keyLock[action]) {
            _keyLocked[action] = true;
        }
        return true;
    }
    return false;
}
/**
 * return the key status of the specified action
 * @name keyStatus
 * @memberof input
 * @public
 * @param {string} action user defined corresponding action
 * @returns {boolean} down (true) or up(false)
 */
function keyStatus(action) {
    return (_keyStatus[action] > 0);
}

/**
 * trigger the specified key (simulated) event <br>
 * @name triggerKeyEvent
 * @memberof input
 * @public
 * @param {number} keycode (See {@link input.KEY})
 * @param {boolean} [status=false] true to trigger a key down event, or false for key up event
 * @param {number} [mouseButton] the mouse button to trigger
 * @example
 * // trigger a key press
 * me.input.triggerKeyEvent(me.input.KEY.LEFT, true);
 */
function triggerKeyEvent(keycode, status, mouseButton) {
    if (status === true) {
        keyDownEvent({}, keycode, mouseButton);
    }
    else {
        keyUpEvent({}, keycode, mouseButton);
    }
}

/**
 * associate a user defined action to a keycode
 * @name bindKey
 * @memberof input
 * @public
 * @param {number} keycode (See {@link input.KEY})
 * @param {string} action user defined corresponding action
 * @param {boolean} [lock=false] cancel the keypress event once read
 * @param {boolean} [preventDefault=input.preventDefault] prevent default browser action
 * @example
 * // enable the keyboard
 * me.input.bindKey(me.input.KEY.LEFT,  "left");
 * me.input.bindKey(me.input.KEY.RIGHT, "right");
 * me.input.bindKey(me.input.KEY.X,     "jump", true);
 * me.input.bindKey(me.input.KEY.F1,    "options", true, true);
 */
function bindKey(keycode, action, lock, preventDefault$1 = preventDefault) {
    _keyBindings[keycode] = action;
    _preventDefaultForKeys[keycode] = preventDefault$1;

    _keyStatus[action] = 0;
    _keyLock[action] = lock ? lock : false;
    _keyLocked[action] = false;
    _keyRefs[action] = {};
}
/**
 * return the action associated with the given keycode
 * @name getBindingKey
 * @memberof input
 * @public
 * @param {number} keycode (See {@link input.KEY})
 * @returns {string} user defined associated action
 */
function getBindingKey(keycode) {
    return _keyBindings[keycode];
}
/**
 * unlock a key manually
 * @name unlockKey
 * @memberof input
 * @public
 * @param {string} action user defined corresponding action
 * @example
 * // Unlock jump when touching the ground
 * if (!this.falling && !this.jumping) {
 *     me.input.unlockKey("jump");
 * }
 */
function unlockKey(action) {
    _keyLocked[action] = false;
}
/**
 * unbind the defined keycode
 * @name unbindKey
 * @memberof input
 * @public
 * @param {number} keycode (See {@link input.KEY})
 * @example
 * me.input.unbindKey(me.input.KEY.LEFT);
 */
function unbindKey(keycode) {
    // clear the event status
    var keybinding = _keyBindings[keycode];
    _keyStatus[keybinding] = 0;
    _keyLock[keybinding] = false;
    _keyRefs[keybinding] = {};
    // remove the key binding
    _keyBindings[keycode] = null;
    _preventDefaultForKeys[keycode] = null;
}

/**
 * @classdesc
 * a bound object contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
 */
class Bounds {
    /**
     * @param {Vector2d[]} [vertices] an array of me.Vector2d points
     */
    constructor(vertices) {
        // @ignore
        this._center = new Vector2d();
        this.onResetEvent(vertices);
    }

    /**
     * @ignore
     */
    onResetEvent(vertices) {
        if (typeof this.min === "undefined") {
            this.min = { x: Infinity,  y: Infinity };
            this.max = { x: -Infinity, y: -Infinity };
        } else {
            this.clear();
        }
        if (typeof vertices !== "undefined") {
            this.update(vertices);
        }
    }

    /**
     * reset the bound
     * @name clear
     * @memberof Bounds
     */
    clear() {
        this.setMinMax(Infinity, Infinity, -Infinity, -Infinity);

    }

    /**
     * sets the bounds to the given min and max value
     * @name setMinMax
     * @memberof Bounds
     * @param {number} minX
     * @param {number} minY
     * @param {number} maxX
     * @param {number} maxY
     */
    setMinMax(minX, minY, maxX, maxY) {
        this.min.x = minX;
        this.min.y = minY;

        this.max.x = maxX;
        this.max.y = maxY;
    }

    /**
     * x position of the bound
     * @public
     * @type {number}
     * @name x
     * @memberof Bounds
     */
    get x() {
        return this.min.x;
    }

    set x(value) {
        var deltaX = this.max.x - this.min.x;
        this.min.x = value;
        this.max.x = value + deltaX;
    }

    /**
     * y position of the bounds
     * @public
     * @type {number}
     * @name y
     * @memberof Bounds
     */
    get y() {
        return this.min.y;
    }

    set y(value) {
        var deltaY = this.max.y - this.min.y;

        this.min.y = value;
        this.max.y = value + deltaY;
    }

    /**
     * width of the bounds
     * @public
     * @type {number}
     * @name width
     * @memberof Bounds
     */
    get width() {
        return this.max.x - this.min.x;
    }

    set width(value) {
        this.max.x = this.min.x + value;
    }

    /**
     * width of the bounds
     * @public
     * @type {number}
     * @name width
     * @memberof Bounds
     */
    get height() {
        return this.max.y - this.min.y;
    }

    set height(value) {
        this.max.y = this.min.y + value;
    }

    /**
     * left coordinate of the bound
     * @public
     * @type {number}
     * @name left
     * @memberof Bounds
     */
    get left() {
        return this.min.x;
    }

    /**
     * right coordinate of the bound
     * @public
     * @type {number}
     * @name right
     * @memberof Bounds
     */
    get right() {
        return this.max.x;
    }

    /**
     * top coordinate of the bound
     * @public
     * @type {number}
     * @name top
     * @memberof Bounds
     */
    get top() {
        return this.min.y;
    }

    /**
     * bottom coordinate of the bound
     * @public
     * @type {number}
     * @name bottom
     * @memberof Bounds
     */
    get bottom() {
        return this.max.y;
    }

    /**
     * center position of the bound on the x axis
     * @public
     * @type {number}
     * @name centerX
     * @memberof Bounds
     */
    get centerX() {
        return this.min.x + (this.width / 2);
    }

    /**
     * center position of the bound on the y axis
     * @public
     * @type {number}
     * @name centerY
     * @memberof Bounds
     */
    get centerY() {
        return this.min.y + (this.height / 2);
    }

    /**
     * return the center position of the bound
     * @public
     * @type {Vector2d}
     * @name center
     * @memberof Bounds
     */
    get center() {
        return this._center.set(this.centerX, this.centerY);
    }

    /**
     * Updates bounds using the given vertices
     * @name update
     * @memberof Bounds
     * @param {Vector2d[]} vertices an array of me.Vector2d points
     */
    update(vertices) {
        this.add(vertices, true);
    }

    /**
     * add the given vertices to the bounds definition.
     * @name add
     * @memberof Bounds
     * @param {Vector2d[]} vertices an array of me.Vector2d points
     * @param {boolean} [clear=false] either to reset the bounds before adding the new vertices
     */
    add(vertices, clear = false) {
        if (clear === true) {
            this.clear();
        }
        for (var i = 0; i < vertices.length; i++) {
            var vertex = vertices[i];
            if (vertex.x > this.max.x) this.max.x = vertex.x;
            if (vertex.x < this.min.x) this.min.x = vertex.x;
            if (vertex.y > this.max.y) this.max.y = vertex.y;
            if (vertex.y < this.min.y) this.min.y = vertex.y;
        }
    }

    /**
     * add the given bounds to the bounds definition.
     * @name addBounds
     * @memberof Bounds
     * @param {Bounds} bounds
     * @param {boolean} [clear=false] either to reset the bounds before adding the new vertices
     */
    addBounds(bounds, clear = false) {
        if (clear === true) {
            this.clear();
        }

        if (bounds.max.x > this.max.x) this.max.x = bounds.max.x;
        if (bounds.min.x < this.min.x) this.min.x = bounds.min.x;
        if (bounds.max.y > this.max.y) this.max.y = bounds.max.y;
        if (bounds.min.y < this.min.y) this.min.y = bounds.min.y;
    }

    /**
     * add the given point to the bounds definition.
     * @name addPoint
     * @memberof Bounds
     * @param {Vector2d} v
     * @param {Matrix2d} [m] an optional transform to apply to the given point
     */
    addPoint(v, m) {
        if (typeof m !== "undefined") {
            v = m.apply(v);
        }
        this.min.x = Math.min(this.min.x, v.x);
        this.max.x = Math.max(this.max.x, v.x);
        this.min.y = Math.min(this.min.y, v.y);
        this.max.y = Math.max(this.max.y, v.y);
    }

    /**
     * add the given quad coordinates to this bound definition, multiplied by the given matrix
     * @name addFrame
     * @memberof Bounds
     * @param {number} x0 - left X coordinates of the quad
     * @param {number} y0 - top Y coordinates of the quad
     * @param {number} x1 - right X coordinates of the quad
     * @param {number} y1 - bottom y coordinates of the quad
     * @param {Matrix2d} [m] an optional transform to apply to the given frame coordinates
     */
    addFrame(x0, y0, x1, y1, m) {
        var v = pool.pull("Vector2d");

        // transform all points and add to the bound definition
        this.addPoint(v.set(x0, y0), m);
        this.addPoint(v.set(x1, y0), m);
        this.addPoint(v.set(x0, y1), m);
        this.addPoint(v.set(x1, y1), m);

        pool.push(v);
    }

    /**
     * Returns true if the bounds contains the given point.
     * @name contains
     * @memberof Bounds
     * @method
     * @param {Vector2d} point
     * @returns {boolean} True if the bounds contain the point, otherwise false
     */
    /**
     * Returns true if the bounds contains the given point.
     * @name contains
     * @memberof Bounds
     * @param {number} x
     * @param {number} y
     * @returns {boolean} True if the bounds contain the point, otherwise false
     */
    contains() {
        var arg0 = arguments[0];
        var _x1, _x2, _y1, _y2;
        if (arguments.length === 2) {
            // x, y
            _x1 = _x2 = arg0;
            _y1 = _y2 = arguments[1];
        } else {
            if (arg0 instanceof Bounds) {
                // bounds
                _x1 = arg0.min.x;
                _x2 = arg0.max.x;
                _y1 = arg0.min.y;
                _y2 = arg0.max.y;
            } else {
                // vector
                _x1 = _x2 = arg0.x;
                _y1 = _y2 = arg0.y;
            }
        }

        return _x1 >= this.min.x && _x2 <= this.max.x
            && _y1 >= this.min.y && _y2 <= this.max.y;
    }

    /**
     * Returns true if the two bounds intersect.
     * @name overlaps
     * @memberof Bounds
     * @param {Bounds|Rect} bounds
     * @returns {boolean} True if the bounds overlap, otherwise false
     */
    overlaps(bounds) {
        return !(this.right < bounds.left || this.left > bounds.right ||
                 this.bottom < bounds.top || this.top > bounds.bottom);
    }

    /**
     * determines whether all coordinates of this bounds are finite numbers.
     * @name isFinite
     * @memberof Bounds
     * @returns {boolean} false if all coordinates are positive or negative Infinity or NaN; otherwise, true.
     */
    isFinite() {
        return (isFinite(this.min.x) && isFinite(this.max.x) && isFinite(this.min.y) && isFinite(this.max.y));
    }

    /**
     * Translates the bounds by the given vector.
     * @name translate
     * @memberof Bounds
     * @method
     * @param {Vector2d} vector
     */
    /**
     * Translates the bounds by x on the x axis, and y on the y axis
     * @name translate
     * @memberof Bounds
     * @param {number} x
     * @param {number} y
     */
    translate() {
        var _x, _y;
        if (arguments.length === 2) {
            // x, y
            _x = arguments[0];
            _y = arguments[1];
        } else {
            // vector
            _x = arguments[0].x;
            _y = arguments[0].y;
        }
        this.min.x += _x;
        this.max.x += _x;
        this.min.y += _y;
        this.max.y += _y;
    }

    /**
     * Shifts the bounds to the given position vector.
     * @name shift
     * @memberof Bounds
     * @method
     * @param {Vector2d} position
     */
    /**
     * Shifts the bounds to the given x, y position.
     * @name shift
     * @memberof Bounds
     * @param {number} x
     * @param {number} y
     */
    shift() {
        var _x, _y;

        if (arguments.length === 2) {
            // x, y
            _x = arguments[0];
            _y = arguments[1];
        } else {
            // vector
            _x = arguments[0].x;
            _y = arguments[0].y;
        }

        var deltaX = this.max.x - this.min.x,
            deltaY = this.max.y - this.min.y;

        this.min.x = _x;
        this.max.x = _x + deltaX;
        this.min.y = _y;
        this.max.y = _y + deltaY;
    }

    /**
     * clone this bounds
     * @name clone
     * @memberof Bounds
     * @returns {Bounds}
     */
    clone() {
        var bounds = new Bounds();
        bounds.addBounds(this);
        return bounds;
    }

    /**
     * Returns a polygon whose edges are the same as this bounds.
     * @name toPolygon
     * @memberof Bounds
     * @returns {Polygon} a new Polygon that represents this bounds.
     */
    toPolygon () {
        return pool.pull("Polygon", this.x, this.y, [
            pool.pull("Vector2d", 0,          0),
            pool.pull("Vector2d", this.width, 0),
            pool.pull("Vector2d", this.width, this.height),
            pool.pull("Vector2d", 0,          this.height)
        ]);
    }

}

/**
 * a temporary vector object
 * @ignore
 */
var tmpVec = new Vector2d();

/**
 * @classdesc
 * a pointer object, representing a single finger on a touch enabled device.
 * @class Pointer
 * @augments Bounds
 */
class Pointer extends Bounds {

    /**
     * @ignore
     */
    constructor(x = 0, y = 0, w = 1, h = 1) {

        // parent constructor
        super();

        // initial coordinates/size
        this.setMinMax(x, y, x + w, y + h);

        /**
         * constant for left button
         * @public
         * @type {number}
         * @name LEFT
         * @memberof Pointer
         */
        this.LEFT = 0;

        /**
         * constant for middle button
         * @public
         * @type {number}
         * @name MIDDLE
         * @memberof Pointer
         */
        this.MIDDLE = 1;

        /**
         * constant for right button
         * @public
         * @type {number}
         * @name RIGHT
         * @memberof Pointer
         */
        this.RIGHT = 2;

        /**
         * the originating Event Object
         * @public
         * @type {PointerEvent|TouchEvent|MouseEvent}
         * @name event
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent
         * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
         * @memberof Pointer
         */
        this.event = undefined;

        /**
         * a string containing the event's type.
         * @public
         * @type {string}
         * @name type
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/type
         * @memberof Pointer
         */
        this.type = undefined;


        /**
         * the button property indicates which button was pressed on the mouse to trigger the event.
         * @public
         * @type {number}
         * @name button
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
         * @memberof Pointer
         */
        this.button = 0;

        /**
         * indicates whether or not the pointer device that created the event is the primary pointer.
         * @public
         * @type {boolean}
         * @name isPrimary
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
         * @memberof Pointer
         */
        this.isPrimary = false;

        /**
         * the horizontal coordinate at which the event occurred, relative to the left edge of the entire document.
         * @public
         * @type {number}
         * @name pageX
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageX
         * @memberof Pointer
         */
        this.pageX = 0;

        /**
         * the vertical coordinate at which the event occurred, relative to the left edge of the entire document.
         * @public
         * @type {number}
         * @name pageY
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageY
         * @memberof Pointer
         */
        this.pageY = 0;

        /**
         * the horizontal coordinate within the application's client area at which the event occurred
         * @public
         * @type {number}
         * @name clientX
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientX
         * @memberof Pointer
         */
        this.clientX = 0;

       /**
        * the vertical coordinate within the application's client area at which the event occurred
        * @public
        * @type {number}
        * @name clientY
        * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientY
        * @memberof Pointer
        */
        this.clientY = 0;

        /**
         * the difference in the X coordinate of the pointer since the previous move event
         * @public
         * @type {number}
         * @name movementX
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX
         * @memberof Pointer
         */
        this.movementX = 0;

       /**
        * the difference in the Y coordinate of the pointer since the previous move event
        * @public
        * @type {number}
        * @name movementY
        * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementY
        * @memberof Pointer
        */
        this.movementY = 0;

        /**
         * an unsigned long representing the unit of the delta values scroll amount
         * @public
         * @type {number}
         * @name deltaMode
         * @see https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode
         * @memberof Pointer
         */
        this.deltaMode = 0;

        /**
         * a double representing the horizontal scroll amount in the Wheel Event deltaMode unit.
         * @public
         * @type {number}
         * @name deltaX
         * @see https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaX
         * @memberof Pointer
         */
        this.deltaX = 0;

        /**
         * a double representing the vertical scroll amount in the Wheel Event deltaMode unit.
         * @public
         * @type {number}
         * @name deltaY
         * @see https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaY
         * @memberof Pointer
         */
        this.deltaY = 0;

        /**
         * a double representing the scroll amount in the z-axis, in the Wheel Event deltaMode unit.
         * @public
         * @type {number}
         * @name deltaZ
         * @see https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaZ
         * @memberof Pointer
         */
        this.deltaZ = 0;

        /**
         * Event normalized X coordinate within the game canvas itself<br>
         * <img src="images/event_coord.png"/>
         * @public
         * @type {number}
         * @name gameX
         * @memberof Pointer
         */
        this.gameX = 0;

        /**
         * Event normalized Y coordinate within the game canvas itself<br>
         * <img src="images/event_coord.png"/>
         * @public
         * @type {number}
         * @name gameY
         * @memberof Pointer
         */
        this.gameY = 0;

        /**
         * Event X coordinate relative to the viewport
         * @public
         * @type {number}
         * @name gameScreenX
         * @memberof Pointer
         */
        this.gameScreenX = 0;

        /**
         * Event Y coordinate relative to the viewport
         * @public
         * @type {number}
         * @name gameScreenY
         * @memberof Pointer
         */
        this.gameScreenY = 0;

        /**
         * Event X coordinate relative to the map
         * @public
         * @type {number}
         * @name gameWorldX
         * @memberof Pointer
         */
        this.gameWorldX = 0;

        /**
         * Event Y coordinate relative to the map
         * @public
         * @type {number}
         * @name gameWorldY
         * @memberof Pointer
         */
        this.gameWorldY = 0;

        /**
         * Event X coordinate relative to the holding container
         * @public
         * @type {number}
         * @name gameLocalX
         * @memberof Pointer
         */
        this.gameLocalX = 0;

        /**
         * Event Y coordinate relative to the holding container
         * @public
         * @type {number}
         * @name gameLocalY
         * @memberof Pointer
         */
        this.gameLocalY = 0;

       /**
        * The unique identifier of the contact for a touch, mouse or pen
        * @public
        * @type {number}
        * @name pointerId
        * @memberof Pointer
        * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
        */
        this.pointerId = undefined;

        /**
         * true if not originally a pointer event
         * @public
         * @type {boolean}
         * @name isNormalized
         * @memberof Pointer
         */
        this.isNormalized = false;

        /**
         * true if the pointer is currently locked
         * @public
         * @type {boolean}
         * @name locked
         * @memberof Pointer
         */
        this.locked = false;

        // bind list for mouse buttons
        this.bind = [ 0, 0, 0 ];
    }

    /**
     * initialize the Pointer object using the given Event Object
     * @name Pointer#set
     * @private
     * @param {Event} event the original Event object
     * @param {number} [pageX=0] the horizontal coordinate at which the event occurred, relative to the left edge of the entire document
     * @param {number} [pageY=0] the vertical coordinate at which the event occurred, relative to the left edge of the entire document
     * @param {number} [clientX=0] the horizontal coordinate within the application's client area at which the event occurred
     * @param {number} [clientY=0] the vertical coordinate within the application's client area at which the event occurred
     * @param {number} [pointerId=1] the Pointer, Touch or Mouse event Id (1)
     */
    setEvent(event, pageX = 0, pageY = 0, clientX = 0, clientY = 0, pointerId = 1) {
        // the original event object
        this.event = event;

        this.pageX = pageX;
        this.pageY = pageY;
        this.clientX = clientX;
        this.clientY = clientY;

        // translate to local coordinates
        globalToLocal(this.pageX, this.pageY, tmpVec);
        this.gameScreenX = this.x = tmpVec.x;
        this.gameScreenY = this.y = tmpVec.y;

        // true if not originally a pointer event
        this.isNormalized = !device.PointerEvent || (device.PointerEvent && !(event instanceof globalThis.PointerEvent));

        this.locked = locked;
        this.movementX = event.movementX || 0;
        this.movementY = event.movementY || 0;

        if (event.type === "wheel") {
            this.deltaMode = event.deltaMode || 0;
            this.deltaX = event.deltaX || 0;
            this.deltaY = event.deltaY || 0;
            this.deltaZ = event.deltaZ || 0;
        } else {
            this.deltaMode = 0;
            this.deltaX = 0;
            this.deltaY = 0;
            this.deltaZ = 0;
        }

        this.pointerId = pointerId;

        this.isPrimary = (typeof event.isPrimary !== "undefined") ? event.isPrimary : true;

        // in case of touch events, button is not defined
        this.button = event.button || 0;

        this.type = event.type;

        // get the current screen to game world offset
        if (typeof viewport !== "undefined") {
            viewport.localToWorld(this.gameScreenX, this.gameScreenY, tmpVec);
        }

        /* Initialize the two coordinate space properties. */
        this.gameWorldX = tmpVec.x;
        this.gameWorldY = tmpVec.y;

        // get the pointer size
        if (this.isNormalized === false) {
            // native PointerEvent
            this.width = event.width || 1;
            this.height = event.height || 1;
        } else if (typeof(event.radiusX) === "number") {
            // TouchEvent
            this.width = (event.radiusX * 2) || 1;
            this.height = (event.radiusY * 2) || 1;
        } else {
            this.width = this.height = 1;
        }
    }
}

/**
 * A pool of `Pointer` objects to cache pointer/touch event coordinates.
 * @type {Array.<Vector2d>}
 * @ignore
 */
var T_POINTERS = [];

// list of registered Event handlers
var eventHandlers = new Map();

// a cache rect represeting the current pointer area
var currentPointer;

// some useful flags
var pointerInitialized = false;

// Track last event timestamp to prevent firing events out of order
var lastTimeStamp = 0;

// "active" list of supported events
var activeEventList = [];

// internal constants
const WHEEL           = ["wheel"];
const POINTER_MOVE    = ["pointermove",   "mousemove",    "touchmove"];
const POINTER_DOWN    = ["pointerdown",   "mousedown",    "touchstart"];
const POINTER_UP      = ["pointerup",     "mouseup",      "touchend"];
const POINTER_CANCEL  = ["pointercancel", "mousecancel",  "touchcancel"];
const POINTER_ENTER   = ["pointerenter",  "mouseenter",   "touchenter"];
const POINTER_OVER    = ["pointerover",   "mouseover",    "touchover"];
const POINTER_LEAVE   = ["pointerleave",  "mouseleave",   "touchleave"];

// list of standard pointer event type
const pointerEventList = [
    WHEEL[0],
    POINTER_MOVE[0],
    POINTER_DOWN[0],
    POINTER_UP[0],
    POINTER_CANCEL[0],
    POINTER_ENTER[0],
    POINTER_OVER[0],
    POINTER_LEAVE[0]
];

// legacy mouse event type
const mouseEventList = [
    WHEEL[0],
    POINTER_MOVE[1],
    POINTER_DOWN[1],
    POINTER_UP[1],
    POINTER_CANCEL[1],
    POINTER_ENTER[1],
    POINTER_OVER[1],
    POINTER_LEAVE[1]
];

// iOS style touch event type
const touchEventList = [
    POINTER_MOVE[2],
    POINTER_DOWN[2],
    POINTER_UP[2],
    POINTER_CANCEL[2],
    POINTER_ENTER[2],
    POINTER_OVER[2],
    POINTER_LEAVE[2]
];

const pointerEventMap = {
    wheel : WHEEL,
    pointermove: POINTER_MOVE,
    pointerdown: POINTER_DOWN,
    pointerup: POINTER_UP,
    pointercancel: POINTER_CANCEL,
    pointerenter: POINTER_ENTER,
    pointerover: POINTER_OVER,
    pointerleave: POINTER_LEAVE
};

/**
 * Array of normalized events (mouse, touch, pointer)
 * @ignore
 */
var normalizedEvents = [];

/**
 * addEventListerner for the specified event list and callback
 * @ignore
 */
function registerEventListener(eventList, callback) {
    for (var x = 0; x < eventList.length; x++) {
        if (POINTER_MOVE.indexOf(eventList[x]) === -1) {
            pointerEventTarget.addEventListener(eventList[x], callback, { passive: (preventDefault === false) });
        }
    }
}

/**
 * enable pointer event (Pointer/Mouse/Touch)
 * @ignore
 */
function enablePointerEvent() {
    if (!pointerInitialized) {

        // the current pointer area
        currentPointer = new Rect(0, 0, 1, 1);

        // instantiate a pool of pointer catched
        for (var v = 0; v < device.maxTouchPoints; v++) {
            T_POINTERS.push(new Pointer());
        }

        if (pointerEventTarget === null) {
            // default pointer event target
            pointerEventTarget = renderer.getScreenCanvas();
        }

        if (device.PointerEvent) {
            // standard Pointer Events
            activeEventList = pointerEventList;
        } else {
            // Regular Mouse events
            activeEventList = mouseEventList;
        }
        if (device.touch && !device.PointerEvent) {
            // touch event on mobile devices
            activeEventList = activeEventList.concat(touchEventList);
        }
        registerEventListener(activeEventList, onPointerEvent);

        // set the PointerMove/touchMove/MouseMove event
        if (typeof(throttlingInterval) === "undefined") {
            // set the default value
            throttlingInterval = ~~(1000 / timer.maxfps);
        }

        if (device.autoFocus === true) {
            device.focus();
            pointerEventTarget.addEventListener(
                activeEventList[2], // MOUSE/POINTER DOWN
                function () {
                    device.focus();
                },
                { passive: (preventDefault === false) }
            );
        }

        // if time interval <= 16, disable the feature
        var i;
        var events = findAllActiveEvents(activeEventList, POINTER_MOVE);
        if (throttlingInterval < 17) {
            for (i = 0; i < events.length; i++) {
                if (activeEventList.indexOf(events[i]) !== -1) {
                    pointerEventTarget.addEventListener(
                        events[i],
                        onMoveEvent,
                        { passive: true } // do not preventDefault on Move events
                    );
                }

            }
        }
        else {
            for (i = 0; i < events.length; i++) {
                if (activeEventList.indexOf(events[i]) !== -1) {
                    pointerEventTarget.addEventListener(
                        events[i],
                        throttle(
                            onMoveEvent,
                            throttlingInterval,
                            false
                        ),
                        { passive: true } // do not preventDefault on Move events
                    );
                }
            }
        }
        // disable all gesture by default
        setTouchAction(pointerEventTarget);

        // set a on change listener on pointerlock if supported
        if (device.hasPointerLockSupport) {
            document.addEventListener("pointerlockchange", () => {
                // change the locked status accordingly
                locked = document.pointerLockElement === getParent();
                // emit the corresponding internal event
                emit(POINTERLOCKCHANGE, locked);
            }, true);
        }

        // all done !
        pointerInitialized = true;
    }
}

/**
 * @ignore
 */
function findActiveEvent(activeEventList, eventTypes) {
    for (var i = 0; i < eventTypes.length; i++) {
        var event = activeEventList.indexOf(eventTypes[i]);
        if (event !== -1) {
            return eventTypes[i];
        }
    }
}

/**
 * @ignore
 */
function findAllActiveEvents(activeEventList, eventTypes) {
    var events = [];
    for (var i = 0; i < eventTypes.length; i++) {
        var event = activeEventList.indexOf(eventTypes[i]);
        if (event !== -1) {
            events.push(eventTypes[i]);
        }
    }

    return events;
}

/**
 * @ignore
 */
function triggerEvent(handlers, type, pointer, pointerId) {
    var callback;
    if (handlers.callbacks[type]) {
        handlers.pointerId = pointerId;
        for (var i = handlers.callbacks[type].length - 1; (i >= 0) && (callback = handlers.callbacks[type][i]); i--) {
            if (callback(pointer) === false) {
                // stop propagating the event if return false
                return true;
            }
        }
    }
    return false;
}

/**
 * propagate events to registered objects
 * @ignore
 */
function dispatchEvent(normalizedEvents) {
    var handled = false;

    while (normalizedEvents.length > 0) {

        // keep a reference to the last item
        var pointer = normalizedEvents.pop();
        // and put it back into our cache
        T_POINTERS.push(pointer);

        // Do not fire older touch events (not required for PointerEvent type)
        if (pointer.isNormalized === true && typeof(pointer.event.timeStamp) !== "undefined") {
            if (pointer.event.timeStamp < lastTimeStamp) {
                continue;
            }
            lastTimeStamp = pointer.event.timeStamp;
        }

        currentPointer.setShape(
            pointer.gameWorldX,
            pointer.gameWorldY,
            pointer.width,
            pointer.height
        );

        // trigger a global event for pointer move
        if (POINTER_MOVE.includes(pointer.type)) {
            pointer.gameX = pointer.gameLocalX = pointer.gameScreenX;
            pointer.gameY = pointer.gameLocalY = pointer.gameScreenY;
            emit(POINTERMOVE, pointer);
        }

        // fetch valid candiates from the game world container
        var candidates = world.broadphase.retrieve(currentPointer, Container.prototype._sortReverseZ);

        // add the main game viewport to the list of candidates
        candidates = candidates.concat([ viewport ]);

        for (var c = candidates.length, candidate; c--, (candidate = candidates[c]);) {
            if (eventHandlers.has(candidate) && (candidate.isKinematic !== true)) {
                var handlers = eventHandlers.get(candidate);
                var region = handlers.region;
                var ancestor = region.ancestor;
                var bounds = region.getBounds();
                var eventInBounds = false;

                if (region.isFloating === true) {
                    pointer.gameX = pointer.gameLocalX = pointer.gameScreenX;
                    pointer.gameY = pointer.gameLocalY = pointer.gameScreenY;
                } else {
                    pointer.gameX = pointer.gameLocalX = pointer.gameWorldX;
                    pointer.gameY = pointer.gameLocalY = pointer.gameWorldY;
                }

                // adjust gameLocalX to specify coordinates
                // within the region ancestor container
                if (typeof ancestor !== "undefined") {
                    var parentBounds = ancestor.getBounds();
                    pointer.gameLocalX = pointer.gameX - parentBounds.x;
                    pointer.gameLocalY = pointer.gameY - parentBounds.y;
                }

                var gameX = pointer.gameX;
                var gameY = pointer.gameY;

                // apply inverse transformation for renderable
                if (typeof region.currentTransform !== "undefined") {
                    if (!region.currentTransform.isIdentity()) {
                        var invV = region.currentTransform.applyInverse(
                            pool.pull("Vector2d", gameX, gameY)
                        );
                        gameX = invV.x;
                        gameY = invV.y;
                        pool.push(invV);
                    }
                }
                eventInBounds = bounds.contains(gameX, gameY);

                switch (pointer.type) {
                    case POINTER_MOVE[0]:
                    case POINTER_MOVE[1]:
                    case POINTER_MOVE[2]:
                    case POINTER_MOVE[3]:
                        // moved out of bounds: trigger the POINTER_LEAVE callbacks
                        if (handlers.pointerId === pointer.pointerId && !eventInBounds) {
                            if (triggerEvent(handlers, findActiveEvent(activeEventList, POINTER_LEAVE), pointer, null)) {
                                handled = true;
                                break;
                            }
                        }
                        // no pointer & moved inside of bounds: trigger the POINTER_ENTER callbacks
                        else if (handlers.pointerId === null && eventInBounds) {
                            if (triggerEvent(handlers, findActiveEvent(activeEventList, POINTER_ENTER), pointer, pointer.pointerId)) {
                                handled = true;
                                break;
                            }
                        }

                        // trigger the POINTER_MOVE callbacks
                        if (eventInBounds && triggerEvent(handlers, pointer.type, pointer, pointer.pointerId)) {
                            handled = true;
                            break;
                        }
                        break;

                    case POINTER_UP[0]:
                    case POINTER_UP[1]:
                    case POINTER_UP[2]:
                    case POINTER_UP[3]:
                        // pointer defined & inside of bounds: trigger the POINTER_UP callback
                        if (handlers.pointerId === pointer.pointerId && eventInBounds) {
                            // trigger the corresponding callback
                            if (triggerEvent(handlers, pointer.type, pointer, null)) {
                                handled = true;
                                break;
                            }
                        }
                        break;

                    case POINTER_CANCEL[0]:
                    case POINTER_CANCEL[1]:
                    case POINTER_CANCEL[2]:
                    case POINTER_CANCEL[3]:
                        // pointer defined: trigger the POINTER_CANCEL callback
                        if (handlers.pointerId === pointer.pointerId) {
                            // trigger the corresponding callback
                            if (triggerEvent(handlers, pointer.type, pointer, null)) {
                                handled = true;
                                break;
                            }
                        }
                        break;

                    default:
                        // event inside of bounds: trigger the POINTER_DOWN or WHEEL callback
                        if (eventInBounds) {
                            // trigger the corresponding callback
                            if (triggerEvent(handlers, pointer.type, pointer, pointer.pointerId)) {
                                handled = true;
                                break;
                            }
                        }
                        break;
                }
            }
            if (handled === true) {
                // stop iterating through this list of candidates
                break;
            }
        }
    }
    return handled;
}

/**
 * translate event coordinates
 * @ignore
 */
function normalizeEvent(originalEvent) {
    var _pointer;

    // PointerEvent or standard Mouse event
    if (device.TouchEvent && originalEvent.changedTouches) {
        // iOS/Android Touch event
        for (var i = 0, l = originalEvent.changedTouches.length; i < l; i++) {
            var touchEvent = originalEvent.changedTouches[i];
            _pointer = T_POINTERS.pop();
            _pointer.setEvent(
                originalEvent,
                touchEvent.pageX,
                touchEvent.pageY,
                touchEvent.clientX,
                touchEvent.clientY,
                touchEvent.identifier
            );
            normalizedEvents.push(_pointer);
        }
    } else {
        // Mouse or PointerEvent
        _pointer = T_POINTERS.pop();
        _pointer.setEvent(
            originalEvent,
            originalEvent.pageX,
            originalEvent.pageY,
            originalEvent.clientX,
            originalEvent.clientY,
            originalEvent.pointerId
        );
        normalizedEvents.push(_pointer);
    }

    // if event.isPrimary is defined and false, return
    if (originalEvent.isPrimary === false) {
        return normalizedEvents;
    }

    // else use the first entry to simulate mouse event
    normalizedEvents[0].isPrimary = true;
    Object.assign(pointer, normalizedEvents[0]);

    return normalizedEvents;
}

/**
 * mouse/touch/pointer event management (move)
 * @ignore
 */
function onMoveEvent(e) {
    // dispatch mouse event to registered object
    dispatchEvent(normalizeEvent(e));
    // do not prevent default on moveEvent :
}

/**
 * mouse/touch/pointer event management (start/down, end/up)
 * @ignore
 */
function onPointerEvent(e) {
    // normalize eventTypes
    normalizeEvent(e);

    // remember/use the first "primary" normalized event for pointer.bind
    var button = normalizedEvents[0].button;

    // dispatch event to registered objects
    if (dispatchEvent(normalizedEvents) || e.type === "wheel") {
        // always preventDefault for wheel event (?legacy code/behavior?)
        {
            e.preventDefault();
        }
    }

    var keycode = pointer.bind[button];

    // check if mapped to a key
    if (keycode) {
        triggerKeyEvent(keycode, POINTER_DOWN.includes(e.type), button + 1);
    }
}

/*
 * PUBLIC STUFF
 */

 /**
  * the default target element for pointer events (usually the canvas element in which the game is rendered)
  * @public
  * @type {EventTarget}
  * @name pointerEventTarget
  * @memberof input
  */
 var pointerEventTarget = null;

/**
 * Pointer information (current position and size)
 * @public
 * @type {Rect}
 * @name pointer
 * @memberof input
 */
var pointer = new Pointer(0, 0, 1, 1);


/**
 * indicates if the pointer is currently locked
 * @public
 * @type {boolean}
 * @name locked
 * @memberof input
 */
var locked = false;

/**
 * time interval for event throttling in milliseconds<br>
 * default value : "1000/me.timer.maxfps" ms<br>
 * set to 0 ms to disable the feature
 * @public
 * @type {number}
 * @name throttlingInterval
 * @memberof input
 */
var throttlingInterval;

/**
 * Translate the specified x and y values from the global (absolute)
 * coordinate to local (viewport) relative coordinate.
 * @name globalToLocal
 * @memberof input
 * @public
 * @param {number} x the global x coordinate to be translated.
 * @param {number} y the global y coordinate to be translated.
 * @param {Vector2d} [v] an optional vector object where to set the translated coordinates
 * @returns {Vector2d} A vector object with the corresponding translated coordinates
 * @example
 * onMouseEvent : function (pointer) {
 *    // convert the given into local (viewport) relative coordinates
 *    var pos = me.input.globalToLocal(pointer.clientX, pointer.clientY);
 *    // do something with pos !
 * };
 */
function globalToLocal(x, y, v) {
    v = v || pool.pull("Vector2d");
    var rect = device.getElementBounds(renderer.getScreenCanvas());
    var pixelRatio = device.devicePixelRatio;
    x -= rect.left + (globalThis.pageXOffset || 0);
    y -= rect.top + (globalThis.pageYOffset || 0);
    var scale = scaleRatio;
    if (scale.x !== 1.0 || scale.y !== 1.0) {
        x /= scale.x;
        y /= scale.y;
    }
    return v.set(x * pixelRatio, y * pixelRatio);
}
/**
 * enable/disable all gestures on the given element.<br>
 * by default melonJS will disable browser handling of all panning and zooming gestures.
 * @name setTouchAction
 * @memberof input
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action
 * @public
 * @param {HTMLCanvasElement} element
 * @param {string} [value="none"]
 */
function setTouchAction(element, value) {
    element.style["touch-action"] = value || "none";
}
/**
 * Associate a pointer event to a keycode<br>
 * Left button â 0
 * Middle button â 1
 * Right button â 2
 * @name bindPointer
 * @memberof input
 * @public
 * @param {number} [button=input.pointer.LEFT] (accordingly to W3C values : 0,1,2 for left, middle and right buttons)
 * @param {input.KEY} keyCode
 * @example
 * // enable the keyboard
 * me.input.bindKey(me.input.KEY.X, "shoot");
 * // map the left button click on the X key (default if the button is not specified)
 * me.input.bindPointer(me.input.KEY.X);
 * // map the right button click on the X key
 * me.input.bindPointer(me.input.pointer.RIGHT, me.input.KEY.X);
 */
function bindPointer() {
    var button = (arguments.length < 2) ? pointer.LEFT : arguments[0];
    var keyCode = (arguments.length < 2) ? arguments[0] : arguments[1];

    // make sure the mouse is initialized
    enablePointerEvent();

    // throw an exception if no action is defined for the specified keycode
    if (!getBindingKey(keyCode)) {
        throw new Error("no action defined for keycode " + keyCode);
    }
    // map the mouse button to the keycode
    pointer.bind[button] = keyCode;
}
/**
 * unbind the defined keycode
 * @name unbindPointer
 * @memberof input
 * @public
 * @param {number} [button=input.pointer.LEFT] (accordingly to W3C values : 0,1,2 for left, middle and right buttons)
 * @example
 * me.input.unbindPointer(me.input.pointer.LEFT);
 */
function unbindPointer(button) {
    // clear the event status
    pointer.bind[
        typeof(button) === "undefined" ?
        pointer.LEFT : button
    ] = null;
}

/**
 * allows registration of event listeners on the object target. <br>
 * melonJS will pass a me.Pointer object to the defined callback.
 * @see Pointer
 * @see {@link http://www.w3.org/TR/pointerevents/#list-of-pointer-events|W3C Pointer Event list}
 * @name registerPointerEvent
 * @memberof input
 * @public
 * @param {string} eventType The event type for which the object is registering <br>
 * melonJS currently supports: <br>
 * <ul>
 *   <li><code>"pointermove"</code></li>
 *   <li><code>"pointerdown"</code></li>
 *   <li><code>"pointerup"</code></li>
 *   <li><code>"pointerenter"</code></li>
 *   <li><code>"pointerover"</code></li>
 *   <li><code>"pointerleave"</code></li>
 *   <li><code>"pointercancel"</code></li>
 *   <li><code>"wheel"</code></li>
 * </ul>
 * @param {Rect|Polygon|Line|Ellipse} region a shape representing the region to register on
 * @param {Function} callback methods to be called when the event occurs.
 * Returning `false` from the defined callback will prevent the event to be propagated to other objects
 * @example
 *  // onActivate function
 *  onActivateEvent: function () {
 *     // register on the 'pointerdown' event
 *     me.input.registerPointerEvent('pointerdown', this, this.pointerDown.bind(this));
 *  },
 *
 *  // pointerDown event callback
 *  pointerDown: function (pointer) {
 *    // do something
 *    ....
 *    // don"t propagate the event to other objects
 *    return false;
 *  },
 */
function registerPointerEvent(eventType, region, callback) {
    // make sure the mouse/touch events are initialized
    enablePointerEvent();

    if (pointerEventList.indexOf(eventType) === -1) {
        throw new Error("invalid event type : " + eventType);
    }

    if (typeof region === "undefined") {
        throw new Error("registerPointerEvent: region for " + toString(region) + " event is undefined ");
    }

    var eventTypes = findAllActiveEvents(activeEventList, pointerEventMap[eventType]);

    // register the event
    if (!eventHandlers.has(region)) {
        eventHandlers.set(region, {
            region : region,
            callbacks : {},
            pointerId : null
        });
    }

    // allocate array if not defined
    var handlers = eventHandlers.get(region);
    for (var i = 0; i < eventTypes.length; i++) {
        eventType = eventTypes[i];
        if (handlers.callbacks[eventType]) {
            handlers.callbacks[eventType].push(callback);
        } else {
            handlers.callbacks[eventType] = [callback];
        }
    }
}
/**
 * allows the removal of event listeners from the object target.
 * @see {@link http://www.w3.org/TR/pointerevents/#list-of-pointer-events|W3C Pointer Event list}
 * @name releasePointerEvent
 * @memberof input
 * @public
 * @param {string} eventType The event type for which the object was registered. See {@link input.registerPointerEvent}
 * @param {Rect|Polygon|Line|Ellipse} region the registered region to release for this event
 * @param {Function} [callback="all"] if specified unregister the event only for the specific callback
 * @example
 * // release the registered region on the 'pointerdown' event
 * me.input.releasePointerEvent('pointerdown', this);
 */
function releasePointerEvent(eventType, region, callback) {
    if (pointerEventList.indexOf(eventType) === -1) {
        throw new Error("invalid event type : " + eventType);
    }

    // convert to supported event type if pointerEvent not natively supported
    var eventTypes = findAllActiveEvents(activeEventList, pointerEventMap[eventType]);

    var handlers = eventHandlers.get(region);
    if (typeof (handlers) !== "undefined") {
        for (var i = 0; i < eventTypes.length; i++) {
            eventType = eventTypes[i];
            if (handlers.callbacks[eventType]) {
                if (typeof (callback) !== "undefined") {
                    remove(handlers.callbacks[eventType], callback);
                } else {
                    while (handlers.callbacks[eventType].length > 0) {
                        handlers.callbacks[eventType].pop();
                    }
                }
                // free the array if empty
                if (handlers.callbacks[eventType].length === 0) {
                    delete handlers.callbacks[eventType];
                }
            }
        }
        if (Object.keys(handlers.callbacks).length === 0) {
            eventHandlers.delete(region);
        }
    }
}
/**
 * allows the removal of all registered event listeners from the object target.
 * @name releaseAllPointerEvents
 * @memberof input
 * @public
 * @param {Rect|Polygon|Line|Ellipse} region the registered region to release event from
 * @example
 * // release all registered event on the
 * me.input.releaseAllPointerEvents(this);
 */
function releaseAllPointerEvents(region) {
    if (eventHandlers.has(region)) {
        for (var i = 0; i < pointerEventList.length; i++) {
            releasePointerEvent(pointerEventList[i], region);
        }
    }}
/**
 * request for the pointer to be locked on the parent DOM element.
 * (Must be called in a click event or an event that requires user interaction)
 * @name requestPointerLock
 * @memberof input
 * @public
 * @returns {boolean} return true if the request was successfully submitted
 * @example
 * // register on the pointer lock change event
 * event.on(event.POINTERLOCKCHANGE, (locked)=> {
 *     console.log("pointer lock: " + locked);
 * });
 * // request for pointer lock
 * me.input.requestPointerLock();
 */
function requestPointerLock() {
    if (device.hasPointerLockSupport) {
        var element = getParent();
        element.requestPointerLock();
        return true;
    }
    return false;
}

/**
 * Initiates an exit from pointer lock state
 * @name exitPointerLock
 * @memberof input
 * @public
 * @returns {boolean} return true if the request was successfully submitted
 */
function exitPointerLock() {
    if (device.hasPointerLockSupport) {
        document.exitPointerLock();
        return true;
    }
    return false;
}

// Analog deadzone
var deadzone = 0.1;

/**
 * Normalize axis values for wired Xbox 360
 * @ignore
 */
function wiredXbox360NormalizeFn(value, axis, button) {
    if (button === this.GAMEPAD.BUTTONS.L2 || button === this.GAMEPAD.BUTTONS.R2) {
        return (value + 1) / 2;
    }
    return value;
}

/**
 * Normalize axis values for OUYA
 * @ignore
 */
function ouyaNormalizeFn(value, axis, button) {
    if (value > 0) {
        if (button === this.GAMEPAD.BUTTONS.L2) {
            // L2 is wonky; seems like the deadzone is around 20000
            // (That's over 15% of the total range!)
            value = Math.max(0, value - 20000) / 111070;
        }
        else {
            // Normalize [1..65536] => [0.0..0.5]
            value = (value - 1) / 131070;
        }
    }
    else {
        // Normalize [-65536..-1] => [0.5..1.0]
        value = (65536 + value) / 131070 + 0.5;
    }

    return value;
}

// Match vendor and product codes for Firefox
var vendorProductRE = /^([0-9a-f]{1,4})-([0-9a-f]{1,4})-/i;

// Match leading zeros
var leadingZeroRE = /^0+/;

/**
 * Firefox reports different ids for gamepads depending on the platform:
 * - Windows: vendor and product codes contain leading zeroes
 * - Mac: vendor and product codes are sparse (no leading zeroes)
 *
 * This function normalizes the id to support both formats
 * @ignore
 */
function addMapping(id, mapping) {
    var expanded_id = id.replace(vendorProductRE, function (_, a, b) {
        return (
            "000".slice(a.length - 1) + a + "-" +
            "000".slice(b.length - 1) + b + "-"
        );
    });
    var sparse_id = id.replace(vendorProductRE, function (_, a, b) {
        return (
            a.replace(leadingZeroRE, "") + "-" +
            b.replace(leadingZeroRE, "") + "-"
        );
    });

    // Normalize optional parameters
    mapping.analog = mapping.analog || mapping.buttons.map(function () {
        return -1;
    });
    mapping.normalize_fn = mapping.normalize_fn || function (value) { return value; };

    remap.set(expanded_id, mapping);
    remap.set(sparse_id, mapping);
}

// binding list
var bindings = {};

// mapping list
var remap = new Map();

var updateEventHandler;

// Default gamepad mappings
[
    // Firefox mappings
    [
        "45e-28e-Xbox 360 Wired Controller",
        {
            "axes" : [ 0, 1, 3, 4 ],
            "buttons" : [ 11, 12, 13, 14, 8, 9, -1, -1, 5, 4, 6, 7, 0, 1, 2, 3, 10 ],
            "analog" : [ -1, -1, -1, -1, -1, -1, 2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1 ],
            "normalize_fn" : wiredXbox360NormalizeFn
        }
    ],
    [
        "54c-268-PLAYSTATION(R)3 Controller",
        {
            "axes" : [ 0, 1, 2, 3 ],
            "buttons" : [ 14, 13, 15, 12, 10, 11, 8, 9, 0, 3, 1, 2, 4, 6, 7, 5, 16 ]
        }
    ],
    [
        "54c-5c4-Wireless Controller", // PS4 Controller
        {
            "axes" : [ 0, 1, 2, 3 ],
            "buttons" : [ 1, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15, 16, 17, 12, 13 ]
        }
    ],
    [
        "2836-1-OUYA Game Controller",
        {
            "axes" : [ 0, 3, 7, 9 ],
            "buttons" : [ 3, 6, 4, 5, 7, 8, 15, 16, -1, -1, 9, 10, 11, 12, 13, 14, -1 ],
            "analog" : [ -1, -1, -1, -1, -1, -1, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1 ],
            "normalize_fn" : ouyaNormalizeFn
        }
    ],

    // Chrome mappings
    [
        "OUYA Game Controller (Vendor: 2836 Product: 0001)",
        {
            "axes" : [ 0, 1, 3, 4 ],
            "buttons" : [ 0, 3, 1, 2, 4, 5, 12, 13, -1, -1, 6, 7, 8, 9, 10, 11, -1 ],
            "analog" : [ -1, -1, -1, -1, -1, -1, 2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1 ],
            "normalize_fn" : ouyaNormalizeFn
        }
    ]
].forEach(function (value) {
    addMapping(value[0], value[1]);
});

/**
 * Update gamepad status
 * @ignore
 */
var updateGamepads = function () {
    var gamepads = navigator.getGamepads();

    // Trigger button bindings
    Object.keys(bindings).forEach(function (index) {
        var gamepad = gamepads[index];
        if (!gamepad) {
            return;
        }

        var mapping = null;
        if (gamepad.mapping !== "standard") {
            mapping = remap.get(gamepad.id);
        }

        var binding = bindings[index];

        // Iterate all buttons that have active bindings
        Object.keys(binding.buttons).forEach(function (button) {
            var last = binding.buttons[button];
            var mapped_button = button;
            var mapped_axis = -1;

            // Remap buttons if necessary
            if (mapping) {
                mapped_button = mapping.buttons[button];
                mapped_axis = mapping.analog[button];
                if (mapped_button < 0 && mapped_axis < 0) {
                    // Button is not mapped
                    return;
                }
            }

            // Get mapped button
            var current = gamepad.buttons[mapped_button] || {};

            // Remap an axis to an analog button
            if (mapping) {
                if (mapped_axis >= 0) {
                    var value = mapping.normalize_fn(gamepad.axes[mapped_axis], -1, +button);

                    // Create a new object, because GamepadButton is read-only
                    current = {
                        "value" : value,
                        "pressed" : current.pressed || (Math.abs(value) >= deadzone)
                    };
                }
            }

            emit(GAMEPAD_UPDATE, index, "buttons", +button, current);

            // Edge detection
            if (!last.pressed && current.pressed) {
                triggerKeyEvent(last.keyCode, true, mapped_button + 256);
            }
            else if (last.pressed && !current.pressed) {
                triggerKeyEvent(last.keyCode, false, mapped_button + 256);
            }

            // Update last button state
            last.value = current.value;
            last.pressed = current.pressed;
        });

        // Iterate all axes that have active bindings
        Object.keys(binding.axes).forEach(function (axis) {
            var last = binding.axes[axis];
            var mapped_axis = axis;

            // Remap buttons if necessary
            if (mapping) {
                mapped_axis = mapping.axes[axis];
                if (mapped_axis < 0) {
                    // axe is not mapped
                    return;
                }
            }

            // retrieve the current value and normalize if necessary
            var value = gamepad.axes[mapped_axis];
            if (typeof(value) === "undefined") {
                return;
            }
            if (mapping) {
                value = mapping.normalize_fn(value, +axis, -1);
            }
            // normalize value into a [-1, 1] range value (treat 0 as positive)
            var range = Math.sign(value) || 1;
            if (last[range].keyCode === 0) {
                return;
            }
            var pressed = (Math.abs(value) >= (deadzone + Math.abs(last[range].threshold)));

            emit(GAMEPAD_UPDATE, index, "axes", +axis, value);

            // Edge detection
            if (!last[range].pressed && pressed) {
                // Release the opposite direction, if necessary
                if (last[-range].pressed) {
                    triggerKeyEvent(last[-range].keyCode, false, mapped_axis + 256);
                    last[-range].value = 0;
                    last[-range].pressed = false;
                }

                triggerKeyEvent(last[range].keyCode, true, mapped_axis + 256);
            }
            else if ((last[range].pressed || last[-range].pressed) && !pressed) {
                range = last[range].pressed ? range : -range;
                triggerKeyEvent(last[range].keyCode, false, mapped_axis + 256);
            }

            // Update last axis state
            last[range].value = value;
            last[range].pressed = pressed;
        });
    });
};

// gamepad connected callback
if (globalThis.navigator && typeof globalThis.navigator.getGamepads === "function") {
    globalThis.addEventListener("gamepadconnected", function (e) {
        emit(GAMEPAD_CONNECTED, e.gamepad);
    }, false);

    /*
     * gamepad disconnected callback
     */
    globalThis.addEventListener("gamepaddisconnected", function (e) {
        emit(GAMEPAD_DISCONNECTED, e.gamepad);
    }, false);
}

/*
 * PUBLIC STUFF
 */

/**
 * Namespace for standard gamepad mapping constants
 * @public
 * @namespace GAMEPAD
 * @memberof input
 */
var GAMEPAD = {
    /**
     * Standard gamepad mapping information for axes<br>
     * <ul>
     *   <li>Left control stick: <code>LX</code> (horizontal), <code>LY</code> (vertical)</li>
     *   <li>Right control stick: <code>RX</code> (horizontal), <code>RY</code> (vertical)</li>
     *   <li>Extras: <code>EXTRA_1</code>, <code>EXTRA_2</code>, <code>EXTRA_3</code>, <code>EXTRA_4</code></li>
     * </ul>
     * @public
     * @name AXES
     * @enum {number}
     * @memberof input.GAMEPAD
     * @see https://w3c.github.io/gamepad/#remapping
     */
    "AXES" : {
        "LX"        : 0,
        "LY"        : 1,
        "RX"        : 2,
        "RY"        : 3,
        "EXTRA_1"   : 4,
        "EXTRA_2"   : 5,
        "EXTRA_3"   : 6,
        "EXTRA_4"   : 7
    },

    /**
     * Standard gamepad mapping information for buttons<br>
     * <ul>
     *   <li>Face buttons: <code>FACE_1</code>, <code>FACE_2</code>, <code>FACE_3</code>, <code>FACE_4</code></li>
     *   <li>D-Pad: <code>UP</code>, <code>DOWN</code>, <code>LEFT</code>, <code>RIGHT</code></li>
     *   <li>Shoulder buttons: <code>L1</code>, <code>L2</code>, <code>R1</code>, <code>R2</code></li>
     *   <li>Analog stick (clicks): <code>L3</code>, <code>R3</code></li>
     *   <li>Navigation: <code>SELECT</code> (<code>BACK</code>), <code>START</code> (<code>FORWARD</code>), <code>HOME</code></li>
     *   <li>Extras: <code>EXTRA_1</code>, <code>EXTRA_2</code>, <code>EXTRA_3</code>, <code>EXTRA_4</code></li>
     * </ul>
     * @public
     * @name BUTTONS
     * @enum {number}
     * @memberof input.GAMEPAD
     * @see https://w3c.github.io/gamepad/#remapping
     */
    "BUTTONS" : {
        "FACE_1"    : 0,
        "FACE_2"    : 1,
        "FACE_3"    : 2,
        "FACE_4"    : 3,
        "L1"        : 4,
        "R1"        : 5,
        "L2"        : 6,
        "R2"        : 7,
        "SELECT"    : 8,
        "BACK"      : 8,
        "START"     : 9,
        "FORWARD"   : 9,
        "L3"        : 10,
        "R3"        : 11,
        "UP"        : 12,
        "DOWN"      : 13,
        "LEFT"      : 14,
        "RIGHT"     : 15,
        "HOME"      : 16,
        "EXTRA_1"   : 17,
        "EXTRA_2"   : 18,
        "EXTRA_3"   : 19,
        "EXTRA_4"   : 20
    }
};

/**
 * Associate a gamepad event to a keycode
 * @name bindGamepad
 * @memberof input
 * @public
 * @param {number} index Gamepad index
 * @param {object} button Button/Axis definition
 * @param {string} button.type "buttons" or "axes"
 * @param {number} button.code button or axis code id (See {@link input.GAMEPAD.BUTTONS}, {@link input.GAMEPAD.AXES})
 * @param {number} [button.threshold=1] value indicating when the axis should trigger the keycode (e.g. -0.5 or 0.5)
 * @param {number} keyCode (See {@link input.KEY})
 * @example
 * // enable the keyboard
 * me.input.bindKey(me.input.KEY.X, "shoot");
 * ...
 * // map the lower face button on the first gamepad to the X key
 * me.input.bindGamepad(0, {type:"buttons", code: me.input.GAMEPAD.BUTTONS.FACE_1}, me.input.KEY.X);
 * // map the left axis value on the first gamepad to the LEFT key
 * me.input.bindGamepad(0, {type:"axes", code: me.input.GAMEPAD.AXES.LX, threshold: -0.5}, me.input.KEY.LEFT);
 */
function bindGamepad(index, button, keyCode) {
    // Throw an exception if no action is defined for the specified keycode
    if (!getBindingKey(keyCode)) {
        throw new Error("no action defined for keycode " + keyCode);
    }

    // register to the the update event if not yet done and supported by the browser
    // if not supported, the function will fail silently (-> update loop won't be called)
    if (typeof updateEventHandler === "undefined" && typeof navigator.getGamepads === "function") {
        updateEventHandler = on(GAME_BEFORE_UPDATE, updateGamepads);
    }

    // Allocate bindings if not defined
    if (!bindings[index]) {
        bindings[index] = {
            "axes" : {},
            "buttons" : {}
        };
    }

    var mapping = {
        "keyCode" : keyCode,
        "value" : 0,
        "pressed" : false,
        "threshold" : button.threshold // can be undefined
    };
    var binding = bindings[index][button.type];

    // Map the gamepad button or axis to the keycode
    if (button.type === "buttons") {
        // buttons are defined by a `gamePadButton` object
        binding[button.code] = mapping;
    } else if (button.type === "axes") {
        // normalize threshold into a value that can represent both side of the axis
        var range = (Math.sign(button.threshold) || 1);
        // axes are defined using two objects; one for negative and one for positive
        if (!binding[button.code]) {
            binding[button.code] = {};
        }
        var axes = binding[button.code];
        axes[range] = mapping;

        // Ensure the opposite axis exists
        if (!axes[-range]) {
            axes[-range] = {
                "keyCode" : 0,
                "value" : 0,
                "pressed" : false,
                "threshold" : -range
            };
        }
    }
}
/**
 * unbind the defined keycode
 * @name unbindGamepad
 * @memberof input
 * @public
 * @param {number} index Gamepad index
 * @param {number} button (See {@link input.GAMEPAD.BUTTONS})
 * @example
 * me.input.unbindGamepad(0, me.input.GAMEPAD.BUTTONS.FACE_1);
 */
function unbindGamepad(index, button) {
    if (!bindings[index]) {
        throw new Error("no bindings for gamepad " + index);
    }
    bindings[index].buttons[button] = {};
}
/**
 * Set deadzone for analog gamepad inputs<br>
 * The default deadzone is 0.1 (10%) Analog values less than this will be ignored
 * @name setGamepadDeadzone
 * @memberof input
 * @public
 * @param {number} value Deadzone value
 */
function setGamepadDeadzone(value) {
    deadzone = value;
}
/**
 * specify a custom mapping for a specific gamepad id<br>
 * see below for the default mapping : <br>
 * <center><img src="images/gamepad_diagram.png"/></center><br>
 * @name setGamepadMapping
 * @memberof input
 * @public
 * @param {string} id Gamepad id string
 * @param {object} mapping A hash table
 * @param {number[]} mapping.axes Standard analog control stick axis locations
 * @param {number[]} mapping.buttons Standard digital button locations
 * @param {number[]} [mapping.analog] Analog axis locations for buttons
 * @param {Function} [mapping.normalize_fn] a function that returns a normalized value in range [-1.0..1.0] for the given value, axis and button
 * @example
 * // A weird controller that has its axis mappings reversed
 * me.input.setGamepadMapping("Generic USB Controller", {
 *   "axes" : [ 3, 2, 1, 0 ],
 *   "buttons" : [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
 * });
 *
 * // Mapping extra axes to analog buttons
 * me.input.setGamepadMapping("Generic Analog Controller", {
 *   "axes" : [ 0, 1, 2, 3 ],
 *   "buttons" : [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ],
 *
 *   // Raw axis 4 is mapped to GAMEPAD.BUTTONS.FACE_1
 *   // Raw axis 5 is mapped to GAMEPAD.BUTTONS.FACE_2
 *   // etc...
 *   // Also maps left and right triggers
 *   "analog" : [ 4, 5, 6, 7, -1, -1, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1 ],
 *
 *   // Normalize the value of button L2: [-1.0..1.0] => [0.0..1.0]
 *   "normalize_fn" : function (value, axis, button) {
 *     return ((button === me.input.GAMEPAD.BUTTONS.L2) ? ((value + 1) / 2) : value) || 0;
 *   }
 * });
 */
var setGamepadMapping = addMapping;

/**
 * @namespace input
 */

/**
 * specify if melonJS should prevent all default browser action on registered events.
 * @public
 * @type {boolean}
 * @default true
 * @name preventDefault
 * @memberof input
 */
var preventDefault = true;

var input = /*#__PURE__*/Object.freeze({
	__proto__: null,
	preventDefault: preventDefault,
	get pointerEventTarget () { return pointerEventTarget; },
	pointer: pointer,
	get locked () { return locked; },
	get throttlingInterval () { return throttlingInterval; },
	globalToLocal: globalToLocal,
	setTouchAction: setTouchAction,
	bindPointer: bindPointer,
	unbindPointer: unbindPointer,
	registerPointerEvent: registerPointerEvent,
	releasePointerEvent: releasePointerEvent,
	releaseAllPointerEvents: releaseAllPointerEvents,
	requestPointerLock: requestPointerLock,
	exitPointerLock: exitPointerLock,
	get keyBoardEventTarget () { return keyBoardEventTarget; },
	KEY: KEY,
	initKeyboardEvent: initKeyboardEvent,
	isKeyPressed: isKeyPressed,
	keyStatus: keyStatus,
	triggerKeyEvent: triggerKeyEvent,
	bindKey: bindKey,
	getBindingKey: getBindingKey,
	unlockKey: unlockKey,
	unbindKey: unbindKey,
	GAMEPAD: GAMEPAD,
	bindGamepad: bindGamepad,
	unbindGamepad: unbindGamepad,
	setGamepadDeadzone: setGamepadDeadzone,
	setGamepadMapping: setGamepadMapping
});

/**
 * @classdesc
 * A base class for renderable objects.
 * @augments Rect
 */
class Renderable extends Rect {
    /**
     * @param {number} x position of the renderable object (accessible through inherited pos.x property)
     * @param {number} y position of the renderable object (accessible through inherited pos.y property)
     * @param {number} width object width
     * @param {number} height object height
     */
    constructor(x, y, width, height) {

        // parent constructor
        super(x, y, width, height);

        /**
         * to identify the object as a renderable object
         * @ignore
         */
        this.isRenderable = true;

        /**
         * If true then physic collision and input events will not impact this renderable
         * @public
         * @type {boolean}
         * @default true
         * @name isKinematic
         * @memberof Renderable
         */
        this.isKinematic = true;

        /**
         * the renderable physic body
         * @public
         * @type {Body}
         * @see Body
         * @name body
         * @memberof Renderable#
         * @example
         *  // define a new Player Class
         *  class PlayerEntity extends me.Sprite {
         *      // constructor
         *      constructor(x, y, settings) {
         *          // call the parent constructor
         *          super(x, y , settings);
         *
         *          // define a basic walking animation
         *          this.addAnimation("walk",  [...]);
         *          // define a standing animation (using the first frame)
         *          this.addAnimation("stand",  [...]);
         *          // set the standing animation as default
         *          this.setCurrentAnimation("stand");
         *
         *          // add a physic body
         *          this.body = new me.Body(this);
         *          // add a default collision shape
         *          this.body.addShape(new me.Rect(0, 0, this.width, this.height));
         *          // configure max speed, friction, and initial force to be applied
         *          this.body.setMaxVelocity(3, 15);
         *          this.body.setFriction(0.4, 0);
         *          this.body.force.set(3, 0);
         *
         *          // set the display to follow our position on both axis
         *          me.game.viewport.follow(this.pos, me.game.viewport.AXIS.BOTH);
         *      }
         *
         *      ...
         *
         * }
         */
        this.body = undefined;

        if (typeof this.currentTransform === "undefined") {
            /**
             * the renderable default transformation matrix
             * @public
             * @type {Matrix2d}
             * @name currentTransform
             * @memberof Renderable#
             */
            this.currentTransform = pool.pull("Matrix2d");
        }
        this.currentTransform.identity();

       /**
        * (G)ame (U)nique (Id)entifier" <br>
        * a GUID will be allocated for any renderable object added <br>
        * to an object container (including the `me.game.world` container)
        * @public
        * @type {string}
        * @name GUID
        * @memberof Renderable
        */
        this.GUID = undefined;

        /**
         * an event handler that is called when the renderable leave or enter a camera viewport
         * @public
         * @type {Function}
         * @default undefined
         * @name onVisibilityChange
         * @memberof Renderable#
         * @example
         * this.onVisibilityChange = function(inViewport) {
         *     if (inViewport === true) {
         *         console.log("object has entered the in a camera viewport!");
         *     }
         * };
         */
        this.onVisibilityChange = undefined;

        /**
         * Whether the renderable object will always update, even when outside of the viewport<br>
         * @public
         * @type {boolean}
         * @default false
         * @name alwaysUpdate
         * @memberof Renderable
         */
        this.alwaysUpdate = false;

        /**
         * Whether to update this object when the game is paused.
         * @public
         * @type {boolean}
         * @default false
         * @name updateWhenPaused
         * @memberof Renderable
         */
        this.updateWhenPaused = false;

        /**
         * make the renderable object persistent over level changes<br>
         * @public
         * @type {boolean}
         * @default false
         * @name isPersistent
         * @memberof Renderable
         */
        this.isPersistent = false;

        /**
         * If true, this renderable will be rendered using screen coordinates,
         * as opposed to world coordinates. Use this, for example, to define UI elements.
         * @public
         * @type {boolean}
         * @default false
         * @name floating
         * @memberof Renderable
         */
        this.floating = false;

        if (this.anchorPoint instanceof ObservableVector2d) {
            this.anchorPoint.setMuted(0.5, 0.5).setCallback(this.onAnchorUpdate, this);
        } else {
            /**
             * The anchor point is used for attachment behavior, and/or when applying transformations.<br>
             * The coordinate system places the origin at the top left corner of the frame (0, 0) and (1, 1) means the bottom-right corner<br>
             * <img src="images/anchor_point.png"/><br>
             * a Renderable's anchor point defaults to (0.5,0.5), which corresponds to the center position.<br>
             * <br>
             * <i><b>Note:</b> Object created through Tiled will have their anchorPoint set to (0, 0) to match Tiled Level editor implementation.
             * To specify a value through Tiled, use a json expression like `json:{"x":0.5,"y":0.5}`. </i>
             * @public
             * @type {ObservableVector2d}
             * @default <0.5,0.5>
             * @name anchorPoint
             * @memberof Renderable#
             */
            this.anchorPoint = pool.pull("ObservableVector2d", 0.5, 0.5, { onUpdate: this.onAnchorUpdate, scope: this });
        }

        /**
         * When enabled, an object container will automatically apply
         * any defined transformation before calling the child draw method.
         * @public
         * @type {boolean}
         * @default true
         * @name autoTransform
         * @memberof Renderable
         * @example
         * // enable "automatic" transformation when the object is activated
         * onActivateEvent: function () {
         *     // reset the transformation matrix
         *     this.currentTransform.identity();
         *     // ensure the anchor point is the renderable center
         *     this.anchorPoint.set(0.5, 0.5);
         *     // enable auto transform
         *     this.autoTransform = true;
         *     ....
         * }
         */
        this.autoTransform = true;

        /**
         * Define the renderable opacity<br>
         * Set to zero if you do not wish an object to be drawn
         * @see Renderable#setOpacity
         * @see Renderable#getOpacity
         * @public
         * @type {number}
         * @default 1.0
         * @name Renderable#alpha
         */
        this.alpha = 1.0;

        /**
         * a reference to the parent object that contains this renderable
         * @public
         * @type {Container|Entity}
         * @default undefined
         * @name Renderable#ancestor
         */
        this.ancestor = undefined;

        /**
         * A mask limits rendering elements to the shape and position of the given mask object.
         * So, if the renderable is larger than the mask, only the intersecting part of the renderable will be visible.
         * @public
         * @type {Rect|RoundRect|Polygon|Line|Ellipse}
         * @name mask
         * @default undefined
         * @memberof Renderable#
         * @example
         * // apply a mask in the shape of a Star
         * myNPCSprite.mask = new me.Polygon(myNPCSprite.width / 2, 0, [
         *    // draw a star
         *    {x: 0, y: 0},
         *    {x: 14, y: 30},
         *    {x: 47, y: 35},
         *    {x: 23, y: 57},
         *    {x: 44, y: 90},
         *    {x: 0, y: 62},
         *    {x: -44, y: 90},
         *    {x: -23, y: 57},
         *    {x: -47, y: 35},
         *    {x: -14, y: 30}
         * ]);
         */
        this.mask = undefined;

        /**
         * define a tint for this renderable. a (255, 255, 255) r, g, b value will remove the tint effect.
         * @public
         * @type {Color}
         * @name tint
         * @default (255, 255, 255)
         * @memberof Renderable#
         * @example
         * // add a red tint to this renderable
         * this.tint.setColor(255, 128, 128);
         * // remove the tint
         * this.tint.setColor(255, 255, 255);
         */
        this.tint = pool.pull("Color", 255, 255, 255, 1.0);

        /**
         * the blend mode to be applied to this renderable (see renderer setBlendMode for available blend mode)
         * @public
         * @type {string}
         * @name blendMode
         * @default "normal"
         * @see CanvasRenderer#setBlendMode
         * @see WebGLRenderer#setBlendMode
         * @memberof Renderable#
         */
        this.blendMode = "normal";

        /**
         * The name of the renderable
         * @public
         * @type {string}
         * @name name
         * @default ""
         * @memberof Renderable
         */
        this.name = "";

        if (this.pos instanceof ObservableVector3d) {
            this.pos.setMuted(x, y, 0).setCallback(this.updateBoundsPos, this);
        } else {
            /**
             * Position of the Renderable relative to its parent container
             * @public
             * @type {ObservableVector3d}
             * @name pos
             * @memberof Renderable#
             */
            this.pos = pool.pull("ObservableVector3d", x, y, 0, { onUpdate: this.updateBoundsPos, scope: this});
        }

        /**
         * when true the renderable will be redrawn during the next update cycle
         * @type {boolean}
         * @name isDirty
         * @default false
         * @memberof Renderable#
         */
        this.isDirty = false;

        // keep track of when we flip
        this._flip = {
            x : false,
            y : false
        };

        // viewport flag
        this._inViewport = false;

        // ensure it's fully opaque by default
        this.setOpacity(1.0);
    }

    /**
     * Whether the renderable object is floating, or contained in a floating container
     * @public
     * @see Renderable#floating
     * @type {boolean}
     * @name isFloating
     * @memberof Renderable
     */
    get isFloating() {
        return this.floating === true || (typeof this.ancestor !== "undefined" && this.ancestor.floating === true);
    }

    /**
     * Whether the renderable object is visible and within the viewport
     * @public
     * @type {boolean}
     * @default false
     * @name inViewport
     * @memberof Renderable
     */
    get inViewport() {
        return this._inViewport;
    }
    set inViewport(value) {
        if (this._inViewport !== value) {
            this._inViewport = value;
            if (typeof this.onVisibilityChange === "function") {
                this.onVisibilityChange.call(this, value);
            }
        }
    }

    /**
     * returns true if this renderable is flipped on the horizontal axis
     * @public
     * @see Renderable#flipX
     * @type {boolean}
     * @name isFlippedX
     * @memberof Renderable
     */
    get isFlippedX() {
        return this._flip.x === true;
    }

    /**
     * returns true if this renderable is flipped on the vertical axis
     * @public
     * @see Renderable#flipY
     * @type {boolean}
     * @name isFlippedY
     * @memberof Renderable
     */
    get isFlippedY() {
        return this._flip.y === true;
    }

    /**
     * returns the bounding box for this renderable
     * @name getBounds
     * @memberof Renderable
     * @returns {Bounds} bounding box Rectangle object
     */
    getBounds() {
        if (typeof this._bounds === "undefined") {
            super.getBounds();
            if (this.isFinite()) {
                this._bounds.setMinMax(this.pos.x, this.pos.y, this.pos.x + this.width, this.pos.y + this.height);
            } else {
                // e.g. containers or game world can have infinite size
                this._bounds.setMinMax(this.pos.x, this.pos.y, this.width, this.height);
            }

        }
        return this._bounds;
    }

    /**
     * get the renderable alpha channel value<br>
     * @name getOpacity
     * @memberof Renderable
     * @returns {number} current opacity value between 0 and 1
     */
    getOpacity() {
        return this.alpha;
    }

    /**
     * set the renderable alpha channel value<br>
     * @name setOpacity
     * @memberof Renderable
     * @param {number} alpha opacity value between 0.0 and 1.0
     */
    setOpacity(alpha) {
        if (typeof (alpha) === "number") {
            this.alpha = clamp(alpha, 0.0, 1.0);
            // Set to 1 if alpha is NaN
            if (isNaN(this.alpha)) {
                this.alpha = 1.0;
            }
            this.isDirty = true;
        }
    }

    /**
     * flip the renderable on the horizontal axis (around the center of the renderable)
     * @see Matrix2d#scaleX
     * @name flipX
     * @memberof Renderable
     * @param {boolean} [flip=true] `true` to flip this renderable.
     * @returns {Renderable} Reference to this object for method chaining
     */
    flipX(flip = true) {
        this._flip.x = !!flip;
        this.isDirty = true;
        return this;
    }

    /**
     * flip the renderable on the vertical axis (around the center of the renderable)
     * @see Matrix2d#scaleY
     * @name flipY
     * @memberof Renderable
     * @param {boolean} [flip=true] `true` to flip this renderable.
     * @returns {Renderable} Reference to this object for method chaining
     */
    flipY(flip = true) {
        this._flip.y = !!flip;
        this.isDirty = true;
        return this;
    }

    /**
     * multiply the renderable currentTransform with the given matrix
     * @name transform
     * @memberof Renderable
     * @see Renderable#currentTransform
     * @param {Matrix2d} m the transformation matrix
     * @returns {Renderable} Reference to this object for method chaining
     */
    transform(m) {
        this.currentTransform.multiply(m);
        //super.transform(m);
        this.updateBoundsPos(this.pos.x, this.pos.y);
        this.isDirty = true;
        return this;
    }

    /**
     * return the angle to the specified target
     * @name angleTo
     * @memberof Renderable
     * @param {Renderable|Vector2d|Vector3d} target
     * @returns {number} angle in radians
     */
    angleTo(target) {
        var a = this.getBounds();
        var ax, ay;

        if (target instanceof Renderable) {
            var b = target.getBounds();
            ax = b.centerX - a.centerX;
            ay = b.centerY - a.centerY;
        } else { // vector object
            ax = target.x - a.centerX;
            ay = target.y - a.centerY;
        }

        return Math.atan2(ay, ax);
    }

    /**
     * return the distance to the specified target
     * @name distanceTo
     * @memberof Renderable
     * @param {Renderable|Vector2d|Vector3d} target
     * @returns {number} distance
     */
    distanceTo(target) {
        var a = this.getBounds();
        var dx, dy;

        if (target instanceof Renderable) {
            var b = target.getBounds();
            dx = a.centerX - b.centerX;
            dy = a.centerY - b.centerY;
        } else { // vector object
            dx = a.centerX - target.x;
            dy = a.centerY - target.y;
        }

        return Math.sqrt(dx * dx + dy * dy);
    }

    /**
     * Rotate this renderable towards the given target.
     * @name lookAt
     * @memberof Renderable
     * @param {Renderable|Vector2d|Vector3d} target the renderable or position to look at
     * @returns {Renderable} Reference to this object for method chaining
     */
    lookAt(target) {
        var position;

        if (target instanceof Renderable) {
            position = target.pos;
        } else {
            position = target;
        }

        var angle = this.angleTo(position);

        this.rotate(angle);

        return this;
    }

    /**
     * Rotate this renderable by the specified angle (in radians).
     * @name rotate
     * @memberof Renderable
     * @param {number} angle The angle to rotate (in radians)
     * @param {Vector2d|ObservableVector2d} [v] an optional point to rotate around
     * @returns {Renderable} Reference to this object for method chaining
     */
    rotate(angle, v) {
        if (!isNaN(angle)) {
            this.currentTransform.rotate(angle, v);
            //this.updateBoundsPos(this.pos.x, this.pos.y);
            this.isDirty = true;
        }
        return this;
    }

    /**
     * scale the renderable around his anchor point.  Scaling actually applies changes
     * to the currentTransform member wich is used by the renderer to scale the object
     * when rendering.  It does not scale the object itself.  For example if the renderable
     * is an image, the image.width and image.height properties are unaltered but the currentTransform
     * member will be changed.
     * @name scale
     * @memberof Renderable
     * @param {number} x a number representing the abscissa of the scaling vector.
     * @param {number} [y=x] a number representing the ordinate of the scaling vector.
     * @returns {Renderable} Reference to this object for method chaining
     */
    scale(x, y) {
        this.currentTransform.scale(x, y);
        super.scale(x, y);
        this.isDirty = true;
        return this;
    }

    /**
     * scale the renderable around his anchor point
     * @name scaleV
     * @memberof Renderable
     * @param {Vector2d} v scaling vector
     * @returns {Renderable} Reference to this object for method chaining
     */
    scaleV(v) {
        this.scale(v.x, v.y);
        return this;
    }

    /**
     * update function. <br>
     * automatically called by the game manager {@link game}
     * @name update
     * @memberof Renderable
     * @protected
     * @param {number} dt time since the last update in milliseconds.
     * @returns {boolean} true if the renderable is dirty
     */
    update(dt) { // eslint-disable-line no-unused-vars
        return this.isDirty;
    }

    /**
     * update the bounding box for this shape.
     * @ignore
     * @name updateBounds
     * @memberof Renderable
     * @returns {Bounds} this shape bounding box Rectangle object
     */
    updateBounds() {
        super.updateBounds();
        this.updateBoundsPos(this.pos.x, this.pos.y);
        return this.getBounds();
    }

    /**
     * update the renderable's bounding rect (private)
     * @ignore
     * @name updateBoundsPos
     * @memberof Renderable
     */
     updateBoundsPos(newX, newY) {
         var bounds = this.getBounds();

         bounds.shift(newX, newY);

         if (typeof this.anchorPoint !== "undefined" && bounds.isFinite()) {
             bounds.translate(
                 -(this.anchorPoint.x * bounds.width),
                 -(this.anchorPoint.y * bounds.height)
             );
         }

         /*
         if (typeof this.body !== "undefined") {
              var bodyBounds = this.body.getBounds();
              bounds.translate(bodyBounds.x, bodyBounds.y);
         }
         */

         // XXX: This is called from the constructor, before it gets an ancestor
         if (this.ancestor instanceof Container && this.floating !== true) {
             bounds.translate(this.ancestor.getAbsolutePosition());
         }

         this.isDirty = true;
     }

     /**
      * return the renderable absolute position in the game world
      * @name getAbsolutePosition
      * @memberof Renderable
      * @returns {Vector2d}
      */
      getAbsolutePosition() {
          if (typeof this._absPos === "undefined") {
              this._absPos = pool.pull("Vector2d");
          }
          // XXX Cache me or something
          this._absPos.set(this.pos.x, this.pos.y);
          if (this.ancestor instanceof Container && this.floating !== true) {
              this._absPos.add(this.ancestor.getAbsolutePosition());
          }
          return this._absPos;
      }

    /**
     * called when the anchor point value is changed
     * @private
     * @name onAnchorUpdate
     * @memberof Renderable
     * @param {number} x the new X value to be set for the anchor
     * @param {number} y the new Y value to be set for the anchor
     */
     onAnchorUpdate(x, y) {
         // since the callback is called before setting the new value
         // manually update the anchor point (required for updateBoundsPos)
         this.anchorPoint.setMuted(x, y);
         // then call updateBounds
         this.updateBoundsPos(this.pos.x, this.pos.y);
     }

    /**
     * prepare the rendering context before drawing
     * (apply defined transforms, anchor point). <br>
     * automatically called by the game manager {@link game}
     * @name preDraw
     * @memberof Renderable
     * @protected
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer object
     */
    preDraw(renderer) {
        var bounds = this.getBounds();
        var ax = bounds.width * this.anchorPoint.x,
            ay = bounds.height * this.anchorPoint.y;

        // save renderer context
        renderer.save();

        // apply the defined alpha value
        renderer.setGlobalAlpha(renderer.globalAlpha() * this.getOpacity());

        // apply flip
        if (this._flip.x || this._flip.y) {
            var dx = this._flip.x ? this.centerX - ax : 0,
                dy = this._flip.y ? this.centerY - ay : 0;

            renderer.translate(dx, dy);
            renderer.scale(this._flip.x  ? -1 : 1, this._flip.y  ? -1 : 1);
            renderer.translate(-dx, -dy);
        }

        // apply stencil mask if defined
        if (typeof this.mask !== "undefined") {
            renderer.translate(this.pos.x, this.pos.y);
            renderer.setMask(this.mask);
            renderer.translate(-this.pos.x, -this.pos.y);
        }

        if ((this.autoTransform === true) && (!this.currentTransform.isIdentity())) {
            // apply the renderable transformation matrix
            renderer.translate(this.pos.x, this.pos.y);
            renderer.transform(this.currentTransform);
            renderer.translate(-this.pos.x, -this.pos.y);
        }

        // offset by the anchor point
        renderer.translate(-ax, -ay);

        // apply the current tint and opacity
        renderer.setTint(this.tint, this.getOpacity());

        // apply blending if different from "normal"
        if (this.blendMode !== renderer.getBlendMode()) {
            renderer.setBlendMode(this.blendMode);
        }
    }

    /**
     * draw this renderable (automatically called by melonJS)
     * @name draw
     * @memberof Renderable
     * @protected
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer instance
     * @param {Camera2d} [viewport] the viewport to (re)draw
     */
    draw(renderer, viewport) {  // eslint-disable-line no-unused-vars
        // empty one !
    }

    /**
     * restore the rendering context after drawing. <br>
     * automatically called by the game manager {@link game}
     * @name postDraw
     * @memberof Renderable
     * @protected
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer object
     */
    postDraw(renderer) {
        // remove the previously applied tint
        renderer.clearTint();

        // clear the mask if set
        if (typeof this.mask !== "undefined") {
            renderer.clearMask();
        }

        // restore the context
        renderer.restore();

        // reset the dirty flag
        this.isDirty = false;
    }

    /**
     * onCollision callback, triggered in case of collision,
     * when this renderable body is colliding with another one
     * @name onCollision
     * @memberof Renderable
     * @param {ResponseObject} response the collision response object
     * @param {Renderable} other the other renderable touching this one (a reference to response.a or response.b)
     * @returns {boolean} true if the object should respond to the collision (its position and velocity will be corrected)
     * @example
     * // colision handler
     * onCollision(response) {
     *     if (response.b.body.collisionType === me.collision.types.ENEMY_OBJECT) {
     *         // makes the other object solid, by substracting the overlap vector to the current position
     *         this.pos.sub(response.overlapV);
     *         this.hurt();
     *         // not solid
     *         return false;
     *     }
     *     // Make the object solid
     *     return true;
     * },
     */
    onCollision(response, other) { // eslint-disable-line no-unused-vars
        return false;
    }

    /**
     * Destroy function<br>
     * @ignore
     */
    destroy() {
        // allow recycling object properties
        pool.push(this.currentTransform);
        this.currentTransform = undefined;

        pool.push(this.anchorPoint);
        this.anchorPoint = undefined;

        pool.push(this.pos);
        this.pos = undefined;

        if (typeof this._absPos !== "undefined") {
            pool.push(this._absPos);
            this._absPos = undefined;
        }

        pool.push(this._bounds);
        this._bounds = undefined;

        this.onVisibilityChange = undefined;

        if (typeof this.mask !== "undefined") {
            pool.push(this.mask);
            this.mask = undefined;
        }

        if (typeof this.tint !== "undefined") {
            pool.push(this.tint);
            this.tint = undefined;
        }

        this.ancestor = undefined;

        // destroy the physic body if defined
        if (typeof this.body !== "undefined") {
            this.body.destroy.apply(this.body, arguments);
            this.body = undefined;
        }

        // release all registered events
        releaseAllPointerEvents(this);

        // call the user defined destroy method
        this.onDestroyEvent.apply(this, arguments);
    }

    /**
     * OnDestroy Notification function<br>
     * Called by engine before deleting the object
     * @name onDestroyEvent
     * @memberof Renderable
     */
    onDestroyEvent() {
        // to be extended !
    }

}

/**
 * @classdesc
 * an ellipse Object
 */
class Ellipse {
    /**
     * @param {number} x the center x coordinate of the ellipse
     * @param {number} y the center y coordinate of the ellipse
     * @param {number} w width (diameter) of the ellipse
     * @param {number} h height (diameter) of the ellipse
     */
    constructor(x, y, w, h) {
        /**
         * the center coordinates of the ellipse
         * @public
         * @type {Vector2d}
         * @name pos
         * @memberof Ellipse
         */
        this.pos = pool.pull("Vector2d");

        /**
         * The bounding rectangle for this shape
         * @private
         */
        this._bounds = undefined;

        /**
         * Maximum radius of the ellipse
         * @public
         * @type {number}
         * @name radius
         * @memberof Ellipse
         */
        this.radius = NaN;

        /**
         * Pre-scaled radius vector for ellipse
         * @public
         * @type {Vector2d}
         * @name radiusV
         * @memberof Ellipse
         */
        this.radiusV = pool.pull("Vector2d");

        /**
         * Radius squared, for pythagorean theorom
         * @public
         * @type {Vector2d}
         * @name radiusSq
         * @memberof Ellipse
         */
        this.radiusSq = pool.pull("Vector2d");

        /**
         * x/y scaling ratio for ellipse
         * @public
         * @type {Vector2d}
         * @name ratio
         * @memberof Ellipse
         */
        this.ratio = pool.pull("Vector2d");

        // the shape type
        this.shapeType = "Ellipse";
        this.setShape(x, y, w, h);
    }

    /** @ignore */
    onResetEvent(x, y, w, h) {
        this.setShape(x, y, w, h);
    }

    /**
     * set new value to the Ellipse shape
     * @name setShape
     * @memberof Ellipse
     * @param {number} x the center x coordinate of the ellipse
     * @param {number} y the center y coordinate of the ellipse
     * @param {number} w width (diameter) of the ellipse
     * @param {number} h height (diameter) of the ellipse
     * @returns {Ellipse} this instance for objecf chaining
     */
    setShape(x, y, w, h) {
        var hW = w / 2;
        var hH = h / 2;

        this.pos.set(x, y);
        this.radius = Math.max(hW, hH);
        this.ratio.set(hW / this.radius, hH / this.radius);
        this.radiusV.set(this.radius, this.radius).scaleV(this.ratio);
        var r = this.radius * this.radius;
        this.radiusSq.set(r, r).scaleV(this.ratio);

        // update the corresponding bounds
        this.getBounds().setMinMax(x, y, x + w, x + h);
        // elipse position is the center of the cirble, bounds position are top left
        this.getBounds().translate(-this.radiusV.x, -this.radiusV.y);

        return this;
    }

    /**
     * Rotate this Ellipse (counter-clockwise) by the specified angle (in radians).
     * @name rotate
     * @memberof Ellipse
     * @param {number} angle The angle to rotate (in radians)
     * @param {Vector2d|ObservableVector2d} [v] an optional point to rotate around
     * @returns {Ellipse} Reference to this object for method chaining
     */
    rotate(angle, v) {
        // TODO : only works for circle
        this.pos.rotate(angle, v);
        this.getBounds().shift(this.pos);
        this.getBounds().translate(-this.radiusV.x, -this.radiusV.y);
        return this;
    }

    /**
     * Scale this Ellipse by the specified scalar.
     * @name scale
     * @memberof Ellipse
     * @param {number} x
     * @param {number} [y=x]
     * @returns {Ellipse} Reference to this object for method chaining
     */
    scale(x, y) {
        y = typeof (y) !== "undefined" ? y : x;
        return this.setShape(
            this.pos.x,
            this.pos.y,
            this.radiusV.x * 2 * x,
            this.radiusV.y * 2 * y
        );
    }

    /**
     * Scale this Ellipse by the specified vector.
     * @name scale
     * @memberof Ellipse
     * @param {Vector2d} v
     * @returns {Ellipse} Reference to this object for method chaining
     */
    scaleV(v) {
        return this.scale(v.x, v.y);
    }

    /**
     * apply the given transformation matrix to this ellipse
     * @name transform
     * @memberof Ellipse
     * @param {Matrix2d} matrix the transformation matrix
     * @returns {Polygon} Reference to this object for method chaining
     */
    transform(matrix) { // eslint-disable-line no-unused-vars
        // TODO
        return this;
    }

    /**
     * translate the circle/ellipse by the specified offset
     * @name translate
     * @memberof Ellipse
     * @method
     * @param {number} x x offset
     * @param {number} y y offset
     * @returns {Ellipse} this ellipse
     */
    /**
     * translate the circle/ellipse by the specified vector
     * @name translate
     * @memberof Ellipse
     * @param {Vector2d} v vector offset
     * @returns {Ellipse} this ellipse
     */
    translate() {
        var _x, _y;

        if (arguments.length === 2) {
            // x, y
            _x = arguments[0];
            _y = arguments[1];
        } else {
            // vector
            _x = arguments[0].x;
            _y = arguments[0].y;
        }

        this.pos.x += _x;
        this.pos.y += _y;
        this.getBounds().translate(_x, _y);

        return this;
    }

    /**
     * check if this circle/ellipse contains the specified point
     * @name contains
     * @method
     * @memberof Ellipse
     * @param {Vector2d} point
     * @returns {boolean} true if contains
     */

    /**
     * check if this circle/ellipse contains the specified point
     * @name contains
     * @memberof Ellipse
     * @param  {number} x x coordinate
     * @param  {number} y y coordinate
     * @returns {boolean} true if contains
     */
    contains() {
        var _x, _y;

        if (arguments.length === 2) {
          // x, y
          _x = arguments[0];
          _y = arguments[1];
        } else {
          // vector
          _x = arguments[0].x;
          _y = arguments[0].y;
        }

        // Make position relative to object center point.
        _x -= this.pos.x;
        _y -= this.pos.y;
        // Pythagorean theorem.
        return (
            ((_x * _x) / this.radiusSq.x) +
            ((_y * _y) / this.radiusSq.y)
        ) <= 1.0;
    }

    /**
     * returns the bounding box for this shape, the smallest Rectangle object completely containing this shape.
     * @name getBounds
     * @memberof Ellipse
     * @returns {Bounds} this shape bounding box Rectangle object
     */
    getBounds() {
        if (typeof this._bounds === "undefined") {
            this._bounds = pool.pull("Bounds");
        }
        return this._bounds;
    }

    /**
     * clone this Ellipse
     * @name clone
     * @memberof Ellipse
     * @returns {Ellipse} new Ellipse
     */
    clone() {
        return new Ellipse(
            this.pos.x,
            this.pos.y,
            this.radiusV.x * 2,
            this.radiusV.y * 2
        );
    }
}

/*
* Separating Axis Theorem implementation, based on the SAT.js library by Jim Riecken <jimr@jimr.ca>
* Available under the MIT License - https://github.com/jriecken/sat-js
*/

/**
 * Constants for Vornoi regions
 * @ignore
 */
const LEFT_VORNOI_REGION = -1;

/**
 * Constants for Vornoi regions
 * @ignore
 */
const MIDDLE_VORNOI_REGION = 0;

/**
 * Constants for Vornoi regions
 * @ignore
 */
const RIGHT_VORNOI_REGION = 1;


/**
 * A pool of `Vector` objects that are used in calculations to avoid allocating memory.
 * @type {Array.<Vector2d>}
 * @ignore
 */
var T_VECTORS = [];
for (var v = 0; v < 10; v++) { T_VECTORS.push(new Vector2d()); }

/**
 * A pool of arrays of numbers used in calculations to avoid allocating memory.
 * @type {Array.<Array.<number>>}
 * @ignore
 */
var T_ARRAYS = [];
for (var a = 0; a < 5; a++) { T_ARRAYS.push([]); }


/**
 * Flattens the specified array of points onto a unit vector axis,
 * resulting in a one dimensional range of the minimum and
 * maximum value on that axis.
 * @ignore
 * @param {Array.<Vector2d>} points The points to flatten.
 * @param {Vector2d} normal The unit vector axis to flatten on.
 * @param {Array.<number>} result An array.  After calling this function,
 *   result[0] will be the minimum value,
 *   result[1] will be the maximum value.
 */
function flattenPointsOn(points, normal, result) {
    var min = Number.MAX_VALUE;
    var max = -Number.MAX_VALUE;
    var len = points.length;
    for (var i = 0; i < len; i++) {
        // The magnitude of the projection of the point onto the normal
        var dot = points[i].dot(normal);
        if (dot < min) { min = dot; }
        if (dot > max) { max = dot; }
    }
    result[0] = min;
    result[1] = max;
}

/**
 * Check whether two convex polygons are separated by the specified
 * axis (must be a unit vector).
 * @ignore
 * @param {Vector2d} aPos The position of the first polygon.
 * @param {Vector2d} bPos The position of the second polygon.
 * @param {Array.<Vector2d>} aPoints The points in the first polygon.
 * @param {Array.<Vector2d>} bPoints The points in the second polygon.
 * @param {Vector2d} axis The axis (unit sized) to test against.  The points of both polygons
 *   will be projected onto this axis.
 * @param {Response=} response A Response object (optional) which will be populated
 *   if the axis is not a separating axis.
 * @returns {boolean} true if it is a separating axis, false otherwise.  If false,
 *   and a response is passed in, information about how much overlap and
 *   the direction of the overlap will be populated.
 */
function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {
    var rangeA = T_ARRAYS.pop();
    var rangeB = T_ARRAYS.pop();
    // The magnitude of the offset between the two polygons
    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
    var projectedOffset = offsetV.dot(axis);

    // Project the polygons onto the axis.
    flattenPointsOn(aPoints, axis, rangeA);
    flattenPointsOn(bPoints, axis, rangeB);
    // Move B's range to its position relative to A.
    rangeB[0] += projectedOffset;
    rangeB[1] += projectedOffset;
    // Check if there is a gap. If there is, this is a separating axis and we can stop
    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
        T_VECTORS.push(offsetV);
        T_ARRAYS.push(rangeA);
        T_ARRAYS.push(rangeB);
        return true;
    }

    // This is not a separating axis. If we're calculating a response, calculate the overlap.
    if (response) {
        var overlap = 0;
        // A starts further left than B
        if (rangeA[0] < rangeB[0]) {
            response.aInB = false;
            // A ends before B does. We have to pull A out of B
            if (rangeA[1] < rangeB[1]) {
                overlap = rangeA[1] - rangeB[0];
                response.bInA = false;
            // B is fully inside A.  Pick the shortest way out.
            } else {
                var option1 = rangeA[1] - rangeB[0];
                var option2 = rangeB[1] - rangeA[0];
                overlap = option1 < option2 ? option1 : -option2;
            }
        // B starts further left than A
        } else {
            response.bInA = false;
            // B ends before A ends. We have to push A out of B
            if (rangeA[1] > rangeB[1]) {
                overlap = rangeA[0] - rangeB[1];
                response.aInB = false;
            // A is fully inside B.  Pick the shortest way out.
            } else {
                var option11 = rangeA[1] - rangeB[0];
                var option22 = rangeB[1] - rangeA[0];
                overlap = option11 < option22 ? option11 : -option22;
            }
        }

        // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.
        var absOverlap = Math.abs(overlap);
        if (absOverlap < response.overlap) {
            response.overlap = absOverlap;
            response.overlapN.copy(axis);
            if (overlap < 0) {
                response.overlapN.negateSelf();
            }
        }
    }
    T_VECTORS.push(offsetV);
    T_ARRAYS.push(rangeA);
    T_ARRAYS.push(rangeB);
    return false;
}


/**
 * Calculates which Vornoi region a point is on a line segment. <br>
 * It is assumed that both the line and the point are relative to `(0,0)`<br>
 * <pre>
 *             |       (0)      |
 *      (-1)  [S]--------------[E]  (1)
 *             |       (0)      |
 * </pre>
 *
 * @ignore
 * @param {Vector2d} line The line segment.
 * @param {Vector2d} point The point.
 * @returns  {number} LEFT_VORNOI_REGION (-1) if it is the left region,
 *          MIDDLE_VORNOI_REGION (0) if it is the middle region,
 *          RIGHT_VORNOI_REGION (1) if it is the right region.
 */
function vornoiRegion(line, point) {
    var len2 = line.length2();
    var dp = point.dot(line);
    if (dp < 0) {
        // If the point is beyond the start of the line, it is in the
        // left vornoi region.
        return LEFT_VORNOI_REGION;
    } else if (dp > len2) {
        // If the point is beyond the end of the line, it is in the
        // right vornoi region.
        return RIGHT_VORNOI_REGION;
    } else {
        // Otherwise, it's in the middle one.
        return MIDDLE_VORNOI_REGION;
    }
}

/**
 * Checks whether polygons collide.
 * @ignore
 * @param {Renderable} a a reference to the object A.
 * @param {Polygon} polyA a reference to the object A Polygon to be tested
 * @param {Renderable} b a reference to the object B.
 * @param {Polygon} polyB a reference to the object B Polygon to be tested
 * @param {Response=} response Response object (optional) that will be populated if they intersect.
 * @returns {boolean} true if they intersect, false if they don't.
 */
function testPolygonPolygon(a, polyA, b, polyB, response) {
    // specific point for
    var aPoints = polyA.points;
    var aNormals = polyA.normals;
    var aLen = aNormals.length;
    var bPoints = polyB.points;
    var bNormals = polyB.normals;
    var bLen = bNormals.length;
    // aboslute shape position
    var posA = T_VECTORS.pop().copy(a.pos).add(a.ancestor.getAbsolutePosition()).add(polyA.pos);
    var posB = T_VECTORS.pop().copy(b.pos).add(b.ancestor.getAbsolutePosition()).add(polyB.pos);
    var i;

    // If any of the edge normals of A is a separating axis, no intersection.
    for (i = 0; i < aLen; i++) {
        if (isSeparatingAxis(posA, posB, aPoints, bPoints, aNormals[i], response)) {
            T_VECTORS.push(posA);
            T_VECTORS.push(posB);
            return false;
        }
    }

    // If any of the edge normals of B is a separating axis, no intersection.
    for (i = 0; i < bLen; i++) {
        if (isSeparatingAxis(posA, posB, aPoints, bPoints, bNormals[i], response)) {
            T_VECTORS.push(posA);
            T_VECTORS.push(posB);
            return false;
        }
    }

    // Since none of the edge normals of A or B are a separating axis, there is an intersection
    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the
    // final overlap vector.
    if (response) {
        response.a = a;
        response.b = b;
        response.overlapV.copy(response.overlapN).scale(response.overlap);
    }
    T_VECTORS.push(posA);
    T_VECTORS.push(posB);
    return true;
}

/**
 * Check if two Ellipse collide.
 * @ignore
 * @param {Renderable} a a reference to the object A.
 * @param {Ellipse} ellipseA a reference to the object A Ellipse to be tested
 * @param {Renderable} b a reference to the object B.
 * @param {Ellipse} ellipseB a reference to the object B Ellipse to be tested
 * @param {Response=} response Response object (optional) that will be populated if
 *   the circles intersect.
 * @returns {boolean} true if the circles intersect, false if they don't.
 */
function testEllipseEllipse(a, ellipseA, b, ellipseB, response) {
    // Check if the distance between the centers of the two
    // circles is greater than their combined radius.
    var differenceV = T_VECTORS.pop().copy(b.pos).add(b.ancestor.getAbsolutePosition()).add(ellipseB.pos)
        .sub(a.pos).add(a.ancestor.getAbsolutePosition()).sub(ellipseA.pos);
    var radiusA = ellipseA.radius;
    var radiusB = ellipseB.radius;
    var totalRadius = radiusA + radiusB;
    var totalRadiusSq = totalRadius * totalRadius;
    var distanceSq = differenceV.length2();
    // If the distance is bigger than the combined radius, they don't intersect.
    if (distanceSq > totalRadiusSq) {
        T_VECTORS.push(differenceV);
        return false;
    }
    // They intersect.  If we're calculating a response, calculate the overlap.
    if (response) {
        var dist = Math.sqrt(distanceSq);
        response.a = a;
        response.b = b;
        response.overlap = totalRadius - dist;
        response.overlapN.copy(differenceV.normalize());
        response.overlapV.copy(differenceV).scale(response.overlap);
        response.aInB = radiusA <= radiusB && dist <= radiusB - radiusA;
        response.bInA = radiusB <= radiusA && dist <= radiusA - radiusB;
    }
    T_VECTORS.push(differenceV);
    return true;
}

/**
 * Check if a polygon and an ellipse collide.
 * @ignore
 * @param {Renderable} a a reference to the object A.
 * @param {Polygon} polyA a reference to the object A Polygon to be tested
 * @param {Renderable} b a reference to the object B.
 * @param {Ellipse} ellipseB a reference to the object B Ellipse to be tested
 * @param {Response=} response Response object (optional) that will be populated if they intersect.
 * @returns {boolean} true if they intersect, false if they don't.
 */
function testPolygonEllipse(a, polyA, b, ellipseB, response) {
    // Get the position of the circle relative to the polygon.
    var circlePos = T_VECTORS.pop().copy(b.pos).add(b.ancestor.getAbsolutePosition()).add(ellipseB.pos)
        .sub(a.pos).add(a.ancestor.getAbsolutePosition()).sub(polyA.pos);
    var radius = ellipseB.radius;
    var radius2 = radius * radius;
    var points = polyA.points;
    var edges = polyA.edges;
    var len = edges.length;
    var edge = T_VECTORS.pop();
    var normal = T_VECTORS.pop();
    var point = T_VECTORS.pop();
    var dist = 0;

    // For each edge in the polygon:
    for (var i = 0; i < len; i++) {
        var next = i === len - 1 ? 0 : i + 1;
        var prev = i === 0 ? len - 1 : i - 1;
        var overlap = 0;
        var overlapN = null;

        // Get the edge.
        edge.copy(edges[i]);
        // Calculate the center of the circle relative to the starting point of the edge.
        point.copy(circlePos).sub(points[i]);

        // If the distance between the center of the circle and the point
        // is bigger than the radius, the polygon is definitely not fully in
        // the circle.
        if (response && point.length2() > radius2) {
            response.aInB = false;
        }

        // Calculate which Vornoi region the center of the circle is in.
        var region = vornoiRegion(edge, point);
        var inRegion = true;
        // If it's the left region:
        if (region === LEFT_VORNOI_REGION) {
            var point2 = null;
            if (len > 1) {
                // We need to make sure we're in the RIGHT_VORNOI_REGION of the previous edge.
                edge.copy(edges[prev]);
                // Calculate the center of the circle relative the starting point of the previous edge
                point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);
                region = vornoiRegion(edge, point2);
                if (region !== RIGHT_VORNOI_REGION) {
                    inRegion = false;
                }
            }

            if (inRegion) {
                // It's in the region we want.  Check if the circle intersects the point.
                dist = point.length();
                if (dist > radius) {
                    // No intersection
                    T_VECTORS.push(circlePos);
                    T_VECTORS.push(edge);
                    T_VECTORS.push(normal);
                    T_VECTORS.push(point);
                    if (point2) {
                        T_VECTORS.push(point2);
                    }
                    return false;
                } else if (response) {
                    // It intersects, calculate the overlap.
                    response.bInA = false;
                    overlapN = point.normalize();
                    overlap = radius - dist;
                }
            }

            if (point2) {
                T_VECTORS.push(point2);
            }
        // If it's the right region:
        } else if (region === RIGHT_VORNOI_REGION) {
            if (len > 1) {
                // We need to make sure we're in the left region on the next edge
                edge.copy(edges[next]);
                // Calculate the center of the circle relative to the starting point of the next edge.
                point.copy(circlePos).sub(points[next]);
                region = vornoiRegion(edge, point);
                if (region !== LEFT_VORNOI_REGION) {
                    inRegion = false;
                }
            }

            if (inRegion) {
                // It's in the region we want.  Check if the circle intersects the point.
                dist = point.length();
                if (dist > radius) {
                    // No intersection
                    T_VECTORS.push(circlePos);
                    T_VECTORS.push(edge);
                    T_VECTORS.push(normal);
                    T_VECTORS.push(point);
                    return false;
                } else if (response) {
                    // It intersects, calculate the overlap.
                    response.bInA = false;
                    overlapN = point.normalize();
                    overlap = radius - dist;
                }
            }
        // Otherwise, it's the middle region:
        } else {
            // Need to check if the circle is intersecting the edge,
            // Get the normal.
            normal.copy(polyA.normals[i]);
            // Find the perpendicular distance between the center of the
            // circle and the edge.
            dist = point.dot(normal);
            var distAbs = Math.abs(dist);
            // If the circle is on the outside of the edge, there is no intersection.
            if ((len === 1 || dist > 0) && distAbs > radius) {
                // No intersection
                T_VECTORS.push(circlePos);
                T_VECTORS.push(edge);
                T_VECTORS.push(normal);
                T_VECTORS.push(point);
                return false;
            } else if (response) {
                // It intersects, calculate the overlap.
                overlapN = normal;
                overlap = radius - dist;
                // If the center of the circle is on the outside of the edge, or part of the
                // circle is on the outside, the circle is not fully inside the polygon.
                if (dist >= 0 || overlap < 2 * radius) {
                    response.bInA = false;
                }
            }
        }

        // If this is the smallest overlap we've seen, keep it.
        // (overlapN may be null if the circle was in the wrong Vornoi region).
        if (overlapN && response && Math.abs(overlap) < Math.abs(response.overlap)) {
            response.overlap = overlap;
            response.overlapN.copy(overlapN);
        }
    }

    // Calculate the final overlap vector - based on the smallest overlap.
    if (response) {
        response.a = a;
        response.b = b;
        response.overlapV.copy(response.overlapN).scale(response.overlap);
    }
    T_VECTORS.push(circlePos);
    T_VECTORS.push(edge);
    T_VECTORS.push(normal);
    T_VECTORS.push(point);
    return true;
}

/**
 * Check if an ellipse and a polygon collide. <br>
 * **NOTE:** This is slightly less efficient than testPolygonEllipse as it just
 * runs testPolygonEllipse and reverses the response at the end.
 * @ignore
 * @param {Renderable} a a reference to the object A.
 * @param {Ellipse} ellipseA a reference to the object A Ellipse to be tested
 * @param {Renderable} b a reference to the object B.
 * @param {Polygon} polyB a reference to the object B Polygon to be tested
 * @param {Response=} response Response object (optional) that will be populated if
 *   they intersect.
 * @returns {boolean} true if they intersect, false if they don't.
 */
function testEllipsePolygon(a, ellipseA, b, polyB, response) {
    // Test the polygon against the circle.
    var result = testPolygonEllipse(b, polyB, a, ellipseA, response);
    if (result && response) {
        // Swap A and B in the response.
        var resa = response.a;
        var aInB = response.aInB;
        response.overlapN.negateSelf();
        response.overlapV.negateSelf();
        response.a = response.b;
        response.b = resa;
        response.aInB = response.bInA;
        response.bInA = aInB;
    }
    return result;
}

var SAT = /*#__PURE__*/Object.freeze({
	__proto__: null,
	testPolygonPolygon: testPolygonPolygon,
	testEllipseEllipse: testEllipseEllipse,
	testPolygonEllipse: testPolygonEllipse,
	testEllipsePolygon: testEllipsePolygon
});

/**
 * @classdesc
 * An object representing the result of an intersection.
 * @property {Renderable} a The first object participating in the intersection
 * @property {Renderable} b The second object participating in the intersection
 * @property {number} overlap Magnitude of the overlap on the shortest colliding axis
 * @property {Vector2d} overlapV The overlap vector (i.e. `overlapN.scale(overlap, overlap)`). If this vector is subtracted from the position of a, a and b will no longer be colliding
 * @property {Vector2d} overlapN The shortest colliding axis (unit-vector)
 * @property {boolean} aInB Whether the first object is entirely inside the second
 * @property {boolean} bInA Whether the second object is entirely inside the first
 * @property {number} indexShapeA The index of the colliding shape for the object a body
 * @property {number} indexShapeB The index of the colliding shape for the object b body
 * @name ResponseObject
 * @public
 */
class ResponseObject {
    constructor() {
        this.a = null;
        this.b = null;
        this.overlapN = new Vector2d();
        this.overlapV = new Vector2d();
        this.aInB = true;
        this.bInA = true;
        this.indexShapeA = -1;
        this.indexShapeB = -1;
        this.overlap = Number.MAX_VALUE;
    }

    /**
     * Set some values of the response back to their defaults. <br>
     * Call this between tests if you are going to reuse a single <br>
     * Response object for multiple intersection tests <br>
     * (recommended as it will avoid allocating extra memory) <br>
     * @name clear
     * @public
     * @returns {object} this object for chaining
     */
    clear () {
        this.aInB = true;
        this.bInA = true;
        this.overlap = Number.MAX_VALUE;
        this.indexShapeA = -1;
        this.indexShapeB = -1;
        return this;
    }
}

// a dummy object when using Line for raycasting
let dummyObj = {
    pos : new Vector2d(0, 0),
    ancestor : {
        _absPos : new Vector2d(0, 0),
        getAbsolutePosition : function () {
            return this._absPos;
        }
    }
};

// the global response object used for collisions
let globalResponse = new ResponseObject();

/**
 * a function used to determine if two objects should collide (based on both respective objects collision mask and type).<br>
 * you can redefine this function if you need any specific rules over what should collide with what.
 * @name shouldCollide
 * @memberof collision
 * @ignore
 * @param {Renderable} a a reference to the object A.
 * @param {Renderable} b a reference to the object B.
 * @returns {boolean} true if they should collide, false otherwise
 */
function shouldCollide(a, b) {
    return (
        a.isKinematic !== true && b.isKinematic !== true &&
        typeof a.body === "object" && typeof b.body === "object" &&
        !(a.body.isStatic === true && b.body.isStatic === true) &&
        (a.body.collisionMask & b.body.collisionType) !== 0 &&
        (a.body.collisionType & b.body.collisionMask) !== 0
    );
}


/**
 * find all the collisions for the specified object
 * @name collisionCheck
 * @ignore
 * @param {Renderable} objA object to be tested for collision
 * @param {ResponseObject} [response] a user defined response object that will be populated if they intersect.
 * @returns {boolean} in case of collision, false otherwise
 */
function collisionCheck(objA, response = globalResponse) {
    var collisionCounter = 0;
    // retreive a list of potential colliding objects from the game world
    var candidates = world.broadphase.retrieve(objA);

    for (var i = candidates.length, objB; i--, (objB = candidates[i]);) {

        // check if both objects "should" collide
        if ((objB !== objA) && shouldCollide(objA, objB) &&
            // fast AABB check if both bounding boxes are overlaping
            objA.body.getBounds().overlaps(objB.body.getBounds())) {

            // go trough all defined shapes in A
            var aLen = objA.body.shapes.length;
            var bLen = objB.body.shapes.length;
            if (aLen === 0 || bLen === 0) {
                continue;
            }

            var indexA = 0;
            do {
                var shapeA = objA.body.getShape(indexA);
                // go through all defined shapes in B
                var indexB = 0;
                do {
                    var shapeB = objB.body.getShape(indexB);

                    // full SAT collision check
                    if (SAT["test" + shapeA.shapeType + shapeB.shapeType]
                        .call(
                            this,
                            objA, // a reference to the object A
                            shapeA,
                            objB,  // a reference to the object B
                            shapeB,
                             // clear response object before reusing
                            response.clear()) === true
                    ) {
                        // we touched something !
                        collisionCounter++;

                        // set the shape index
                        response.indexShapeA = indexA;
                        response.indexShapeB = indexB;

                        // execute the onCollision callback
                        if (objA.onCollision && objA.onCollision(response, objB) !== false && objA.body.isStatic === false) {
                            objA.body.respondToCollision.call(objA.body, response);
                        }
                        if (objB.onCollision && objB.onCollision(response, objA) !== false && objB.body.isStatic === false) {
                            objB.body.respondToCollision.call(objB.body, response);
                        }
                    }
                    indexB++;
                } while (indexB < bLen);
                indexA++;
            } while (indexA < aLen);
        }
    }
    // we could return the amount of objects we collided with ?
    return collisionCounter > 0;
}
/**
 * Checks for object colliding with the given line
 * @name rayCast
 * @ignore
 * @param {Line} line line to be tested for collision
 * @param {Array.<Renderable>} [result] a user defined array that will be populated with intersecting physic objects.
 * @returns {Array.<Renderable>} an array of intersecting physic objects
 * @example
 *    // define a line accross the viewport
 *    var ray = new me.Line(
 *        // absolute position of the line
 *        0, 0, [
 *        // starting point relative to the initial position
 *        new me.Vector2d(0, 0),
 *        // ending point
 *        new me.Vector2d(me.game.viewport.width, me.game.viewport.height)
 *    ]);
 *
 *    // check for collition
 *    result = me.collision.rayCast(ray);
 *
 *    if (result.length > 0) {
 *        // ...
 *    }
 */
function rayCast(line, result = []) {
    var collisionCounter = 0;

    // retrieve a list of potential colliding objects from the game world
    var candidates = world.broadphase.retrieve(line);

    for (var i = candidates.length, objB; i--, (objB = candidates[i]);) {

        // fast AABB check if both bounding boxes are overlaping
        if (objB.body && line.getBounds().overlaps(objB.getBounds())) {

            // go trough all defined shapes in B (if any)
            var bLen = objB.body.shapes.length;
            if ( objB.body.shapes.length === 0) {
                continue;
            }

            var shapeA = line;

            // go through all defined shapes in B
            var indexB = 0;
            do {
                var shapeB = objB.body.getShape(indexB);

                // full SAT collision check
                if (SAT["test" + shapeA.shapeType + shapeB.shapeType]
                    .call(
                        this,
                        dummyObj, // a reference to the object A
                        shapeA,
                        objB,  // a reference to the object B
                        shapeB
                )) {
                    // we touched something !
                    result[collisionCounter] = objB;
                    collisionCounter++;
                }
                indexB++;
            } while (indexB < bLen);
        }
    }

    // cap result in case it was not empty
    result.length = collisionCounter;

    // return the list of colliding objects
    return result;
}

/**
 * Collision detection (and projection-based collision response) of 2D shapes.<br>
 * Based on the Separating Axis Theorem and supports detecting collisions between simple Axis-Aligned Boxes, convex polygons and circles based shapes.
 * @namespace collision
 */

var collision = {

     /**
      * The maximum number of children that a quadtree node can contain before it is split into sub-nodes.
      * @name maxChildren
      * @memberof collision
      * @public
      * @type {number}
      * @default 8
      * @see game.world.broadphase
      */
     maxChildren : 8,

     /**
      * The maximum number of levels that the quadtree will create.
      * @name maxDepth
      * @memberof collision
      * @public
      * @type {number}
      * @default 4
      * @see game.world.broadphase
      */
     maxDepth : 4,

    /**
     * Enum for collision type values.
     * @property {number} NO_OBJECT to disable collision check
     * @property {number} PLAYER_OBJECT playbable characters
     * @property {number} NPC_OBJECT non playable characters
     * @property {number} ENEMY_OBJECT enemies objects
     * @property {number} COLLECTABLE_OBJECT collectable objects
     * @property {number} ACTION_OBJECT e.g. doors
     * @property {number} PROJECTILE_OBJECT e.g. missiles
     * @property {number} WORLD_SHAPE e.g. walls; for map collision shapes
     * @property {number} USER user-defined collision types (see example)
     * @property {number} ALL_OBJECT all of the above (including user-defined types)
     * @readonly
     * @enum {number}
     * @name types
     * @memberof collision
     * @see Body.setCollisionMask
     * @see Body.collisionType
     * @example
     * // set the body collision type
     * myEntity.body.collisionType = me.collision.types.PLAYER_OBJECT;
     *
     * // filter collision detection with collision shapes, enemies and collectables
     * myEntity.body.setCollisionMask(
     *     me.collision.types.WORLD_SHAPE |
     *     me.collision.types.ENEMY_OBJECT |
     *     me.collision.types.COLLECTABLE_OBJECT
     * );
     *
     * // User-defined collision types are defined using BITWISE LEFT-SHIFT:
     * game.collisionTypes = {
     *     LOCKED_DOOR : me.collision.types.USER << 0,
     *     OPEN_DOOR   : me.collision.types.USER << 1,
     *     LOOT        : me.collision.types.USER << 2,
     * };
     *
     * // Set collision type for a door entity
     * myDoorEntity.body.collisionType = game.collisionTypes.LOCKED_DOOR;
     *
     * // Set collision mask for the player entity, so it collides with locked doors and loot
     * myPlayerEntity.body.setCollisionMask(
     *     me.collision.types.ENEMY_OBJECT |
     *     me.collision.types.WORLD_SHAPE |
     *     game.collisionTypes.LOCKED_DOOR |
     *     game.collisionTypes.LOOT
     * );
     */
    types : {
        /** to disable collision check */
        NO_OBJECT           : 0,
        PLAYER_OBJECT       : 1 << 0,
        NPC_OBJECT          : 1 << 1,
        ENEMY_OBJECT        : 1 << 2,
        COLLECTABLE_OBJECT  : 1 << 3,
        ACTION_OBJECT       : 1 << 4, // door, etc...
        PROJECTILE_OBJECT   : 1 << 5, // missiles, etc...
        WORLD_SHAPE         : 1 << 6, // walls, etc...
        USER                : 1 << 7, // user-defined types start here...
        ALL_OBJECT          : 0xFFFFFFFF // all objects
    },

    /**
     * Checks for object colliding with the given line
     * @name rayCast
     * @memberof collision
     * @public
     * @param {Line} line line to be tested for collision
     * @param {Array.<Renderable>} [result] a user defined array that will be populated with intersecting physic objects.
     * @returns {Array.<Renderable>} an array of intersecting physic objects
     * @example
     *    // define a line accross the viewport
     *    var ray = new me.Line(
     *        // absolute position of the line
     *        0, 0, [
     *        // starting point relative to the initial position
     *        new me.Vector2d(0, 0),
     *        // ending point
     *        new me.Vector2d(me.game.viewport.width, me.game.viewport.height)
     *    ]);
     *
     *    // check for collition
     *    result = me.collision.rayCast(ray);
     *
     *    if (result.length > 0) {
     *        // ...
     *    }
     */
    rayCast(line, result) { return rayCast(line, result); }
};

/**
 * @classdesc
 * a Generic Physic Body Object with some physic properties and behavior functionality, to as a member of a Renderable.
 * @see Renderable.body
 */
class Body {
    /**
     * @param {Renderable} ancestor the parent object this body is attached to
     * @param {Rect|Rect[]|Polygon|Polygon[]|Line|Line[]|Ellipse|Ellipse[]|Bounds|Bounds[]|object} [shapes] a initial shape, list of shapes, or JSON object defining the body
     * @param {Function} [onBodyUpdate] callback for when the body is updated (e.g. add/remove shapes)
     */
    constructor(ancestor, shapes, onBodyUpdate) {

        /**
         * a reference to the parent object that contains this body,
         * or undefined if it has not been added to one.
         * @public
         * @type {Renderable}
         * @default undefined
         */
        this.ancestor = ancestor;

        if (typeof this.bounds === "undefined") {
            /**
             * The AABB bounds box reprensenting this body
             * @public
             * @type {Bounds}
             */
            this.bounds = pool.pull("Bounds");
        }

        if (typeof this.shapes === "undefined") {
            /**
             * The collision shapes of the body
             * @ignore
             * @type {Polygon[]|Line[]|Ellipse[]}
             */
            this.shapes = [];
        }

        /**
         * The body collision mask, that defines what should collide with what.<br>
         * (by default will collide with all entities)
         * @ignore
         * @type {number}
         * @default collision.types.ALL_OBJECT
         * @see collision.types
         */
        this.collisionMask = collision.types.ALL_OBJECT;

        /**
         * define the collision type of the body for collision filtering
         * @public
         * @type {number}
         * @default collision.types.ENEMY_OBJECT
         * @see collision.types
         * @example
         * // set the body collision type
         * body.collisionType = me.collision.types.PLAYER_OBJECT;
         */
        this.collisionType = collision.types.ENEMY_OBJECT;

        if (typeof this.vel === "undefined") {
            /**
             * body velocity
             * @public
             * @type {Vector2d}
             * @default <0,0>
             */
            this.vel = pool.pull("Vector2d");
        }
        this.vel.set(0, 0);

        if (typeof this.force === "undefined") {
            /**
             * body force or acceleration (automatically) applied to the body.
             * when defining a force, user should also define a max velocity
             * @public
             * @type {Vector2d}
             * @default <0,0>
             * @see Body.setMaxVelocity
             * @example
             * // define a default maximum acceleration, initial force and friction
             * this.body.force.set(0, 0);
             * this.body.friction.set(0.4, 0);
             * this.body.setMaxVelocity(3, 15);
             *
             * // apply a postive or negative force when pressing left of right key
             * update(dt) {
             *     if (me.input.isKeyPressed("left"))    {
             *          this.body.force.x = -this.body.maxVel.x;
             *      } else if (me.input.isKeyPressed("right")) {
             *         this.body.force.x = this.body.maxVel.x;
             *     } else {
             *         this.body.force.x = 0;
             *     }
             * }
             */
            this.force = pool.pull("Vector2d");
        }
        this.force.set(0, 0);

        if (typeof this.friction === "undefined") {
            /**
             * body friction
             * @public
             * @type {Vector2d}
             * @default <0,0>
             */
            this.friction = pool.pull("Vector2d");
        }
        this.friction.set(0, 0);

        /**
         * the body bouciness level when colliding with other solid bodies :
         * a value of 0 will not bounce, a value of 1 will fully rebound.
         * @public
         * @type {number}
         * @default 0
         */
        this.bounce = 0;

        /**
         * the body mass
         * @public
         * @type {number}
         * @default 1
         */
        this.mass = 1;

        if (typeof this.maxVel === "undefined") {
            /**
             * max velocity (to limit body velocity)
             * @public
             * @type {Vector2d}
             * @default <490,490>
             */
            this.maxVel = pool.pull("Vector2d");
        }
        // cap by default to half the default gravity force
        this.maxVel.set(490, 490);


        /**
         * Either this body is a static body or not.
         * A static body is completely fixed and can never change position or angle.
         * @readonly
         * @public
         * @type {boolean}
         * @default false
         */
        this.isStatic = false;


        /**
         * The degree to which this body is affected by the world gravity
         * @public
         * @see World.gravity
         * @type {number}
         * @default 1.0
         */
        this.gravityScale = 1.0;

        /**
         * If true this body won't be affected by the world gravity
         * @public
         * @see World.gravity
         * @type {boolean}
         * @default false
         */
        this.ignoreGravity = false;

        /**
         * falling state of the body<br>
         * true if the object is falling<br>
         * false if the object is standing on something<br>
         * @readonly
         * @public
         * @type {boolean}
         * @default false
         */
        this.falling = false;

        /**
         * jumping state of the body<br>
         * equal true if the body is jumping<br>
         * @readonly
         * @public
         * @type {boolean}
         * @default false
         */
        this.jumping = false;


        if (typeof onBodyUpdate === "function") {
            this.onBodyUpdate = onBodyUpdate;
        }

        this.bounds.clear();

        // parses the given shapes array and add them
        if (typeof shapes !== "undefined") {
            if (Array.isArray(shapes)) {
                for (var s = 0; s < shapes.length; s++) {
                    this.addShape(shapes[s]);
                }
            } else {
                this.addShape(shapes);
            }
        }

        // automatically enable physic when a body is added to a renderable
        this.ancestor.isKinematic = false;
    }

    /**
     * set the body as a static body
     * static body do not move automatically and do not check againt collision with others
     * @param {boolean} [isStatic=true]
     */
    setStatic(isStatic = true) {
        this.isStatic = isStatic === true;
    }

    /**
     * add a collision shape to this body <br>
     * (note: me.Rect objects will be converted to me.Polygon before being added)
     * @param {Rect|Polygon|Line|Ellipse|Bounds|object} shape a shape or JSON object
     * @returns {number} the shape array length
     * @example
     * // add a rectangle shape
     * this.body.addShape(new me.Rect(0, 0, image.width, image.height));
     * // add a shape from a JSON object
     * this.body.addShape(me.loader.getJSON("shapesdef").banana);
     */
    addShape(shape) {
        if (shape instanceof Rect || shape instanceof Bounds) {
            var poly = shape.toPolygon();
            this.shapes.push(poly);
            // update the body bounds
            this.bounds.add(poly.points);
            this.bounds.translate(poly.pos);
        } else if (shape instanceof Ellipse) {
            if (!this.shapes.includes(shape)) {
                // see removeShape
                this.shapes.push(shape);
            }
            // update the body bounds
            this.bounds.addBounds(shape.getBounds());
            // use bounds position as ellipse position is center
            this.bounds.translate(
                shape.getBounds().x,
                shape.getBounds().y
            );
        } else if (shape instanceof Polygon) {
            if (!this.shapes.includes(shape)) {
                // see removeShape
                this.shapes.push(shape);
            }
            // update the body bounds
            this.bounds.add(shape.points);
            this.bounds.translate(shape.pos);
        } else {
            // JSON object
            this.fromJSON(shape);
        }

        if (typeof this.onBodyUpdate === "function") {
            this.onBodyUpdate(this);
        }

        // return the length of the shape list
        return this.shapes.length;
    }

    /**
     * set the body vertices to the given one
     * @param {Vector2d[]} vertices an array of me.Vector2d points defining a convex hull
     * @param {number} [index=0] the shape object for which to set the vertices
     * @param {boolean} [clear=true] either to reset the body definition before adding the new vertices
     */
    setVertices(vertices, index = 0, clear = true) {
        var polygon = this.getShape(index);
        if (polygon instanceof Polygon) {
            polygon.setShape(0, 0, vertices);
        } else {
            // this will replace any other non polygon shape type if defined
            this.shapes[index] = pool.pull("Polygon", 0, 0, vertices);
        }

        // update the body bounds to take in account the new vertices
        this.bounds.add(this.shapes[index].points, clear);

        if (typeof this.onBodyUpdate === "function") {
            this.onBodyUpdate(this);
        }
    }

    /**
     * add the given vertices to the body shape
     * @param {Vector2d[]} vertices an array of me.Vector2d points defining a convex hull
     * @param {number} [index=0] the shape object for which to set the vertices
     */
    addVertices(vertices, index = 0) {
        this.setVertices(vertices, index, false);
    }

    /**
     * add collision mesh based on a JSON object
     * (this will also apply any physic properties defined in the given JSON file)
     * @param {object} json a JSON object as exported from a Physics Editor tool
     * @param {string} [id] an optional shape identifier within the given the json object
     * @see https://www.codeandweb.com/physicseditor
     * @returns {number} how many shapes were added to the body
     * @example
     * // define the body based on the banana shape
     * this.body.fromJSON(me.loader.getJSON("shapesdef").banana);
     * // or ...
     * this.body.fromJSON(me.loader.getJSON("shapesdef"), "banana");
     */
    fromJSON(json, id) {
        var data = json;

        if (typeof id !== "undefined" ) {
            data = json[id];
        }

        // Physic Editor Format (https://www.codeandweb.com/physicseditor)
        if (typeof data === "undefined") {
            throw new Error("Identifier (" + id + ") undefined for the given JSON object)");
        }

        if (data.length) {
            // go through all shapes and add them to the body
            for (var i = 0; i < data.length; i++) {
                this.addVertices(data[i].shape, i);
            }
            // apply density, friction and bounce properties from the first shape
            // Note : how to manage different mass or friction for all different shapes?
            this.mass = data[0].density || 0;
            this.friction.set(data[0].friction || 0, data[0].friction || 0);
            this.bounce = data[0].bounce || 0;
        }

        // return the amount of shapes added to the body
        return data.length;
    }

    /**
     * return the collision shape at the given index
     * @param {number} [index=0] the shape object at the specified index
     * @returns {Polygon|Line|Ellipse} shape a shape object if defined
     */
    getShape(index) {
        return this.shapes[index || 0];
    }

    /**
     * returns the AABB bounding box for this body
     * @returns {Bounds} bounding box Rectangle object
     */
    getBounds() {
        return this.bounds;
    }

    /**
     * remove the specified shape from the body shape list
     * @param {Polygon|Line|Ellipse} shape a shape object
     * @returns {number} the shape array length
     */
    removeShape(shape) {
        // clear the current bounds
        this.bounds.clear();
        // remove the shape from shape list
        remove(this.shapes, shape);
        // add everything left back
        for (var s = 0; s < this.shapes.length; s++) {
            this.addShape(this.shapes[s]);
        }
        // return the length of the shape list
        return this.shapes.length;
    }

    /**
     * remove the shape at the given index from the body shape list
     * @param {number} index the shape object at the specified index
     * @returns {number} the shape array length
     */
    removeShapeAt(index) {
        return this.removeShape(this.getShape(index));
    }

    /**
     * By default all physic bodies are able to collide with all other bodies, <br>
     * but it's also possible to specify 'collision filters' to provide a finer <br>
     * control over which body can collide with each other.
     * @see collision.types
     * @param {number} [bitmask = collision.types.ALL_OBJECT] the collision mask
     * @example
     * // filter collision detection with collision shapes, enemies and collectables
     * body.setCollisionMask(me.collision.types.WORLD_SHAPE | me.collision.types.ENEMY_OBJECT | me.collision.types.COLLECTABLE_OBJECT);
     * ...
     * // disable collision detection with all other objects
     * body.setCollisionMask(me.collision.types.NO_OBJECT);
     */
    setCollisionMask(bitmask = collision.types.ALL_OBJECT) {
        this.collisionMask = bitmask;
    }

    /**
     * define the collision type of the body for collision filtering
     * @see collision.types
     * @param {number} type the collision type
     * @example
     * // set the body collision type
     * body.collisionType = me.collision.types.PLAYER_OBJECT;
     */
    setCollisionType(type) {
        if (typeof type !== "undefined") {
            if (typeof collision.types[type] !== "undefined") {
                this.collisionType = collision.types[type];
            } else {
                throw new Error("Invalid value for the collisionType property");
            }
        }
    }

    /**
     * the built-in function to solve the collision response
     * @param {object} response the collision response object (see {@link ResponseObject})
     */
    respondToCollision(response) {
        // the overlap vector
        var overlap = response.overlapV;

        // FIXME: Respond proportionally to object mass

        // Move out of the other object shape
        this.ancestor.pos.sub(overlap);

        // adjust velocity
        if (overlap.x !== 0) {
            this.vel.x = ~~(0.5 + this.vel.x - overlap.x) || 0;
            if (this.bounce > 0) {
                this.vel.x *= -this.bounce;
            }
        }
        if (overlap.y !== 0) {
            this.vel.y = ~~(0.5 + this.vel.y - overlap.y) || 0;
            if (this.bounce > 0) {
                this.vel.y *= -this.bounce;
            }

            // cancel the falling an jumping flags if necessary
            var dir = Math.sign(world.gravity.y * this.gravityScale) || 1;
            this.falling = overlap.y >= dir;
            this.jumping = overlap.y <= -dir;
        }
    }

    /**
     * The forEach() method executes a provided function once per body shape element. <br>
     * the callback function is invoked with three arguments: <br>
     *    - The current element being processed in the array <br>
     *    - The index of element in the array. <br>
     *    - The array forEach() was called upon. <br>
     * @param {Function} callback fnction to execute on each element
     * @param {object} [thisArg] value to use as this(i.e reference Object) when executing callback.
     * @example
     * // iterate through all shapes of the physic body
     * mySprite.body.forEach((shape) => {
     *    shape.doSomething();
     * });
     * mySprite.body.forEach((shape, index) => { ... });
     * mySprite.body.forEach((shape, index, array) => { ... });
     * mySprite.body.forEach((shape, index, array) => { ... }, thisArg);
     */
    forEach(callback, thisArg) {
        var context = this, i = 0;
        var shapes = this.shapes;

        var len = shapes.length;

        if (typeof callback !== "function") {
            throw new Error(callback + " is not a function");
        }

        if (arguments.length > 1) {
            context = thisArg;
        }

        while (i < len) {
            callback.call(context, shapes[i], i, shapes);
            i++;
        }
    }


    /**
     * Returns true if the any of the shape composing the body contains the given point.
     * @method Body#contains
     * @param {Vector2d} point
     * @returns {boolean} true if contains
     */

    /**
     * Returns true if the any of the shape composing the body contains the given point.
     * @param  {number} x x coordinate
     * @param  {number} y y coordinate
     * @returns {boolean} true if contains
     */
    contains() {
        var _x, _y;

        if (arguments.length === 2) {
          // x, y
          _x = arguments[0];
          _y = arguments[1];
        } else {
          // vector
          _x = arguments[0].x;
          _y = arguments[0].y;
        }

        if (this.getBounds().contains(_x, _y)) {
             // cannot use forEach here as cannot break out with a return
             for (var i = this.shapes.length, shape; i--, (shape = this.shapes[i]);) {
                if (shape.contains(_x, _y)) {
                    return true;
                }
            }        }
        return false;
    }

    /**
     * Rotate this body (counter-clockwise) by the specified angle (in radians).
     * Unless specified the body will be rotated around its center point
     * @param {number} angle The angle to rotate (in radians)
     * @param {Vector2d|ObservableVector2d} [v=Body.getBounds().center] an optional point to rotate around
     * @returns {Body} Reference to this object for method chaining
     */
    rotate(angle, v = this.getBounds().center) {
        this.bounds.clear();
        this.forEach((shape) => {
            shape.rotate(angle, v);
            this.bounds.addBounds(shape.getBounds());
            if (shape instanceof Ellipse) {
                // use bounds position as ellipse position is center
                this.bounds.translate(
                    shape.getBounds().x,
                    shape.getBounds().y
                );
            } else {
                this.bounds.translate(shape.pos);
            }
        });
        return this;
    }

    /**
     * cap the body velocity (body.maxVel property) to the specified value<br>
     * @param {number} x max velocity on x axis
     * @param {number} y max velocity on y axis
     */
    setMaxVelocity(x, y) {
        this.maxVel.x = x;
        this.maxVel.y = y;
    }

    /**
     * set the body default friction
     * @param {number} x horizontal friction
     * @param {number} y vertical friction
     */
    setFriction(x = 0, y = 0) {
        this.friction.x = x;
        this.friction.y = y;
    }

    /**
     * compute the new velocity value
     * @ignore
     */
    computeVelocity(/* dt */) {
        // apply timer.tick to delta time for linear interpolation (when enabled)
        // #761 add delta time in body update
        var deltaTime = /* dt * */ timer.tick;

        // apply gravity to the current velocity
        if (!this.ignoreGravity) {
            var worldGravity = world.gravity;

            // apply gravity if defined
            this.vel.x += worldGravity.x * this.gravityScale * deltaTime;
            this.vel.y += worldGravity.y * this.gravityScale * deltaTime;

            // check if falling / jumping
            this.falling = (this.vel.y * Math.sign(worldGravity.y * this.gravityScale)) > 0;
            this.jumping = (this.falling ? false : this.jumping);
        }

        // apply force if defined
        if (this.force.x !== 0) {
            this.vel.x += this.force.x * deltaTime;
        }
        if (this.force.y !== 0) {
            this.vel.y += this.force.y * deltaTime;
        }

        // apply friction if defined
        if (this.friction.x > 0) {
            var fx = this.friction.x * deltaTime,
                nx = this.vel.x + fx,
                x = this.vel.x - fx;

            this.vel.x = (
                (nx < 0) ? nx :
                ( x > 0) ? x  : 0
            );
        }
        if (this.friction.y > 0) {
            var fy = this.friction.y * deltaTime,
                ny = this.vel.y + fy,
                y = this.vel.y - fy;

            this.vel.y = (
                (ny < 0) ? ny :
                ( y > 0) ? y  : 0
            );
        }

        // cap velocity
        if (this.vel.y !== 0) {
            this.vel.y = clamp(this.vel.y, -this.maxVel.y, this.maxVel.y);
        }
        if (this.vel.x !== 0) {
            this.vel.x = clamp(this.vel.x, -this.maxVel.x, this.maxVel.x);
        }
    }

    /**
     * Updates the parent's position as well as computes the new body's velocity based
     * on the values of force/friction/gravity.  Velocity chages are proportional to the
     * me.timer.tick value (which can be used to scale velocities).  The approach to moving the
     * parent renderable is to compute new values of the Body.vel property then add them to
     * the parent.pos value thus changing the postion the amount of Body.vel each time the
     * update call is made. <br>
     * Updates to Body.vel are bounded by maxVel (which defaults to viewport size if not set) <br>
     *
     * In addition, when the gravity calcuation is made, if the Body.vel.y > 0 then the Body.falling
     * property is set to true and Body.jumping is set to !Body.falling.
     *
     * At this time a call to Body.Update does not call the onBodyUpdate callback that is listed in the constructor arguments.
     * @protected
     * @param {number} dt time since the last update in milliseconds.
     * @returns {boolean} true if resulting velocity is different than 0
     */
    update(dt) {
        // update the velocity
        this.computeVelocity(dt);

        // update the body ancestor position
        this.ancestor.pos.add(this.vel);

        // returns true if vel is different from 0
        return (this.vel.x !== 0 || this.vel.y !== 0);
    }

    /**
     * Destroy function<br>
     * @ignore
     */
    destroy() {
        // push back instance into object pool
        pool.push(this.bounds);
        pool.push(this.vel);
        pool.push(this.force);
        pool.push(this.friction);
        pool.push(this.maxVel);
        this.shapes.forEach((shape) => {
            pool.push(shape, false);
        });

        // set to undefined
        this.onBodyUpdate = undefined;
        this.ancestor = undefined;
        this.bounds = undefined;
        this.vel = undefined;
        this.force = undefined;
        this.friction = undefined;
        this.maxVel = undefined;
        this.shapes.length = 0;

        // reset some variable to default
        this.setStatic(false);
    }
}

/**
 * Private function to re-use for object removal in a defer
 * @ignore
 */
var deferredRemove = function (child, keepalive) {
    this.removeChildNow(child, keepalive);
};

var globalFloatingCounter = 0;

/**
 * @classdesc
 * Container represents a collection of child objects
 * @augments Renderable
 */
class Container extends Renderable {
    /**
     * @param {number} [x=0] position of the container (accessible via the inherited pos.x property)
     * @param {number} [y=0] position of the container (accessible via the inherited pos.y property)
     * @param {number} [width=game.viewport.width] width of the container
     * @param {number} [height=game.viewport.height] height of the container
     */
    constructor(x = 0, y = 0, width = viewport.width, height = viewport.height, root = false) {

        // call the super constructor
        super(x, y, width, height);

        /**
         * keep track of pending sort
         * @ignore
         */
        this.pendingSort = null;

        /**
         * whether the container is the root of the scene
         * @public
         * @type {boolean}
         * @default false
         * @name root
         * @memberof Container
         */
        this.root = root;

        /**
         * The array of children of this container.
         * @ignore
         */
        this.children = undefined;

        /**
         * The property of the child object that should be used to sort on <br>
         * value : "x", "y", "z"
         * @public
         * @type {string}
         * @default me.game.sortOn
         * @name sortOn
         * @memberof Container
         */
        this.sortOn = sortOn;

        /**
         * Specify if the children list should be automatically sorted when adding a new child
         * @public
         * @type {boolean}
         * @default true
         * @name autoSort
         * @memberof Container
         */
        this.autoSort = true;

        /**
         * Specify if the children z index should automatically be managed by the parent container
         * @public
         * @type {boolean}
         * @default true
         * @name autoDepth
         * @memberof Container
         */
        this.autoDepth = true;

        /**
         * Specify if the container draw operation should clip his children to its own bounds
         * @public
         * @type {boolean}
         * @default false
         * @name clipping
         * @memberof Container
         */
        this.clipping = false;

        /**
         * a callback to be extended, triggered after a child has been added or removed
         * @name onChildChange
         * @memberof Container#
         * @param {number} index added or removed child index
         */
        this.onChildChange = function (index) {   // eslint-disable-line no-unused-vars
            // to be extended
        };

        /**
         * Specify if the container bounds should automatically take in account
         * all child bounds when updated (this is expensive and disabled by default,
         * only enable if necessary)
         * @public
         * @type {boolean}
         * @default false
         * @name enableChildBoundsUpdate
         * @memberof Container
         */
        this.enableChildBoundsUpdate = false;

        /**
         * define a background color for this container
         * @public
         * @type {Color}
         * @name backgroundColor
         * @default (0, 0, 0, 0.0)
         * @memberof Container
         * @example
         * // add a red background color to this container
         * this.backgroundColor.setColor(255, 0, 0);
         */
        this.backgroundColor = pool.pull("Color", 0, 0, 0, 0.0);

        /**
         * Used by the debug panel plugin
         * @ignore
         */
        this.drawCount = 0;

        // container self apply any defined transformation
        this.autoTransform = true;

        // enable collision and event detection
        this.isKinematic = false;

        this.anchorPoint.set(0, 0);

        // subscribe on the canvas resize event
        if (this.root === true) {
            // Workaround for not updating container child-bounds automatically (it's expensive!)
            on(CANVAS_ONRESIZE, this.updateBounds.bind(this, true));
        }
    }

    /**
     * reset the container, removing all childrens, and reseting transforms.
     * @name reset
     * @memberof Container
     */
    reset() {
        // cancel any sort operation
        if (this.pendingSort) {
            clearTimeout(this.pendingSort);
            this.pendingSort = null;
        }

        // delete all children
        var children = this.getChildren();
        for (var i = children.length, child; i >= 0; (child = children[--i])) {
            // don't remove it if a persistent object
            if (child && child.isPersistent !== true) {
                this.removeChildNow(child);
            }
        }
        if (typeof this.currentTransform !== "undefined") {
            // just reset some variables
            this.currentTransform.identity();
        }

        this.backgroundColor.setColor(0, 0, 0, 0.0);
    }

    /**
     * Add a child to the container <br>
     * if auto-sort is disable, the object will be appended at the bottom of the list.
     * Adding a child to the container will automatically remove it from its other container.
     * Meaning a child can only have one parent.  This is important if you add a renderable
     * to a container then add it to the me.game.world container it will move it out of the
     * orginal container. Then when the me.game.world.reset() is called the renderable
     * will not be in any container. <br>
     * if the given child implements a onActivateEvent method, that method will be called
     * once the child is added to this container.
     * @name addChild
     * @memberof Container
     * @param {Renderable} child
     * @param {number} [z] forces the z index of the child to the specified value
     * @returns {Renderable} the added child
     */
    addChild(child, z) {
        if (child.ancestor instanceof Container) {
            child.ancestor.removeChildNow(child);
        }
        else {
            // only allocate a GUID if the object has no previous ancestor
            // (e.g. move one child from one container to another)
            if (child.isRenderable) {
                // allocated a GUID value (use child.id as based index if defined)
                child.GUID = utils.createGUID(child.id);
            }
        }

        child.ancestor = this;
        this.getChildren().push(child);

        // set the child z value if required
        if (typeof(child.pos) !== "undefined") {
            if (typeof(z) === "number") {
                    child.pos.z = z;
            } else if (this.autoDepth === true) {
                child.pos.z = this.getChildren().length;
            }
        }

        if (this.autoSort === true) {
            this.sort();
        }

        if (typeof child.onActivateEvent === "function" && this.isAttachedToRoot()) {
            child.onActivateEvent();
        }

        // force repaint in case this is a static non-animated object
        if (this.isAttachedToRoot() === true) {
            repaint();
        }

        // force bounds update if required
        if (this.enableChildBoundsUpdate) {
            this.updateBounds(true);
        }

        // if a physic body is defined, add it to the game world
        if (child.body instanceof Body) {
            world.addBody(child.body);
        }

        // triggered callback if defined
        this.onChildChange.call(this, this.getChildren().length - 1);

        return child;
    }

    /**
     * Add a child to the container at the specified index<br>
     * (the list won't be sorted after insertion)
     * @name addChildAt
     * @memberof Container
     * @param {Renderable} child
     * @param {number} index
     * @returns {Renderable} the added child
     */
    addChildAt(child, index) {
        if (index >= 0 && index < this.getChildren().length) {
            if (child.ancestor instanceof Container) {
                child.ancestor.removeChildNow(child);
            }
            else {
                // only allocate a GUID if the object has no previous ancestor
                // (e.g. move one child from one container to another)
                if (child.isRenderable) {
                    // allocated a GUID value
                    child.GUID = utils.createGUID();
                }
            }
            child.ancestor = this;

            this.getChildren().splice(index, 0, child);

            if (typeof child.onActivateEvent === "function" && this.isAttachedToRoot()) {
                child.onActivateEvent();
            }

            // force repaint in case this is a static non-animated object
            if (this.isAttachedToRoot() === true) {
                repaint();
            }

            // force bounds update if required
            if (this.enableChildBoundsUpdate) {
                this.updateBounds(true);
            }

            // if a physic body is defined, add it to the game world
            if (child.body instanceof Body) {
                world.addBody(child.body);
            }

            // triggered callback if defined
            this.onChildChange.call(this, index);

            return child;
        }
        else {
            throw new Error("Index (" + index + ") Out Of Bounds for addChildAt()");
        }
    }

    /**
     * The forEach() method executes a provided function once per child element. <br>
     * the callback function is invoked with three arguments: <br>
     *    - The current element being processed in the array <br>
     *    - The index of element in the array. <br>
     *    - The array forEach() was called upon. <br>
     * @name forEach
     * @memberof Container
     * @param {Function} callback fnction to execute on each element
     * @param {object} [thisArg] value to use as this(i.e reference Object) when executing callback.
     * @example
     * // iterate through all children of the root container
     * me.game.world.forEach((child) => {
     *    // do something with the child
     *    child.doSomething();
     * });
     * me.game.world.forEach((child, index) => { ... });
     * me.game.world.forEach((child, index, array) => { ... });
     * me.game.world.forEach((child, index, array) => { ... }, thisArg);
     */
    forEach(callback, thisArg) {
        var context = this, i = 0;
        var children = this.getChildren();

        var len = children.length;

        if (typeof callback !== "function") {
            throw new Error(callback + " is not a function");
        }

        if (arguments.length > 1) {
            context = thisArg;
        }

        while (i < len) {
            callback.call(context, children[i], i, children);
            i++;
        }
    }

    /**
     * Swaps the position (z-index) of 2 children
     * @name swapChildren
     * @memberof Container
     * @param {Renderable} child
     * @param {Renderable} child2
     */
    swapChildren(child, child2) {
        var index = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);

        if ((index !== -1) && (index2 !== -1)) {
            // swap z index
            var _z = child.pos.z;
            child.pos.z = child2.pos.z;
            child2.pos.z = _z;
            // swap the positions..
            this.getChildren()[index] = child2;
            this.getChildren()[index2] = child;
            // mark the container as dirty
            this.isDirty = true;
        }
        else {
            throw new Error(child + " Both the supplied childs must be a child of the caller " + this);
        }
    }

    /**
     * Returns the Child at the specified index
     * @name getChildAt
     * @memberof Container
     * @param {number} index
     * @returns {Renderable} the child at the specified index
     */
    getChildAt(index) {
        if (index >= 0 && index < this.getChildren().length) {
            return this.getChildren()[index];
        }
        else {
            throw new Error("Index (" + index + ") Out Of Bounds for getChildAt()");
        }
    }

    /**
     * Returns the index of the given Child
     * @name getChildIndex
     * @memberof Container
     * @param {Renderable} child
     * @returns {number} index
     */
    getChildIndex(child) {
        return this.getChildren().indexOf(child);
    }

    /**
     * Returns the next child within the container or undefined if none
     * @name getNextChild
     * @memberof Container
     * @param {Renderable} child
     * @returns {Renderable} child
     */
    getNextChild(child) {
        var index = this.getChildren().indexOf(child) - 1;
        if (index >= 0 && index < this.getChildren().length) {
            return this.getChildAt(index);
        }
        return undefined;
    }

    /**
     * Returns true if contains the specified Child
     * @name hasChild
     * @memberof Container
     * @param {Renderable} child
     * @returns {boolean}
     */
    hasChild(child) {
        return this === child.ancestor;
    }

    /**
     * return the child corresponding to the given property and value.<br>
     * note : avoid calling this function every frame since
     * it parses the whole object tree each time
     * @name getChildByProp
     * @memberof Container
     * @public
     * @param {string} prop Property name
     * @param {string|RegExp|number|boolean} value Value of the property
     * @returns {Renderable[]} Array of childs
     * @example
     * // get the first child object called "mainPlayer" in a specific container :
     * var ent = myContainer.getChildByProp("name", "mainPlayer");
     *
     * // or query the whole world :
     * var ent = me.game.world.getChildByProp("name", "mainPlayer");
     *
     * // partial property matches are also allowed by using a RegExp.
     * // the following matches "redCOIN", "bluecoin", "bagOfCoins", etc :
     * var allCoins = me.game.world.getChildByProp("name", /coin/i);
     *
     * // searching for numbers or other data types :
     * var zIndex10 = me.game.world.getChildByProp("z", 10);
     * var inViewport = me.game.world.getChildByProp("inViewport", true);
     */
    getChildByProp(prop, value)    {
        var objList = [];

        /**
         * @ignore
         */
        function compare(obj, prop) {
            var v = obj[prop];
            if (value instanceof RegExp && typeof(v) === "string") {
                if (value.test(v)) {
                    objList.push(obj);
                }
            }
            else if (v === value) {
                objList.push(obj);
            }
        }

        this.forEach((child) => {
            compare(child, prop);
            if (child instanceof Container) {
                objList = objList.concat(child.getChildByProp(prop, value));
            }
        });

        return objList;
    }

    /**
     * returns the list of childs with the specified class type
     * @name getChildByType
     * @memberof Container
     * @public
     * @param {object} classType
     * @returns {Renderable[]} Array of children
     */
    getChildByType(classType) {
        var objList = [];

        this.forEach((child) => {
            if (child instanceof classType) {
                objList.push(child);
            }
            if (child instanceof Container) {
                objList = objList.concat(child.getChildByType(classType));
            }
        });

        return objList;
    }

    /**
     * returns the list of childs with the specified name<br>
     * as defined in Tiled (Name field of the Object Properties)<br>
     * note : avoid calling this function every frame since
     * it parses the whole object list each time
     * @name getChildByName
     * @memberof Container
     * @public
     * @param {string|RegExp|number|boolean} name child name
     * @returns {Renderable[]} Array of children
     */
    getChildByName(name) {
        return this.getChildByProp("name", name);
    }

    /**
     * return the child corresponding to the specified GUID<br>
     * note : avoid calling this function every frame since
     * it parses the whole object list each time
     * @name getChildByGUID
     * @memberof Container
     * @public
     * @param {string|RegExp|number|boolean} guid child GUID
     * @returns {Renderable} corresponding child or null
     */
    getChildByGUID(guid) {
        var obj = this.getChildByProp("GUID", guid);
        return (obj.length > 0) ? obj[0] : null;
    }

    /**
     * return all child in this container
     * @name getChildren
     * @memberof Container
     * @public
     * @returns {Renderable[]} an array of renderable object
     */
    getChildren() {
        if (typeof this.children === "undefined") {
            this.children = [];
        }
        return this.children;
    }

    /**
     * update the bounding box for this shape.
     * @ignore
     * @name updateBounds
     * @memberof Renderable
     * @returns {Bounds} this shape bounding box Rectangle object
     */
    updateBounds(forceUpdateChildBounds = false) {

        // call parent method
        super.updateBounds();

        var bounds = this.getBounds();

        if (forceUpdateChildBounds === true || this.enableChildBoundsUpdate === true) {
            this.forEach((child) => {
                if (child.isRenderable) {
                    var childBounds = child.getBounds();
                    if (childBounds.isFinite()) {
                        bounds.addBounds(child.getBounds());
                    }
                }
            });
        }

        return bounds;
    }

    /**
     * Checks if this container is root or if it's attached to the root container.
     * @private
     * @name isAttachedToRoot
     * @memberof Container
     * @returns {boolean}
     */
    isAttachedToRoot() {
        if (this.root === true) {
            return true;
        } else {
            var ancestor = this.ancestor;
            while (ancestor) {
                if (ancestor.root === true) {
                    return true;
                }
                ancestor = ancestor.ancestor;
            }
            return false;
        }
    }

    /**
     * update the cointainer's bounding rect (private)
     * @ignore
     * @name updateBoundsPos
     * @memberof Container
     */
    updateBoundsPos(newX, newY) {
        // call the parent method
        super.updateBoundsPos(newX, newY);

        // Notify children that the parent's position has changed
        this.forEach((child) => {
            if (child.isRenderable) {
                child.updateBoundsPos(
                    // workaround on this.pos being updated after
                    // the callback being triggered
                    child.pos.x + newX - this.pos.x,
                    child.pos.y + newY - this.pos.y
                );
            }
        });
        return this.getBounds();
    }

    /**
     * @ignore
     */
    onActivateEvent() {
        this.forEach((child) => {
            if (typeof child.onActivateEvent === "function") {
                child.onActivateEvent();
            }
        });
    }

    /**
     * Invokes the removeChildNow in a defer, to ensure the child is removed safely after the update & draw stack has completed. <br>
     * if the given child implements a onDeactivateEvent() method, that method will be called once the child is removed from this container.
     * @name removeChild
     * @memberof Container
     * @public
     * @param {Renderable} child
     * @param {boolean} [keepalive=False] True to prevent calling child.destroy()
     */
    removeChild(child, keepalive) {
        if (this.hasChild(child)) {
            utils.function.defer(deferredRemove, this, child, keepalive);
        }
        else {
            throw new Error("Child is not mine.");
        }
    }

    /**
     * Removes (and optionally destroys) a child from the container.<br>
     * (removal is immediate and unconditional)<br>
     * Never use keepalive=true with objects from {@link pool}. Doing so will create a memory leak.
     * @name removeChildNow
     * @memberof Container
     * @param {Renderable} child
     * @param {boolean} [keepalive=False] True to prevent calling child.destroy()
     */
    removeChildNow(child, keepalive) {
        if (this.hasChild(child) && (this.getChildIndex(child) >= 0)) {
            if (typeof child.onDeactivateEvent === "function") {
                child.onDeactivateEvent();
            }

            // remove the body first to avoid a condition where a body can be detached
            // from its parent, before the body is removed from the game world
            if (child.body instanceof Body) {
                world.removeBody(child.body);
            }

            if (!keepalive) {
                // attempt at recycling the object
                if (pool.push(child, false) === false ) {
                    //  else just destroy it
                    if (typeof child.destroy === "function") {
                        child.destroy();
                    }
                }
            }

            // Don't cache the child index; another element might have been removed
            // by the child's `onDeactivateEvent` or `destroy` methods
            var childIndex = this.getChildIndex(child);
            if (childIndex >= 0) {
                this.getChildren().splice(childIndex, 1);
                child.ancestor = undefined;
            }

            // force repaint in case this is a static non-animated object
            if (this.isAttachedToRoot() === true) {
                repaint();
            }

            // force bounds update if required
            if (this.enableChildBoundsUpdate) {
                this.updateBounds(true);
            }

            // triggered callback if defined
            this.onChildChange.call(this, childIndex);
        }
    }

    /**
     * Automatically set the specified property of all childs to the given value
     * @name setChildsProperty
     * @memberof Container
     * @param {string} prop property name
     * @param {object} value property value
     * @param {boolean} [recursive=false] recursively apply the value to child containers if true
     */
    setChildsProperty(prop, value, recursive) {
        this.forEach((child) => {
            if ((recursive === true) && (child instanceof Container)) {
                child.setChildsProperty(prop, value, recursive);
            }
            child[prop] = value;
        });
    }

    /**
     * Move the child in the group one step forward (z depth).
     * @name moveUp
     * @memberof Container
     * @param {Renderable} child
     */
    moveUp(child) {
        var childIndex = this.getChildIndex(child);
        if (childIndex - 1 >= 0) {
            // note : we use an inverted loop
            this.swapChildren(child, this.getChildAt(childIndex - 1));
            // mark the container as dirty
            this.isDirty = true;
        }
    }

    /**
     * Move the child in the group one step backward (z depth).
     * @name moveDown
     * @memberof Container
     * @param {Renderable} child
     */
    moveDown(child) {
        var childIndex = this.getChildIndex(child);
        if (childIndex >= 0 && (childIndex + 1) < this.getChildren().length) {
            // note : we use an inverted loop
            this.swapChildren(child, this.getChildAt(childIndex + 1));
            // mark the container as dirty
            this.isDirty = true;
        }
    }

    /**
     * Move the specified child to the top(z depth).
     * @name moveToTop
     * @memberof Container
     * @param {Renderable} child
     */
    moveToTop(child) {
        var childIndex = this.getChildIndex(child);
        if (childIndex > 0) {
            var children = this.getChildren();
            // note : we use an inverted loop
            children.splice(0, 0, children.splice(childIndex, 1)[0]);
            // increment our child z value based on the previous child depth
            child.pos.z = children[1].pos.z + 1;
            // mark the container as dirty
            this.isDirty = true;
        }
    }

    /**
     * Move the specified child the bottom (z depth).
     * @name moveToBottom
     * @memberof Container
     * @param {Renderable} child
     */
    moveToBottom(child) {
        var childIndex = this.getChildIndex(child);
        var children = this.getChildren();
        if (childIndex >= 0 && childIndex < (children.length - 1)) {
            // note : we use an inverted loop
            children.splice((children.length - 1), 0, children.splice(childIndex, 1)[0]);
            // increment our child z value based on the next child depth
            child.pos.z = children[(children.length - 2)].pos.z - 1;
            // mark the container as dirty
            this.isDirty = true;
        }
    }

    /**
     * Manually trigger the sort of all the childs in the container</p>
     * @name sort
     * @memberof Container
     * @public
     * @param {boolean} [recursive=false] recursively sort all containers if true
     */
    sort(recursive) {
        // do nothing if there is already a pending sort
        if (!this.pendingSort) {
            if (recursive === true) {
                this.forEach((child) => {
                    if (child instanceof Container) {
                        // note : this will generate one defered sorting function
                        // for each existing containe
                        child.sort(recursive);
                    }
                });
            }
            /** @ignore */
            this.pendingSort = utils.function.defer(function () {
                // sort everything in this container
                this.getChildren().sort(this["_sort" + this.sortOn.toUpperCase()]);
                // clear the defer id
                this.pendingSort = null;
                // make sure we redraw everything
                repaint();
            }, this);
        }
    }

    /**
     * @ignore
     */
    onDeactivateEvent() {
        this.forEach((child) => {
            if (typeof child.onDeactivateEvent === "function") {
                child.onDeactivateEvent();
            }
        });
    }

    /**
     * Z Sorting function
     * @ignore
     */
    _sortZ(a, b) {
        return (b.pos && a.pos) ? (b.pos.z - a.pos.z) : (a.pos ? -Infinity : Infinity);
    }

    /**
     * Reverse Z Sorting function
     * @ignore
     */
    _sortReverseZ(a, b) {
        return (a.pos && b.pos) ? (a.pos.z - b.pos.z) : (a.pos ? Infinity : -Infinity);
    }

    /**
     * X Sorting function
     * @ignore
     */
    _sortX(a, b) {
        if (!b.pos || !a.pos) {
            return (a.pos ? -Infinity : Infinity);
        }
        var result = b.pos.z - a.pos.z;
        return (result ? result : (b.pos.x - a.pos.x));
    }

    /**
     * Y Sorting function
     * @ignore
     */
    _sortY(a, b) {
        if (!b.pos || !a.pos) {
            return (a.pos ? -Infinity : Infinity);
        }
        var result = b.pos.z - a.pos.z;
        return (result ? result : (b.pos.y - a.pos.y));
    }

    /**
     * Destroy function<br>
     * @ignore
     */
    destroy() {
        // empty the container
        this.reset();
        // call the parent destroy method
        super.destroy(arguments);
    }

    /**
     * container update function. <br>
     * automatically called by the game manager {@link game}
     * @name update
     * @memberof Container
     * @protected
     * @param {number} dt time since the last update in milliseconds.
     * @returns {boolean} true if the Container is dirty
     */
    update(dt) {
        var isFloating = false;
        var isPaused = state.isPaused();
        var children = this.getChildren();

        for (var i = children.length, obj; i--, (obj = children[i]);) {
            if (isPaused && (!obj.updateWhenPaused)) {
                // skip this object
                continue;
            }

            if (obj.isRenderable) {
                isFloating = (globalFloatingCounter > 0 || obj.floating);
                if (isFloating) {
                    globalFloatingCounter++;
                }

                // check if object is in any active cameras
                obj.inViewport = false;
                // iterate through all cameras
                state.current().cameras.forEach(function(camera) {
                    if (camera.isVisible(obj, isFloating)) {
                        obj.inViewport = true;
                    }                });

                // update our object
                this.isDirty |= ((obj.inViewport || obj.alwaysUpdate) && obj.update(dt));

                if (globalFloatingCounter > 0) {
                    globalFloatingCounter--;
                }
            }
            else {
                // just directly call update() for non renderable object
                this.isDirty |= obj.update(dt);
            }
        }

        // call the parent method
        return super.update(dt);
    }

    /**
      * draw this renderable (automatically called by melonJS)
     * @name draw
     * @memberof Container
     * @protected
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer instance
     * @param {Camera2d} [viewport] the viewport to (re)draw
     */
    draw(renderer, viewport) {
        var isFloating = false;
        var bounds = this.getBounds();

        this.drawCount = 0;

        // clip the containter children to the container bounds
        if (this.root === false && this.clipping === true && bounds.isFinite() === true) {
            renderer.clipRect(
                bounds.left,
                bounds.top,
                bounds.width,
                bounds.height
            );
        }

        // adjust position if required (e.g. canvas/window centering)
        renderer.translate(this.pos.x, this.pos.y);

        // color background if defined
        if (this.backgroundColor.alpha > 1 / 255) {
            renderer.clearColor(this.backgroundColor);
        }

        var children = this.getChildren();
        for (var i = children.length, obj; i--, (obj = children[i]);) {
            if (obj.isRenderable) {

                isFloating = obj.floating === true;

                if ((obj.inViewport || isFloating)) {

                    if (isFloating) {
                        // translate to screen coordinates
                        renderer.save();
                        renderer.resetTransform();
                    }

                    // predraw (apply transforms)
                    obj.preDraw(renderer);

                    // draw the object
                    obj.draw(renderer, viewport);

                    // postdraw (clean-up);
                    obj.postDraw(renderer);

                    // restore the previous "state"
                    if (isFloating) {
                        renderer.restore();
                    }

                    this.drawCount++;
                }
            }
        }
    }
}

/*
 * A QuadTree implementation in JavaScript, a 2d spatial subdivision algorithm.
 * Based on the QuadTree Library by Timo Hausmann and released under the MIT license
 * https://github.com/timohausmann/quadtree-js/
**/


/**
 * a pool of `QuadTree` objects
 * @ignore
 */
var QT_ARRAY = [];

/**
 * will pop a quadtree object from the array
 * or create a new one if the array is empty
 * @ignore
 */
function QT_ARRAY_POP(bounds, max_objects = 4, max_levels = 4, level = 0) {
    if (QT_ARRAY.length > 0) {
        var _qt =  QT_ARRAY.pop();
        _qt.bounds = bounds;
        _qt.max_objects = max_objects;
        _qt.max_levels  = max_levels;
        _qt.level = level;
        return _qt;
    } else {
        return new QuadTree(bounds, max_objects, max_levels, level);
    }
}
/**
 * Push back a quadtree back into the array
 * @ignore
 */
function QT_ARRAY_PUSH(qt) {
    QT_ARRAY.push(qt);
}
/**
 * a temporary vector object to be reused
 * @ignore
 */
var QT_VECTOR = new Vector2d();

/**
 * @classdesc
 * a QuadTree implementation in JavaScript, a 2d spatial subdivision algorithm.
 * @see game.world.broadphase
 */
class QuadTree {
    /**
     * @param {Bounds} bounds bounds of the node
     * @param {number} [max_objects=4] max objects a node can hold before splitting into 4 subnodes
     * @param {number} [max_levels=4] total max levels inside root Quadtree
     * @param {number} [level] deepth level, required for subnodes
     */
    constructor(bounds, max_objects = 4, max_levels = 4, level = 0) {
        this.max_objects = max_objects;
        this.max_levels  = max_levels;

        this.level = level;
        this.bounds = bounds;

        this.objects = [];
        this.nodes = [];
    }

    /*
     * Split the node into 4 subnodes
     */
    split() {
        var nextLevel = this.level + 1,
            subWidth  = this.bounds.width / 2,
            subHeight = this.bounds.height / 2,
            left = this.bounds.left,
            top = this.bounds.top;

         //top right node
        this.nodes[0] = QT_ARRAY_POP({
            left : left + subWidth,
            top : top,
            width : subWidth,
            height : subHeight
        }, this.max_objects, this.max_levels, nextLevel);

        //top left node
        this.nodes[1] = QT_ARRAY_POP({
            left : left,
            top: top,
            width : subWidth,
            height : subHeight
        }, this.max_objects, this.max_levels, nextLevel);

        //bottom left node
        this.nodes[2] = QT_ARRAY_POP({
            left : left,
            top : top + subHeight,
            width : subWidth,
            height : subHeight
        }, this.max_objects, this.max_levels, nextLevel);

        //bottom right node
        this.nodes[3] = QT_ARRAY_POP({
            left : left + subWidth,
            top : top + subHeight,
            width : subWidth,
            height : subHeight
        }, this.max_objects, this.max_levels, nextLevel);
    }

    /*
     * Determine which node the object belongs to
     * @param {Rect} rect bounds of the area to be checked
     * @returns Integer index of the subnode (0-3), or -1 if rect cannot completely fit within a subnode and is part of the parent node
     */
    getIndex(item) {
        var pos;
        var bounds = item.getBounds();

        // use game world coordinates for floating items
        if (item.isFloating === true) {
            pos = viewport.localToWorld(bounds.left, bounds.top, QT_VECTOR);
        } else {
            pos = QT_VECTOR.set(item.left, item.top);
        }

        var index = -1,
            rx = pos.x,
            ry = pos.y,
            rw = bounds.width,
            rh = bounds.height,
            verticalMidpoint = this.bounds.left + (this.bounds.width / 2),
            horizontalMidpoint = this.bounds.top + (this.bounds.height / 2),
            //rect can completely fit within the top quadrants
            topQuadrant = (ry < horizontalMidpoint && ry + rh < horizontalMidpoint),
            //rect can completely fit within the bottom quadrants
            bottomQuadrant = (ry > horizontalMidpoint);

        //rect can completely fit within the left quadrants
        if (rx < verticalMidpoint && rx + rw < verticalMidpoint) {
            if (topQuadrant) {
                index = 1;
            } else if (bottomQuadrant) {
                index = 2;
            }
        } else if (rx > verticalMidpoint) {
            //rect can completely fit within the right quadrants
            if (topQuadrant) {
                index = 0;
            } else if (bottomQuadrant) {
                index = 3;
            }
        }

        return index;
    }

    /**
     * Insert the given object container into the node.
     * @name insertContainer
     * @memberof QuadTree
     * @param {Container} container group of objects to be added
     */
    insertContainer(container) {
        for (var i = container.children.length, child; i--, (child = container.children[i]);) {
            if (child.isKinematic !== true) {
                if (child instanceof Container) {
                    if (child.name !== "rootContainer") {
                        this.insert(child);
                    }
                    // recursivly insert all childs
                    this.insertContainer(child);
                } else {
                    // only insert object with a bounding box
                    // Probably redundant with `isKinematic`
                    if (typeof (child.getBounds) === "function") {
                        this.insert(child);
                    }
                }
            }
        }
    }

    /**
     * Insert the given object into the node. If the node
     * exceeds the capacity, it will split and add all
     * objects to their corresponding subnodes.
     * @name insert
     * @memberof QuadTree
     * @param {object} item object to be added
     */
    insert(item) {
        var index = -1;

        //if we have subnodes ...
        if (this.nodes.length > 0) {
            index = this.getIndex(item);

            if (index !== -1) {
                this.nodes[index].insert(item);
                return;
            }
        }

        this.objects.push(item);

        if (this.objects.length > this.max_objects && this.level < this.max_levels) {

            //split if we don't already have subnodes
            if (this.nodes.length === 0) {
                this.split();
            }

            var i = 0;

            //add all objects to there corresponding subnodes
            while (i < this.objects.length) {

                index = this.getIndex(this.objects[i]);

                if (index !== -1) {
                    this.nodes[index].insert(this.objects.splice(i, 1)[0]);
                } else {
                    i = i + 1;
                }
            }
        }
    }

    /**
     * Return all objects that could collide with the given object
     * @name retrieve
     * @memberof QuadTree
     * @param {object} item object to be checked against
     * @param {object} [fn] a sorting function for the returned array
     * @returns {object[]} array with all detected objects
     */
    retrieve(item, fn) {
        var returnObjects = this.objects;

        //if we have subnodes ...
        if (this.nodes.length > 0) {

            var index = this.getIndex(item);

            //if rect fits into a subnode ..
            if (index !== -1) {
                returnObjects = returnObjects.concat(this.nodes[index].retrieve(item));
            } else {
                 //if rect does not fit into a subnode, check it against all subnodes
                for (var i = 0; i < this.nodes.length; i = i + 1) {
                    returnObjects = returnObjects.concat(this.nodes[i].retrieve(item));
                }
            }
        }

        if (typeof(fn) === "function") {
            returnObjects.sort(fn);
        }

        return returnObjects;
    }

    /**
     * Remove the given item from the quadtree.
     * (this function won't recalculate the impacted node)
     * @name remove
     * @memberof QuadTree
     * @param {object} item object to be removed
     * @returns {boolean} true if the item was found and removed.
     */
     remove(item) {
        var found = false;

        if (typeof (item.getBounds) === "undefined") {
            // ignore object that cannot be added in the first place
            return false;
        }

        //if we have subnodes ...
        if (this.nodes.length > 0) {
            // determine to which node the item belongs to
            var index = this.getIndex(item);

            if (index !== -1) {
                found = remove(this.nodes[index], item);
                // trim node if empty
                if (found && this.nodes[index].isPrunable()) {
                    this.nodes.splice(index, 1);
                }
            }
        }

        if (found === false) {
            // try and remove the item from the list of items in this node
            if (this.objects.indexOf(item) !== -1) {
                remove(this.objects, item);
                found = true;
            }
        }

        return found;
    }

    /**
     * return true if the node is prunable
     * @name isPrunable
     * @memberof QuadTree
     * @returns {boolean} true if the node is prunable
     */
    isPrunable() {
        return !(this.hasChildren() || (this.objects.length > 0));
    }

    /**
     * return true if the node has any children
     * @name hasChildren
     * @memberof QuadTree
     * @returns {boolean} true if the node has any children
     */
    hasChildren() {
        for (var i = 0; i < this.nodes.length; i = i + 1) {
            var subnode = this.nodes[i];
            if (subnode.length > 0 || subnode.objects.length > 0) {
                return true;
            }
        }
        return false;
    }

    /**
     * clear the quadtree
     * @name clear
     * @memberof QuadTree
     * @param {Bounds} [bounds=this.bounds] the bounds to be cleared
     */
    clear(bounds) {
        this.objects.length = 0;

        for (var i = 0; i < this.nodes.length; i++) {
            this.nodes[i].clear();
            // recycle the quadTree object
            QT_ARRAY_PUSH(this.nodes[i]);
        }
        // empty the array
        this.nodes.length = 0;

        // resize the root bounds if required
        if (typeof bounds !== "undefined") {
            this.bounds.setMinMax(bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y);
        }
    }
}

/**
 * @classdesc
 * an object representing the physic world, and responsible for managing and updating all childs and physics
 * @augments Container
 */
class World extends Container {
    /**
     * @param {number} [x=0] position of the container (accessible via the inherited pos.x property)
     * @param {number} [y=0] position of the container (accessible via the inherited pos.y property)
     * @param {number} [width=game.viewport.width] width of the container
     * @param {number} [height=game.viewport.height] height of the container
     */
    constructor(x = 0, y = 0, width = Infinity, height = Infinity) {
        // call the super constructor
        super(x, y, width, height, true);

        // world is the root container
        this.name = "rootContainer";

        // to mimic the previous behavior
        this.anchorPoint.set(0, 0);

        /**
         * the rate at which the game world is updated,
         * may be greater than or lower than the display fps
         * @public
         * @type {Vector2d}
         * @default 60
         * @name fps
         * @memberof World
         * @see timer.maxfps
         */
        this.fps = 60;

        /**
         * world gravity
         * @public
         * @type {Vector2d}
         * @default <0,0.98>
         * @name gravity
         * @memberof World
         */
        this.gravity = new Vector2d(0, 0.98);

        /**
         * Specify the rendering method for tile layers. <br>
         * if false visible part of the layers are rendered dynamically,<br>
         * if true the entire layers are first rendered into an offscreen canvas.<br>
         * the "best" rendering method depends of your game
         * (amount of layer, layer size, amount of tiles per layer, etc.)<br>
         * note : rendering method is also configurable per layer by adding this
         * property to your layer (in Tiled).
         * @type {boolean}
         * @default false
         * @memberof World
         */
        this.preRender = false;

        /**
         * the active physic bodies in this simulation
         * @name bodies
         * @memberof World
         * @public
         * @type {Set<Body>}
         */
        this.bodies = new Set();

        /**
         * the instance of the game world quadtree used for broadphase
         * @name broadphase
         * @memberof World
         * @public
         * @type {QuadTree}
         */
        this.broadphase = new QuadTree(this.getBounds().clone(), collision.maxChildren, collision.maxDepth);

        // reset the world container on the game reset signal
        on(GAME_RESET, this.reset, this);

        // update the broadband world bounds if a new level is loaded
        on(LEVEL_LOADED, () => {
            // reset the quadtree
            this.broadphase.clear(this.getBounds());
        });
    }

    /**
     * reset the game world
     * @name reset
     * @memberof World
     */
    reset() {
        // clear the quadtree
        this.broadphase.clear();

        // reset the anchorPoint
        this.anchorPoint.set(0, 0);

        // call the parent method
        super.reset();

        // empty the list of active physic bodies
        // Note: this should be empty already when calling the parent method
        this.bodies.clear();
    }

    /**
     * Add a physic body to the game world
     * @name addBody
     * @memberof World
     * @see Container.addChild
     * @param {Body} body
     * @returns {World} this game world
     */
    addBody(body) {
        //add it to the list of active body
        this.bodies.add(body);
        return this;
    }

    /**
     * Remove a physic body from the game world
     * @name removeBody
     * @memberof World
     * @see Container.removeChild
     * @param {Body} body
     * @returns {World} this game world
     */
    removeBody(body) {
        //remove from the list of active body
        this.bodies.delete(body);
        return this;
    }

    /**
     * update the game world
     * @name reset
     * @memberof World
     * @param {number} dt the time passed since the last frame update
     * @returns {boolean} true if the word is dirty
     */
    update (dt) {
        var isPaused = state.isPaused();

        // clear the quadtree
        this.broadphase.clear();

        // insert the world container (children) into the quadtree
        this.broadphase.insertContainer(this);

        // iterate through all bodies
        this.bodies.forEach((body) => {
            if (!body.isStatic) {
                var ancestor = body.ancestor;
                // if the game is not paused, and ancestor can be updated
                if (!(isPaused && (!ancestor.updateWhenPaused)) &&
                   (ancestor.inViewport || ancestor.alwaysUpdate)) {
                    // apply physics to the body (this moves it)
                    if (body.update(dt) === true) {
                        // mark ancestor as dirty
                        ancestor.isDirty = true;
                    }                    // handle collisions against other objects
                    collisionCheck(ancestor);
                }
            }
        });

        // call the super constructor
        return super.update(dt);
    }

}

/**
 * game represents your current game, it contains all the objects,
 * tilemap layers, current viewport, collision map, etc...<br>
 * game is also responsible for updating (each frame) the object status and draw them.
 * @namespace game
 */

// to know when we have to refresh the display
var isDirty = true;

// always refresh the display when updatesPerSecond are lower than fps
var isAlwaysDirty = false;

// frame counter for frameSkipping
// reset the frame counter
var frameCounter = 0;
var frameRate = 1;

// time accumulation for multiple update calls
var accumulator = 0.0;
var accumulatorMax = 0.0;
var accumulatorUpdateDelta = 0;

// min update step size
var stepSize = 1000 / 60;
var updateDelta = 0;
var lastUpdateStart = null;
var updateAverageDelta = 0;


 // initialize the game manager on system boot
on(BOOT, () => {
    // the root object of our world is an entity container
    world = new World();
    // publish init notification
    emit(GAME_INIT);
});


/**
 * a reference to the current active stage "default" camera
 * @public
 * @type {Camera2d}
 * @name viewport
 * @memberof game
 */
let viewport;

/**
 * a reference to the game world, <br>
 * a world is a virtual environment containing all the game objects
 * @public
 * @type {World}
 * @name world
 * @memberof game
 */
let world;

/**
 * when true, all objects will be added under the root world container.<br>
 * When false, a `me.Container` object will be created for each corresponding groups
 * @public
 * @type {boolean}
 * @default true
 * @name mergeGroup
 * @memberof game
 */
let mergeGroup = true;

/**
 * Specify the property to be used when sorting entities.
 * Accepted values : "x", "y", "z"
 * @public
 * @type {string}
 * @default "z"
 * @name sortOn
 * @memberof game
 */
let sortOn = "z";

/**
 * Last time the game update loop was executed. <br>
 * Use this value to implement frame prediction in drawing events,
 * for creating smooth motion while running game update logic at
 * a lower fps.
 * @public
 * @type {DOMHighResTimeStamp}
 * @name lastUpdate
 * @memberof game
 */
let lastUpdate = globalThis.performance.now();

/**
 * Fired when a level is fully loaded and all entities instantiated. <br>
 * Additionnaly the level id will also be passed to the called function.
 * @function game.onLevelLoaded
 * @example
 * // call myFunction () everytime a level is loaded
 * me.game.onLevelLoaded = this.myFunction.bind(this);
 */
function onLevelLoaded() {}
/**
 * reset the game Object manager<br>
 * destroy all current objects
 * @function game.reset
 */
function reset () {
    // point to the current active stage "default" camera
    var current = state.current();
    if (typeof current !== "undefined") {
        viewport = current.cameras.get("default");
    }

    // publish reset notification
    emit(GAME_RESET);

    // Refresh internal variables for framerate  limiting
    updateFrameRate();
}

/**
 * Update the renderer framerate using the system config variables.
 * @function game.updateFrameRate
 * @see timer.maxfps
 * @see World.fps
 */
function updateFrameRate() {
    // reset the frame counter
    frameCounter = 0;
    frameRate = ~~(0.5 + 60 / timer.maxfps);

    // set step size based on the updatesPerSecond
    stepSize = (1000 / world.fps);
    accumulator = 0.0;
    accumulatorMax = stepSize * 10;

    // display should always re-draw when update speed doesn't match fps
    // this means the user intends to write position prediction drawing logic
    isAlwaysDirty = (timer.maxfps > world.fps);
}
/**
 * Returns the parent container of the specified Child in the game world
 * @function game.getParentContainer
 * @param {Renderable} child
 * @returns {Container}
 */
function getParentContainer(child) {
    return child.ancestor;
}
/**
 * force the redraw (not update) of all objects
 * @function game.repaint
 */
function repaint() {
    isDirty = true;
}

/**
 * update all objects of the game manager
 * @ignore
 * @function game.update
 * @param {number} time current timestamp as provided by the RAF callback
 * @param {Stage} stage the current stage
 */
function update(time, stage) {
    // handle frame skipping if required
    if ((++frameCounter % frameRate) === 0) {
        // reset the frame counter
        frameCounter = 0;

        // publish notification
        emit(GAME_BEFORE_UPDATE, time);

        accumulator += timer.getDelta();
        accumulator = Math.min(accumulator, accumulatorMax);

        updateDelta = (timer.interpolation) ? timer.getDelta() : stepSize;
        accumulatorUpdateDelta = (timer.interpolation) ? updateDelta : Math.max(updateDelta, updateAverageDelta);

        while (accumulator >= accumulatorUpdateDelta || timer.interpolation) {
            lastUpdateStart = globalThis.performance.now();

            // game update event
            if (state.isPaused() !== true) {
                emit(GAME_UPDATE, time);
            }

            // update all objects (and pass the elapsed time since last frame)
            isDirty = stage.update(updateDelta) || isDirty;

            lastUpdate = globalThis.performance.now();
            updateAverageDelta = lastUpdate - lastUpdateStart;

            accumulator -= accumulatorUpdateDelta;
            if (timer.interpolation) {
                accumulator = 0;
                break;
            }
        }

        // publish notification
        emit(GAME_AFTER_UPDATE, lastUpdate);
    }
}
/**
 * draw the current scene/stage
 * @function game.draw
 * @ignore
 * @param {Stage} stage the current stage
 */
function draw(stage) {

    if (renderer.isContextValid === true && (isDirty || isAlwaysDirty)) {
        // publish notification
        emit(GAME_BEFORE_DRAW, globalThis.performance.now());

        // prepare renderer to draw a new frame
        renderer.clear();

        // render the stage
        stage.draw(renderer);

        // set back to flag
        isDirty = false;

        // flush/render our frame
        renderer.flush();

        // publish notification
        emit(GAME_AFTER_DRAW, globalThis.performance.now());
    }
}

var game = /*#__PURE__*/Object.freeze({
	__proto__: null,
	get viewport () { return viewport; },
	get world () { return world; },
	mergeGroup: mergeGroup,
	sortOn: sortOn,
	get lastUpdate () { return lastUpdate; },
	onLevelLoaded: onLevelLoaded,
	reset: reset,
	updateFrameRate: updateFrameRate,
	getParentContainer: getParentContainer,
	repaint: repaint,
	update: update,
	draw: draw
});

// some ref shortcut
const MIN = Math.min, MAX = Math.max;

var targetV = new Vector2d();

/**
 * @classdesc
 * a 2D orthographic camera
 * @augments Renderable
 */
class Camera2d extends Renderable {
    /**
     * @param {number} minX start x offset
     * @param {number} minY start y offset
     * @param {number} maxX end x offset
     * @param {number} maxY end y offset
     */
    constructor(minX, minY, maxX, maxY) {
        super(minX, minY, maxX - minX, maxY - minY);

        /**
         * Axis definition
         * @enum {number}
         * @property {number} NONE no axis
         * @property {number} HORIZONTAL horizontal axis only
         * @property {number} VERTICAL vertical axis only
         * @property {number} BOTH both axis
         * @readonly
         * @name AXIS
         * @memberof Camera2d
         */
        this.AXIS = {
            NONE : 0,
            HORIZONTAL : 1,
            VERTICAL : 2,
            BOTH : 3
        };

        /**
         * Camera bounds
         * @public
         * @type {Bounds}
         * @name bounds
         * @memberof Camera2d
         */
        this.bounds = pool.pull("Bounds");

        /**
         * enable or disable damping
         * @private
         * @default true
         */
        this.smoothFollow = true;

        /**
         * Camera damping for smooth transition [0 .. 1].
         * 1 being the maximum value and will snap the camera to the target position
         * @public
         * @type {number}
         * @name damping
         * @default 1.0
         * @memberof Camera2d
         */
        this.damping = 1.0;

        /**
         * the closest point relative to the camera
         * @public
         * @type {number}
         * @name near
         * @default -1000
         * @memberof Camera2d
         */
        this.near = -1000;

        /**
         * the furthest point relative to the camera.
         * @public
         * @type {number}
         * @name far
         * @default 1000
         * @memberof Camera2d
         */
        this.far = 1000;

        /**
         * the default camera projection matrix
         * (2d cameras use an orthographic projection by default).
         * @public
         * @type {Matrix3d}
         * @name projectionMatrix
         * @memberof Camera2d
         */
        this.projectionMatrix = new Matrix3d();

        /**
         * the invert camera transform used to unproject points
         * @ignore
         * @type {Matrix2d}
         * @name invCurrentTransform
         * @memberof Camera2d
         */
        this.invCurrentTransform = new Matrix2d();

        // offset for shake effect
        this.offset = new Vector2d();

        // target to follow
        this.target = null;

        // default value follow
        this.follow_axis = this.AXIS.NONE;

        // shake variables
        this._shake = {
            intensity : 0,
            duration : 0,
            axis : this.AXIS.BOTH,
            onComplete : null
        };

        // flash variables
        this._fadeOut = {
            color : null,
            tween : null
        };
        // fade variables
        this._fadeIn = {
            color : null,
            tween : null
        };

        // default camera name
        this.name = "default";

        // set a default deadzone
        this.setDeadzone(this.width / 6, this.height / 6);

        // for backward "compatiblity" (in terms of behavior)
        this.anchorPoint.set(0, 0);

        // enable event detection on the camera
        this.isKinematic = false;

        this.bounds.setMinMax(minX, minY, maxX, maxY);

        // update the projection matrix
        this._updateProjectionMatrix();

        // subscribe to the game reset event
        on(GAME_RESET, this.reset, this);
        // subscribe to the canvas resize event
        on(CANVAS_ONRESIZE, this.resize, this);
    }

    // -- some private function ---

    /** @ignore */
    // update the projection matrix based on the projection frame (a rectangle)
    _updateProjectionMatrix() {
        this.projectionMatrix.ortho(0, this.width, this.height, 0, this.near, this.far);
    }

    /** @ignore */
    _followH(target) {
        var targetX = this.pos.x;
        if ((target.x - this.pos.x) > (this.deadzone.right)) {
            targetX = MIN((target.x) - (this.deadzone.right), this.bounds.width - this.width);
        }
        else if ((target.x - this.pos.x) < (this.deadzone.pos.x)) {
            targetX = MAX((target.x) - this.deadzone.pos.x, this.bounds.left);
        }
        return targetX;

    }

    /** @ignore */
    _followV(target) {
        var targetY = this.pos.y;
        if ((target.y - this.pos.y) > (this.deadzone.bottom)) {
            targetY = MIN((target.y) - (this.deadzone.bottom), this.bounds.height - this.height);
        }
        else if ((target.y - this.pos.y) < (this.deadzone.pos.y)) {
            targetY = MAX((target.y) - this.deadzone.pos.y, this.bounds.top);
        }
        return targetY;
    }

    // -- public function ---

    /**
     * reset the camera position to specified coordinates
     * @name reset
     * @memberof Camera2d
     * @param {number} [x=0]
     * @param {number} [y=0]
     */
    reset(x = 0, y = 0) {
        // reset the initial camera position to 0,0
        this.pos.x = x;
        this.pos.y = y;

        // reset the target
        this.unfollow();

        // damping default value
        this.smoothFollow = true;
        this.damping = 1.0;

        // reset the transformation matrix
        this.currentTransform.identity();
        this.invCurrentTransform.identity().invert();

        // update the projection matrix
        this._updateProjectionMatrix();
    }

    /**
     * change the deadzone settings.
     * the "deadzone" defines an area within the current camera in which
     * the followed renderable can move without scrolling the camera.
     * @name setDeadzone
     * @see Camera2d.follow
     * @memberof Camera2d
     * @param {number} w deadzone width
     * @param {number} h deadzone height
     */
    setDeadzone(w, h) {
        if (typeof(this.deadzone) === "undefined") {
            this.deadzone = new Rect(0, 0, 0, 0);
        }

        // reusing the old code for now...
        this.deadzone.pos.set(
            ~~((this.width - w) / 2),
            ~~((this.height - h) / 2 - h * 0.25)
        );
        this.deadzone.resize(w, h);

        this.smoothFollow = false;

        // force a camera update
        this.updateTarget();

        this.smoothFollow = true;
    }

    /**
     * resize the camera
     * @name resize
     * @memberof Camera2d
     * @param {number} w new width of the camera
     * @param {number} h new height of the camera
     * @returns {Camera2d} this camera
     */
    resize(w, h) {
        // parent consctructor, resize camera rect
        super.resize(w, h);

        // disable damping while resizing
        this.smoothFollow = false;

        // reset everything
        this.setBounds(0, 0, w, h);
        this.setDeadzone(w / 6, h / 6);
        this.update();
        this.smoothFollow = true;

        // update the projection matrix
        this._updateProjectionMatrix();

        // publish the viewport resize event
        emit(VIEWPORT_ONRESIZE, this.width, this.height);

        return this;
    }

    /**
     * set the camera boundaries (set to the world limit by default).
     * the camera is bound to the given coordinates and cannot move/be scrolled outside of it.
     * @name setBounds
     * @memberof Camera2d
     * @param {number} x world left limit
     * @param {number} y world top limit
     * @param {number} w world width limit
     * @param {number} h world height limit
     */
    setBounds(x, y, w, h) {
        this.smoothFollow = false;
        this.bounds.setMinMax(x, y, w + x, h + y);
        this.moveTo(this.pos.x, this.pos.y);
        this.update();
        this.smoothFollow = true;
    }

    /**
     * set the camera to follow the specified renderable. <br>
     * (this will put the camera center around the given target)
     * @name follow
     * @memberof Camera2d
     * @param {Renderable|Vector2d} target renderable or position vector to follow
     * @param {number} [axis=me.game.viewport.AXIS.BOTH] Which axis to follow (see {@link Camera2d.AXIS})
     * @param {number} [damping=1] default damping value
     * @example
     * // set the camera to follow this renderable on both axis, and enable damping
     * me.game.viewport.follow(this, me.game.viewport.AXIS.BOTH, 0.1);
     */
    follow(target, axis, damping) {
        if (target instanceof Renderable) {
            this.target = target.pos;
        }
        else if ((target instanceof Vector2d) || (target instanceof Vector3d) ||
                 (target instanceof ObservableVector2d) || (target instanceof ObservableVector3d)) {
            this.target = target;
        }
        else {
            throw new Error("invalid target for me.Camera2d.follow");
        }
        // if axis is null, camera is moved on target center
        this.follow_axis = (
            typeof(axis) === "undefined" ? this.AXIS.BOTH : axis
        );

        this.smoothFollow = false;

        if (typeof damping !== "number") {
            this.damping = 1;
        } else {
            this.damping = clamp(damping, 0.0, 1.0);
        }

        // force a camera update
        this.updateTarget();

        this.smoothFollow = true;
    }

    /**
     * unfollow the current target
     * @name unfollow
     * @memberof Camera2d
     */
    unfollow() {
        this.target = null;
        this.follow_axis = this.AXIS.NONE;
    }

    /**
     * move the camera upper-left position by the specified offset.
     * @name move
     * @memberof Camera2d
     * @see Camera2d.focusOn
     * @param {number} x
     * @param {number} y
     * @example
     * // Move the camera up by four pixels
     * me.game.viewport.move(0, -4);
     */
    move(x, y) {
        this.moveTo(this.pos.x + x, this.pos.y + y);
    }

    /**
     * move the camera upper-left position to the specified coordinates
     * @name moveTo
     * @memberof Camera2d
     * @see Camera2d.focusOn
     * @param {number} x
     * @param {number} y
     */
    moveTo(x, y) {
        var _x = this.pos.x;
        var _y = this.pos.y;

        this.pos.x = clamp(
            x,
            this.bounds.left,
            this.bounds.width
        );
        this.pos.y = clamp(
            y,
            this.bounds.top,
            this.bounds.height
        );

        //publish the VIEWPORT_ONCHANGE event if necessary
        if (_x !== this.pos.x || _y !== this.pos.y) {
            this.isDirty = true;
        }
    }

    /** @ignore */
    updateTarget() {
        if (this.target) {

            targetV.setV(this.pos);

            switch (this.follow_axis) {
                case this.AXIS.NONE:
                    //this.focusOn(this.target);
                    break;

                case this.AXIS.HORIZONTAL:
                    targetV.x = this._followH(this.target);
                    break;

                case this.AXIS.VERTICAL:
                    targetV.y = this._followV(this.target);
                    break;

                case this.AXIS.BOTH:
                    targetV.x = this._followH(this.target);
                    targetV.y = this._followV(this.target);
                    break;
            }

            if (!this.pos.equals(targetV)) {
                // update the camera position
                if (this.smoothFollow === true && this.damping < 1.0) {
                    // account for floating precision and check if we are close "enough"
                    if (toBeCloseTo(targetV.x, this.pos.x, 2) &&
                        toBeCloseTo(targetV.y, this.pos.y, 2)) {
                        this.pos.setV(targetV);
                        return;
                    } else {
                        this.pos.lerp(targetV, this.damping);
                    }
                } else {
                    this.pos.setV(targetV);
                }
                this.isDirty = true;
            }
        }
    }

    /** @ignore */
    update(dt) {
        // update the camera position
        this.updateTarget(dt);

        if (this._shake.duration > 0) {
            this._shake.duration -= dt;
            if (this._shake.duration <= 0) {
                this._shake.duration = 0;
                this.offset.setZero();
                if (typeof(this._shake.onComplete) === "function") {
                    this._shake.onComplete();
                }
            }
            else {
                if (this._shake.axis === this.AXIS.BOTH ||
                    this._shake.axis === this.AXIS.HORIZONTAL) {
                    this.offset.x = (Math.random() - 0.5) * this._shake.intensity;
                }
                if (this._shake.axis === this.AXIS.BOTH ||
                    this._shake.axis === this.AXIS.VERTICAL) {
                    this.offset.y = (Math.random() - 0.5) * this._shake.intensity;
                }
            }
            // updated!
            this.isDirty = true;
        }

        if (this.isDirty === true) {
            //publish the corresponding message
            emit(VIEWPORT_ONCHANGE, this.pos);
        }

        // check for fade/flash effect
        if ((this._fadeIn.tween != null) || (this._fadeOut.tween != null)) {
            this.isDirty = true;
        }

        if (!this.currentTransform.isIdentity()) {
            this.invCurrentTransform.copy(this.currentTransform).invert();
        } else {
            // reset to default
            this.invCurrentTransform.identity();
        }

        return super.update(dt);
    }

    /**
     * shake the camera
     * @name shake
     * @memberof Camera2d
     * @param {number} intensity maximum offset that the screen can be moved
     * while shaking
     * @param {number} duration expressed in milliseconds
     * @param {number} [axis=me.game.viewport.AXIS.BOTH] specify on which axis to apply the shake effect (see {@link Camera2d.AXIS})
     * @param {Function} [onComplete] callback once shaking effect is over
     * @param {boolean} [force] if true this will override the current effect
     * @example
     * // shake it baby !
     * me.game.viewport.shake(10, 500, me.game.viewport.AXIS.BOTH);
     */
    shake(intensity, duration, axis, onComplete, force) {
        if (this._shake.duration === 0 || force === true) {
            this._shake.intensity = intensity;
            this._shake.duration = duration;
            this._shake.axis = axis || this.AXIS.BOTH;
            this._shake.onComplete = typeof (onComplete) === "function" ? onComplete : undefined;
        }
    }

    /**
     * fadeOut(flash) effect<p>
     * screen is filled with the specified color and slowly goes back to normal
     * @name fadeOut
     * @memberof Camera2d
     * @param {Color|string} color a CSS color value
     * @param {number} [duration=1000] expressed in milliseconds
     * @param {Function} [onComplete] callback once effect is over
     * @example
     * // fade the camera to white upon dying, reload the level, and then fade out back
     * me.game.viewport.fadeIn("#fff", 150, function() {
     *     me.audio.play("die", false);
     *     me.level.reload();
     *     me.game.viewport.fadeOut("#fff", 150);
     * });
     */
    fadeOut(color, duration = 1000, onComplete) {
        this._fadeOut.color = pool.pull("Color").copy(color);
        this._fadeOut.tween = pool.pull("Tween", this._fadeOut.color)
            .to({ alpha: 0.0 }, duration)
            .onComplete(onComplete || null);
        this._fadeOut.tween.isPersistent = true;
        this._fadeOut.tween.start();
    }

    /**
     * fadeIn effect <p>
     * fade to the specified color
     * @name fadeIn
     * @memberof Camera2d
     * @param {Color|string} color a CSS color value
     * @param {number} [duration=1000] expressed in milliseconds
     * @param {Function} [onComplete] callback once effect is over
     * @example
     * // flash the camera to white for 75ms
     * me.game.viewport.fadeIn("#FFFFFF", 75);
     */
    fadeIn(color, duration = 1000, onComplete) {
        this._fadeIn.color = pool.pull("Color").copy(color);
        var _alpha = this._fadeIn.color.alpha;
        this._fadeIn.color.alpha = 0.0;
        this._fadeIn.tween = pool.pull("Tween", this._fadeIn.color)
            .to({ alpha: _alpha }, duration)
            .onComplete(onComplete || null);
        this._fadeIn.tween.isPersistent = true;
        this._fadeIn.tween.start();
    }

    /**
     * set the camera position around the specified object
     * @name focusOn
     * @memberof Camera2d
     * @param {Renderable} target the renderable to focus the camera on
     */
    focusOn(target) {
        var bounds = target.getBounds();
        this.moveTo(
            target.pos.x + bounds.left + (bounds.width / 2),
            target.pos.y + bounds.top + (bounds.height / 2)
        );
    }

    /**
     * check if the specified renderable is in the camera
     * @name isVisible
     * @memberof Camera2d
     * @param {Renderable} obj to be checked against
     * @param {boolean} [floating = obj.floating] if visibility check should be done against screen coordinates
     * @returns {boolean}
     */
    isVisible(obj, floating = obj.floating) {
        if (floating === true || obj.floating === true) {
            // check against screen coordinates
            return renderer.overlaps(obj.getBounds());
        } else {
            // check if within the current camera
            return obj.getBounds().overlaps(this);
        }
    }

    /**
     * convert the given "local" (screen) coordinates into world coordinates
     * @name localToWorld
     * @memberof Camera2d
     * @param {number} x
     * @param {number} y
     * @param {number} [v] an optional vector object where to set the
     * converted value
     * @returns {Vector2d}
     */
    localToWorld(x, y, v) {
        // TODO memoization for one set of coords (multitouch)
        v = v || pool.pull("Vector2d");
        v.set(x, y).add(this.pos).sub(world.pos);
        if (!this.currentTransform.isIdentity()) {
            this.invCurrentTransform.apply(v);
        }
        return v;
    }

    /**
     * convert the given world coordinates into "local" (screen) coordinates
     * @name worldToLocal
     * @memberof Camera2d
     * @param {number} x
     * @param {number} y
     * @param {number} [v] an optional vector object where to set the
     * converted value
     * @returns {Vector2d}
     */
    worldToLocal(x, y, v) {
        // TODO memoization for one set of coords (multitouch)
        v = v || pool.pull("Vector2d");
        v.set(x, y);
        if (!this.currentTransform.isIdentity()) {
            this.currentTransform.apply(v);
        }
        return v.sub(this.pos).add(world.pos);
    }

    /**
     * render the camera effects
     * @ignore
     */
    drawFX(renderer) {
        // fading effect
        if (this._fadeIn.tween) {
            // add an overlay
            renderer.save();
            // reset all transform so that the overaly cover the whole camera area
            renderer.resetTransform();
            renderer.setColor(this._fadeIn.color);
            renderer.fillRect(0, 0, this.width, this.height);
            renderer.restore();
            // remove the tween if over
            if (this._fadeIn.color.alpha === 1.0) {
                this._fadeIn.tween = null;
                pool.push(this._fadeIn.color);
                this._fadeIn.color = null;
            }
        }

        // flashing effect
        if (this._fadeOut.tween) {
            // add an overlay
            renderer.save();
            // reset all transform so that the overaly cover the whole camera area
            renderer.resetTransform();
            renderer.setColor(this._fadeOut.color);
            renderer.fillRect(0, 0, this.width, this.height);
            renderer.restore();
            // remove the tween if over
            if (this._fadeOut.color.alpha === 0.0) {
                this._fadeOut.tween = null;
                pool.push(this._fadeOut.color);
                this._fadeOut.color = null;
            }
        }
    }

    /**
     * draw all object visibile in this viewport
     * @ignore
     */
    draw(renderer, container) {
        var translateX = this.pos.x + this.offset.x;
        var translateY = this.pos.y + this.offset.y;

        // translate the world coordinates by default to screen coordinates
        container.currentTransform.translate(-translateX, -translateY);

        // set the camera projection
        renderer.setProjection(this.projectionMatrix);

        // clip to camera bounds
        renderer.clipRect(
            0,
            0,
            this.width,
            this.height
        );

        this.preDraw(renderer);

        container.preDraw(renderer);

        // draw all objects,
        // specifying the viewport as the rectangle area to redraw
        container.draw(renderer, this);

        // draw the viewport/camera effects
        this.drawFX(renderer);

        container.postDraw(renderer);

        this.postDraw(renderer);

        // translate the world coordinates by default to screen coordinates
        container.currentTransform.translate(translateX, translateY);
    }

}

// a default camera instance to use across all stages
var default_camera;

// default stage settings
var default_settings = {
    cameras : []
};

/**
 * @classdesc
 * a default "Stage" object.
 * every "stage" object (title screen, credits, ingame, etc...) to be managed
 * through the state manager must inherit from this base class.
 * @see state
 */
class Stage {

    /**
     * @param {object} [settings] The stage` parameters
     * @param {Camera2d[]} [settings.cameras=[new me.Camera2d()]] a list of cameras (experimental)
     * @param {Function} [settings.onResetEvent] called by the state manager when reseting the object
     * @param {Function} [settings.onDestroyEvent] called by the state manager before switching to another state
     */
    constructor(settings) {
        /**
         * The list of active cameras in this stage.
         * Cameras will be renderered based on this order defined in this list.
         * Only the "default" camera will be resized when the window or canvas is resized.
         * @public
         * @type {Map<Camera2d>}
         * @name cameras
         * @memberof Stage
         */
        this.cameras = new Map();

        /**
         * The list of active lights in this stage.
         * (Note: Canvas Renderering mode will only properly support one light per stage)
         * @public
         * @type {Map<Light2d>}
         * @name lights
         * @memberof Stage
         * @see Light2d
         * @see Stage.ambientLight
         * @example
         * // create a white spot light
         * var whiteLight = new me.Light2d(0, 0, 140, "#fff", 0.7);
         * // and add the light to this current stage
         * this.lights.set("whiteLight", whiteLight);
         * // set a dark ambient light
         * this.ambientLight.parseCSS("#1117");
         * // make the light follow the mouse
         * me.input.registerPointerEvent("pointermove", me.game.viewport, (event) => {
         *    whiteLight.centerOn(event.gameX, event.gameY);
         * });
         */
        this.lights = new Map();

        /**
         * an ambient light that will be added to the stage rendering
         * @public
         * @type {Color}
         * @name ambientLight
         * @memberof Stage
         * @default "#000000"
         * @see Light2d
         */
        this.ambientLight = new Color(0, 0, 0, 0);

        /**
         * The given constructor options
         * @public
         * @name settings
         * @memberof Stage
         * @type {object}
         */
        this.settings = Object.assign(default_settings, settings || {});
    }

    /**
     * Object reset function
     * @ignore
     */
    reset() {

        // add all defined cameras
        this.settings.cameras.forEach((camera) => {
            this.cameras.set(camera.name, camera);
        });

        // empty or no default camera
        if (this.cameras.has("default") === false) {
            if (typeof default_camera === "undefined") {
                var width = renderer.getWidth();
                var height = renderer.getHeight();
                // new default camera instance
                default_camera = new Camera2d(0, 0, width, height);
            }
            this.cameras.set("default", default_camera);
        }

        // reset the game
        reset();

        // call the onReset Function
        this.onResetEvent.apply(this, arguments);
    }

    /**
     * update function
     * @name update
     * @memberof Stage
     * @ignore
     * @param {number} dt time since the last update in milliseconds.
     * @returns {boolean}
     */
    update(dt) {
        // update all objects (and pass the elapsed time since last frame)
        var isDirty = world.update(dt);

        // update the camera/viewport
        // iterate through all cameras
        this.cameras.forEach(function(camera) {
            if (camera.update(dt) === true) {
                isDirty = true;
            }        });

        // update all lights
        this.lights.forEach((light) => {
            if (light.update(dt) === true) {
                isDirty = true;
            }        });

        return isDirty;
    }

    /**
     * draw the current stage
     * @name draw
     * @memberof Stage
     * @ignore
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer object
     */
    draw(renderer) {
        // iterate through all cameras
        this.cameras.forEach((camera) => {
            // render the root container
            camera.draw(renderer, world);

            // render the ambient light
            if (this.ambientLight.alpha !== 0) {
                renderer.save();
                // iterate through all lights
                this.lights.forEach((light) => {
                    // cut out all lights visible areas
                    renderer.setMask(light.getVisibleArea(), true);
                });
                // fill the screen with the ambient color
                renderer.setColor(this.ambientLight);
                renderer.fillRect(0, 0, camera.width, camera.height);
                // clear all masks
                renderer.clearMask();
                renderer.restore();
            }

            // render all lights
            this.lights.forEach((light) => {
                light.preDraw(renderer, world);
                light.draw(renderer, world);
                light.postDraw(renderer, world);
            });
        });
    }

    /**
     * destroy function
     * @ignore
     */
    destroy() {
        // clear all cameras
        this.cameras.clear();
        // clear all lights
        this.lights.forEach((light) => {
            light.destroy();
        });
        this.lights.clear();
        // notify the object
        this.onDestroyEvent.apply(this, arguments);
    }

    /**
     * onResetEvent function<br>
     * called by the state manager when reseting the object
     * this is typically where you will load a level, add renderables, etc...
     * @name onResetEvent
     * @memberof Stage
     * @param {object} [...arguments] optional arguments passed when switching state
     * @see state#change
     */
    onResetEvent() {
        // execute onResetEvent function if given through the constructor
        if (typeof this.settings.onResetEvent === "function") {
            this.settings.onResetEvent.apply(this, arguments);
        }

    }

    /**
     * onDestroyEvent function<br>
     * called by the state manager before switching to another state
     * @name onDestroyEvent
     * @memberof Stage
     */
    onDestroyEvent() {
        // execute onDestroyEvent function if given through the constructor
        if (typeof this.settings.onDestroyEvent === "function") {
            this.settings.onDestroyEvent.apply(this, arguments);
        }
    }
}

var src = {};

var arraymultimap = {};

var multimap = {};

var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (commonjsGlobal && commonjsGlobal.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (commonjsGlobal && commonjsGlobal.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(multimap, "__esModule", { value: true });
multimap.Multimap = void 0;
var Multimap = /** @class */ (function () {
    function Multimap(operator, iterable) {
        var e_1, _a;
        this.size_ = 0;
        this.map = new Map();
        this.operator = operator;
        if (iterable) {
            try {
                for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                    var _b = __read(iterable_1_1.value, 2), key = _b[0], value = _b[1];
                    this.put(key, value);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return this;
    }
    Object.defineProperty(Multimap.prototype, "size", {
        get: function () {
            return this.size_;
        },
        enumerable: false,
        configurable: true
    });
    Multimap.prototype.get = function (key) {
        var values = this.map.get(key);
        if (values) {
            return this.operator.clone(values);
        }
        else {
            return this.operator.create();
        }
    };
    Multimap.prototype.put = function (key, value) {
        var values = this.map.get(key);
        if (!values) {
            values = this.operator.create();
        }
        if (!this.operator.add(value, values)) {
            return false;
        }
        this.map.set(key, values);
        this.size_++;
        return true;
    };
    Multimap.prototype.putAll = function (arg1, arg2) {
        var e_2, _a, e_3, _b;
        var pushed = 0;
        if (arg2) {
            var key = arg1;
            var values = arg2;
            try {
                for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                    var value = values_1_1.value;
                    this.put(key, value);
                    pushed++;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        else if (arg1 instanceof Multimap) {
            try {
                for (var _c = __values(arg1.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
                    this.put(key, value);
                    pushed++;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        else {
            throw new TypeError("unexpected arguments");
        }
        return pushed > 0;
    };
    Multimap.prototype.has = function (key) {
        return this.map.has(key);
    };
    Multimap.prototype.hasEntry = function (key, value) {
        return this.operator.has(value, this.get(key));
    };
    Multimap.prototype.delete = function (key) {
        this.size_ -= this.operator.size(this.get(key));
        return this.map.delete(key);
    };
    Multimap.prototype.deleteEntry = function (key, value) {
        var current = this.get(key);
        if (!this.operator.delete(value, current)) {
            return false;
        }
        this.map.set(key, current);
        this.size_--;
        return true;
    };
    Multimap.prototype.clear = function () {
        this.map.clear();
        this.size_ = 0;
    };
    Multimap.prototype.keys = function () {
        return this.map.keys();
    };
    Multimap.prototype.entries = function () {
        var self = this;
        function gen() {
            var _a, _b, _c, key, values, values_2, values_2_1, value, e_4_1, e_5_1;
            var e_5, _d, e_4, _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        _f.trys.push([0, 11, 12, 13]);
                        _a = __values(self.map.entries()), _b = _a.next();
                        _f.label = 1;
                    case 1:
                        if (!!_b.done) return [3 /*break*/, 10];
                        _c = __read(_b.value, 2), key = _c[0], values = _c[1];
                        _f.label = 2;
                    case 2:
                        _f.trys.push([2, 7, 8, 9]);
                        values_2 = (e_4 = void 0, __values(values)), values_2_1 = values_2.next();
                        _f.label = 3;
                    case 3:
                        if (!!values_2_1.done) return [3 /*break*/, 6];
                        value = values_2_1.value;
                        return [4 /*yield*/, [key, value]];
                    case 4:
                        _f.sent();
                        _f.label = 5;
                    case 5:
                        values_2_1 = values_2.next();
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_4_1 = _f.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (values_2_1 && !values_2_1.done && (_e = values_2.return)) _e.call(values_2);
                        }
                        finally { if (e_4) throw e_4.error; }
                        return [7 /*endfinally*/];
                    case 9:
                        _b = _a.next();
                        return [3 /*break*/, 1];
                    case 10: return [3 /*break*/, 13];
                    case 11:
                        e_5_1 = _f.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 13];
                    case 12:
                        try {
                            if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                        }
                        finally { if (e_5) throw e_5.error; }
                        return [7 /*endfinally*/];
                    case 13: return [2 /*return*/];
                }
            });
        }
        return gen();
    };
    Multimap.prototype.values = function () {
        var self = this;
        function gen() {
            var _a, _b, _c, value, e_6_1;
            var e_6, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _e.trys.push([0, 5, 6, 7]);
                        _a = __values(self.entries()), _b = _a.next();
                        _e.label = 1;
                    case 1:
                        if (!!_b.done) return [3 /*break*/, 4];
                        _c = __read(_b.value, 2), value = _c[1];
                        return [4 /*yield*/, value];
                    case 2:
                        _e.sent();
                        _e.label = 3;
                    case 3:
                        _b = _a.next();
                        return [3 /*break*/, 1];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        e_6_1 = _e.sent();
                        e_6 = { error: e_6_1 };
                        return [3 /*break*/, 7];
                    case 6:
                        try {
                            if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                        }
                        finally { if (e_6) throw e_6.error; }
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        }
        return gen();
    };
    Multimap.prototype.forEach = function (callback, thisArg) {
        var e_7, _a;
        try {
            for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                callback.call(thisArg === undefined ? this : thisArg, value, key, this);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    Multimap.prototype[Symbol.iterator] = function () {
        return this.entries();
    };
    Multimap.prototype.asMap = function () {
        var e_8, _a;
        var ret = new Map();
        try {
            for (var _b = __values(this.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                ret.set(key, this.operator.clone(this.get(key)));
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_8) throw e_8.error; }
        }
        return ret;
    };
    return Multimap;
}());
multimap.Multimap = Multimap;

var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(arraymultimap, "__esModule", { value: true });
arraymultimap.ArrayMultimap = void 0;
var multimap_1$1 = multimap;
var ArrayMultimap = /** @class */ (function (_super) {
    __extends$1(ArrayMultimap, _super);
    function ArrayMultimap(iterable) {
        return _super.call(this, new ArrayOperator(), iterable) || this;
    }
    Object.defineProperty(ArrayMultimap.prototype, Symbol.toStringTag, {
        get: function () {
            return "ArrayMultimap";
        },
        enumerable: false,
        configurable: true
    });
    return ArrayMultimap;
}(multimap_1$1.Multimap));
arraymultimap.ArrayMultimap = ArrayMultimap;
var ArrayOperator = /** @class */ (function () {
    function ArrayOperator() {
    }
    ArrayOperator.prototype.create = function () {
        return [];
    };
    ArrayOperator.prototype.clone = function (collection) {
        return collection.slice();
    };
    ArrayOperator.prototype.add = function (value, collection) {
        collection.push(value);
        return true;
    };
    ArrayOperator.prototype.size = function (collection) {
        return collection.length;
    };
    ArrayOperator.prototype.delete = function (value, collection) {
        var index = collection.indexOf(value);
        if (index > -1) {
            collection.splice(index, 1);
            return true;
        }
        return false;
    };
    ArrayOperator.prototype.has = function (value, collection) {
        return collection.includes(value);
    };
    return ArrayOperator;
}());

var setmultimap = {};

var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(setmultimap, "__esModule", { value: true });
setmultimap.SetMultimap = void 0;
var multimap_1 = multimap;
var SetMultimap = /** @class */ (function (_super) {
    __extends(SetMultimap, _super);
    function SetMultimap(iterable) {
        return _super.call(this, new SetOperator(), iterable) || this;
    }
    Object.defineProperty(SetMultimap.prototype, Symbol.toStringTag, {
        get: function () {
            return "SetMultimap";
        },
        enumerable: false,
        configurable: true
    });
    return SetMultimap;
}(multimap_1.Multimap));
setmultimap.SetMultimap = SetMultimap;
var SetOperator = /** @class */ (function () {
    function SetOperator() {
    }
    SetOperator.prototype.create = function () {
        return new Set();
    };
    SetOperator.prototype.clone = function (collection) {
        return new Set(collection);
    };
    SetOperator.prototype.add = function (value, collection) {
        var prev = collection.size;
        collection.add(value);
        return prev !== collection.size;
    };
    SetOperator.prototype.size = function (collection) {
        return collection.size;
    };
    SetOperator.prototype.delete = function (value, collection) {
        return collection.delete(value);
    };
    SetOperator.prototype.has = function (value, collection) {
        return collection.has(value);
    };
    return SetOperator;
}());

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SetMultimap = exports.ArrayMultimap = void 0;
	var arraymultimap_1 = arraymultimap;
	Object.defineProperty(exports, "ArrayMultimap", { enumerable: true, get: function () { return arraymultimap_1.ArrayMultimap; } });
	var setmultimap_1 = setmultimap;
	Object.defineProperty(exports, "SetMultimap", { enumerable: true, get: function () { return setmultimap_1.SetMultimap; } });
} (src));

/**
 * a basic texture cache object
 * @ignore
 */
class TextureCache {

    /**
     * @ignore
     */
    constructor(max_size) {
        // cache uses an array to allow for duplicated key
        this.cache = new src.ArrayMultimap();
        this.tinted = new Map();
        this.units = new Map();
        this.max_size = max_size || Infinity;
        this.clear();
    }

    /**
     * @ignore
     */
    clear() {
        this.cache.clear();
        this.tinted.clear();
        this.units.clear();
        this.length = 0;
    }

    /**
     * @ignore
     */
    validate() {
        if (this.length >= this.max_size) {
            // TODO: Merge textures instead of throwing an exception
            throw new Error(
                "Texture cache overflow: " + this.max_size +
                " texture units available for this GPU."
            );
        }
    }

    /**
     * @ignore
     */
    get(image, atlas) {
        var entry;

        if (typeof atlas === "undefined") {
            entry = this.cache.get(image)[0];
        } else {
            // manage cases where a specific atlas is specified
            this.cache.forEach((value, key) => {
                var _atlas = value.getAtlas();
                if (key === image && _atlas[0].width === atlas.framewidth && _atlas[0].height === atlas.frameheight) {
                    entry = value;
                }
            });
        }

        if (typeof entry === "undefined") {
            if (!atlas) {
                atlas = createAtlas(image.width, image.height, image.src ? getBasename(image.src) : undefined);
            }
            entry = new TextureAtlas(atlas, image, false);
            this.set(image, entry);
        }

        return entry;
    }

    /**
     * @ignore
     */
    delete(image) {
        if (!this.cache.has(image)) {
            this.cache.delete(image);
        }
    }

    /**
     * @ignore
     */
    tint(src, color) {
        // make sure the src is in the cache
        var image_cache = this.tinted.get(src);

        if (image_cache === undefined) {
            image_cache = this.tinted.set(src, new Map());
        }

        if (!image_cache.has(color)) {
            image_cache.set(color, renderer.tint(src, color, "multiply"));
        }

        return image_cache.get(color);
    }

    /**
     * @ignore
     */
    set(image, texture) {
        var width = image.width;
        var height = image.height;

        // warn if a non POT texture is added to the cache when using WebGL1
        if (renderer.WebGLVersion === 1 && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {
            var src = typeof image.src !== "undefined" ? image.src : image;
            console.warn(
                "[Texture] " + src + " is not a POT texture " +
                "(" + width + "x" + height + ")"
            );
        }
        return this.cache.put(image, texture);
    }

    /**
     * @ignore
     */
    getUnit(texture) {
        if (!this.units.has(texture)) {
            this.validate();
            this.units.set(texture, this.length++);
        }
        return this.units.get(texture);
    }
}

/**
 * create a simple 1 frame texture atlas based on the given parameters
 * @ignore
 */
function createAtlas(width, height, name = "default", repeat = "no-repeat") {
   return {
       "meta" : {
           "app" : "melonJS",
           "size" : { "w" : width, "h" : height },
           "repeat" : repeat,
           "image" : "default"
       },
       "frames" : [{
           "filename" : name,
           "frame" : { "x" : 0, "y" : 0, "w" : width, "h" : height }
       }]
   };
}

/**
 * @classdesc
 * A Texture atlas class, currently supports : <br>
 * - [TexturePacker]{@link http://www.codeandweb.com/texturepacker/} : through JSON export (standard and multipack texture atlas) <br>
 * - [ShoeBox]{@link http://renderhjs.net/shoebox/} : through JSON export using the
 * melonJS setting [file]{@link https://github.com/melonjs/melonJS/raw/master/media/shoebox_JSON_export.sbx} <br>
 * - [Free Texture Packer]{@link http://free-tex-packer.com/app/} : through JSON export (standard and multipack texture atlas) <br>
 * - Standard (fixed cell size) spritesheet : through a {framewidth:xx, frameheight:xx, anchorPoint:me.Vector2d} object
 * );
 */
class TextureAtlas {
    /**
     * @param {object|object[]} atlases atlas information. See {@link loader.getJSON}
     * @param {HTMLImageElement|HTMLCanvasElement|string|HTMLImageElement[]|HTMLCanvasElement[]|string[]} [src=atlas.meta.image] Image source
     * @param {boolean} [cache=false] Use true to skip caching this Texture
     * @example
     * // create a texture atlas from a JSON Object
     * game.texture = new me.TextureAtlas(
     *     me.loader.getJSON("texture")
     * );
     *
     * // create a texture atlas from a multipack JSON Object
     * game.texture = new me.TextureAtlas([
     *     me.loader.getJSON("texture-0"),
     *     me.loader.getJSON("texture-1"),
     *     me.loader.getJSON("texture-2")
     * ]);
     *
     * // create a texture atlas for a spritesheet with an anchorPoint in the center of each frame
     * game.texture = new me.TextureAtlas(
     *     {
     *         framewidth : 32,
     *         frameheight : 32,
     *         anchorPoint : new me.Vector2d(0.5, 0.5)
     *     },
     *     me.loader.getImage("spritesheet")
     */
    constructor (atlases, src, cache) {
        /**
         * to identify the atlas format (e.g. texture packer)
         * @ignore
         */
        this.format = null;

        /**
         * the texture source(s) itself
         * @type {Map}
         * @ignore
         */
        this.sources = new Map();

        /**
         * the atlas dictionnaries
         * @type {Map}
         * @ignore
         */
        this.atlases = new Map();

        // parse given atlas(es) paremeters
        if (typeof (atlases) !== "undefined") {
            // normalize to array to keep the following code generic
            atlases = Array.isArray(atlases) ? atlases : [atlases];
            for (var i in atlases) {
                var atlas = atlases[i];

                if (typeof(atlas.meta) !== "undefined") {
                    // Texture Packer or Free Texture Packer
                    if (atlas.meta.app.includes("texturepacker") || atlas.meta.app.includes("free-tex-packer")) {
                        this.format = "texturepacker";
                        // set the texture
                        if (typeof(src) === "undefined") {
                            // get the texture name from the atlas meta data
                            var image = loader.getImage(atlas.meta.image);
                            if (!image) {
                                throw new Error(
                                    "Atlas texture '" + image + "' not found"
                                );
                            }
                            this.sources.set(atlas.meta.image, image);
                        } else {
                            this.sources.set(atlas.meta.image || "default", typeof src === "string" ? loader.getImage(src) : src);
                        }
                        this.repeat = "no-repeat";
                    }
                    // ShoeBox
                    else if (atlas.meta.app.includes("ShoeBox")) {
                        if (!atlas.meta.exporter || !atlas.meta.exporter.includes("melonJS")) {
                            throw new Error(
                                "ShoeBox requires the JSON exporter : " +
                                "https://github.com/melonjs/melonJS/tree/master/media/shoebox_JSON_export.sbx"
                            );
                        }
                        this.format = "ShoeBox";
                        this.repeat = "no-repeat";
                        this.sources.set("default", typeof src === "string" ? loader.getImage(src) : src);
                    }
                    // Internal texture atlas
                    else if (atlas.meta.app.includes("melonJS")) {
                        this.format = "melonJS";
                        this.repeat = atlas.meta.repeat || "no-repeat";
                        this.sources.set("default", typeof src === "string" ? loader.getImage(src) : src);
                    }
                    // initialize the atlas
                    this.atlases.set(atlas.meta.image || "default", this.parse(atlas));

                } else {
                    // a regular spritesheet
                    if (typeof(atlas.framewidth) !== "undefined" &&
                        typeof(atlas.frameheight) !== "undefined") {
                        this.format = "Spritesheet (fixed cell size)";
                        this.repeat = "no-repeat";

                        if (typeof(src) !== "undefined") {
                            // overwrite if specified
                            atlas.image = typeof src === "string" ? loader.getImage(src) : src;
                        }
                        // initialize the atlas
                        this.atlases.set("default", this.parseFromSpriteSheet(atlas));
                        this.sources.set("default", atlas.image);

                    }
                }
            } // end forEach
        }

        // if format not recognized
        if (this.atlases.length === 0) {
            throw new Error("texture atlas format not supported");
        }

        // Add self to TextureCache if cache !== false
        if (cache !== false) {
            this.sources.forEach((source) => {
                if (cache instanceof TextureCache) {
                    cache.set(source, this);
                } else {
                    renderer.cache.set(source, this);
                }
            });
        }
    }

    /**
     * build an atlas from the given data
     * @ignore
     */
    parse(data) {
        var atlas = {};

        data.frames.forEach((frame) => {
            // fix wrongly formatted JSON (e.g. last dummy object in ShoeBox)
            if (frame.hasOwnProperty("filename")) {
                // Source coordinates
                var s = frame.frame;

                var originX, originY;
                // Pixel-based offset origin from the top-left of the source frame
                var hasTextureAnchorPoint = (frame.spriteSourceSize && frame.sourceSize && frame.pivot);
                if (hasTextureAnchorPoint) {
                    originX = (frame.sourceSize.w * frame.pivot.x) - ((frame.trimmed) ? frame.spriteSourceSize.x : 0);
                    originY = (frame.sourceSize.h * frame.pivot.y) - ((frame.trimmed) ? frame.spriteSourceSize.y : 0);
                }

                atlas[frame.filename] = {
                    name         : frame.filename, // frame name
                    texture      : data.meta.image || "default", // the source texture
                    offset       : new Vector2d(s.x, s.y),
                    anchorPoint  : (hasTextureAnchorPoint) ? new Vector2d(originX / s.w, originY / s.h) : null,
                    trimmed      : !!frame.trimmed,
                    width        : s.w,
                    height       : s.h,
                    angle        : (frame.rotated === true) ? -ETA : 0
                };
                this.addUVs(atlas, frame.filename, data.meta.size.w, data.meta.size.h);
            }
        });
        return atlas;
    }

    /**
     * build an atlas from the given spritesheet
     * @ignore
     */
    parseFromSpriteSheet(data) {
        var atlas = {};
        var image = data.image;
        var spacing = data.spacing || 0;
        var margin = data.margin || 0;

        var width = image.width;
        var height = image.height;

        // calculate the sprite count (line, col)
        var spritecount = pool.pull("Vector2d",
            ~~((width - margin + spacing) / (data.framewidth + spacing)),
            ~~((height - margin + spacing) / (data.frameheight + spacing))
        );

        // verifying the texture size
        if ((width % (data.framewidth + spacing)) !== 0 ||
            (height % (data.frameheight + spacing)) !== 0) {
            var computed_width = spritecount.x * (data.framewidth + spacing);
            var computed_height = spritecount.y * (data.frameheight + spacing);
            if (computed_width - width !== spacing && computed_height - height !== spacing) {
                // "truncate size" if delta is different from the spacing size
                width = computed_width;
                height = computed_height;
                // warning message
                console.warn(
                    "Spritesheet Texture for image: " + image.src +
                    " is not divisible by " + (data.framewidth + spacing) +
                    "x" + (data.frameheight + spacing) +
                    ", truncating effective size to " + width + "x" + height
                );
            }
        }

        // build the local atlas
        for (var frame = 0, count = spritecount.x * spritecount.y; frame < count; frame++) {
            var name = "" + frame;
            atlas[name] = {
                name        : name,
                texture     : "default", // the source texture
                offset      : new Vector2d(
                    margin + (spacing + data.framewidth) * (frame % spritecount.x),
                    margin + (spacing + data.frameheight) * ~~(frame / spritecount.x)
                ),
                anchorPoint : (data.anchorPoint || null),
                trimmed     : false,
                width       : data.framewidth,
                height      : data.frameheight,
                angle       : 0
            };
            this.addUVs(atlas, name, width, height);
        }

        pool.push(spritecount);

        return atlas;
    }

    /**
     * return the default or specified atlas dictionnary
     * @param {string} [name] atlas name in case of multipack textures
     * @returns {object}
     */
    getAtlas(name) {
        if (typeof name === "string") {
            return this.atlases.get(name);
        } else {
            return this.atlases.values().next().value;
        }
    }

    /**
     * return the format of the atlas dictionnary
     * @returns {string} will return "texturepacker", or "ShoeBox", or "melonJS", or "Spritesheet (fixed cell size)"
     */
    getFormat() {
        return this.format;
    }

    /**
     * return the source texture for the given region (or default one if none specified)
     * @param {object} [region] region name in case of multipack textures
     * @returns {HTMLImageElement|HTMLCanvasElement}
     */
    getTexture(region) {
        if ((typeof region === "object") && (typeof region.texture === "string")) {
            return this.sources.get(region.texture);
        } else {
            return this.sources.values().next().value;
        }
    }

    /**
     * add a region to the atlas
     * @param {string} name region mame
     * @param {number} x x origin of the region
     * @param {number} y y origin of the region
     * @param {number} w width of the region
     * @param {number} h height of the region
     * @returns {object} the created region
     */
    addRegion(name, x, y, w, h) {
        // TODO: Require proper atlas regions instead of caching arbitrary region keys
        if (renderer.settings.verbose === true) {
            console.warn("Adding texture region", name, "for texture", this);
        }

        var source = this.getTexture();
        var atlas = this.getAtlas();
        var dw = source.width;
        var dh = source.height;

        atlas[name] = {
            name    : name,
            offset  : new Vector2d(x, y),
            width   : w,
            height  : h,
            angle   : 0
        };

        this.addUVs(atlas, name, dw, dh);

        return atlas[name];
    }

    /**
     * return a normalized region (or frame) information for the specified sprite name
     * @param {string} name name of the sprite
     * @param {string} [atlas] name of a specific atlas where to search for the region
     * @returns {object}
     */
    getRegion(name, atlas) {
        var region;
        if (typeof atlas === "string") {
            region = this.getAtlas(atlas)[name];
        } else {
            // look for the given region in each existing atlas
            this.atlases.forEach(function (atlas) {
                if (typeof atlas[name] !== "undefined") {
                    // there should be only one
                    region = atlas[name];
                }
            });
        }
        return region;
    }

    /**
     * return the uvs mapping for the given region
     * @param {object} name region (or frame) name
     * @returns {Float32Array} region Uvs
     */
    getUVs(name) {
        // Get the source texture region
        var region = this.getRegion(name);

        if (typeof(region) === "undefined") {
            // TODO: Require proper atlas regions instead of caching arbitrary region keys
            var keys = name.split(","),
                sx = +keys[0],
                sy = +keys[1],
                sw = +keys[2],
                sh = +keys[3];
            region = this.addRegion(name, sx, sy, sw, sh);
        }
        return region.uvs;
    }

    /**
     * add uvs mapping for the given region
     * @param {object} atlas the atlas dictionnary where the region is define
     * @param {object} name region (or frame) name
     * @param {number} w the width of the region
     * @param {number} h the height of the region
     * @returns {Float32Array} the created region UVs
     */
    addUVs(atlas, name, w, h) {
        // ignore if using the Canvas Renderer
        if (renderer instanceof WebGLRenderer) {
            // Source coordinates
            var s = atlas[name].offset;
            var sw = atlas[name].width;
            var sh = atlas[name].height;

            atlas[name].uvs = new Float32Array([
                s.x / w,        // u0 (left)
                s.y / h,        // v0 (top)
                (s.x + sw) / w, // u1 (right)
                (s.y + sh) / h  // v1 (bottom)
            ]);
            // Cache source coordinates
            // TODO: Remove this when the Batcher only accepts a region name
            var key = s.x + "," + s.y + "," + w + "," + h;
            atlas[key] = atlas[name];
        }
        return atlas[name].uvs;
    }

    /**
     * Create a sprite object using the first region found using the specified name
     * @param {string} name name of the sprite
     * @param {object} [settings] Additional settings passed to the {@link Sprite} contructor
     * @param {boolean} [nineSlice=false] if true returns a 9-slice sprite
     * @returns {Sprite|NineSliceSprite}
     * @example
     * // create a new texture object under the `game` namespace
     * game.texture = new me.TextureAtlas(
     *    me.loader.getJSON("texture"),
     *    me.loader.getImage("texture")
     * );
     * ...
     * ...
     * // create a new "coin" sprite
     * var sprite = game.texture.createSpriteFromName("coin.png");
     * // set the renderable position to bottom center
     * sprite.anchorPoint.set(0.5, 1.0);
     * ...
     * ...
     * // create a 9-slice sprite
     * var dialogPanel = game.texture.createSpriteFromName(
     *    "rpg_dialo.png",
     *    // width & height are mandatory for 9-slice sprites
     *    { width: this.width, height: this.height },
     *    true
     * );
     */
    createSpriteFromName(name, settings, nineSlice = false) {
        // instantiate a new sprite object
        return pool.pull(
            nineSlice === true ? "me.NineSliceSprite" : "me.Sprite",
            0, 0,
            Object.assign({
                image: this,
                region : name
            }, settings || {})
        );
    }

    /**
     * Create an animation object using the first region found using all specified names
     * @param {string[]|number[]} names list of names for each sprite
     * (when manually creating a Texture out of a spritesheet, only numeric values are authorized)
     * @param {object} [settings] Additional settings passed to the {@link Sprite} contructor
     * @returns {Sprite}
     * @example
     * // create a new texture object under the `game` namespace
     * game.texture = new me.TextureAtlas(
     *     me.loader.getJSON("texture"),
     *     me.loader.getImage("texture")
     * );
     *
     * // create a new Animated Sprite
     * var sprite = game.texture.createAnimationFromName([
     *     "walk0001.png", "walk0002.png", "walk0003.png",
     *     "walk0004.png", "walk0005.png", "walk0006.png",
     *     "walk0007.png", "walk0008.png", "walk0009.png",
     *     "walk0010.png", "walk0011.png"
     * ]);
     *
     * // define an additional basic walking animation
     * sprite.addAnimation ("simple_walk", [0,2,1]);
     * // you can also use frame name to define your animation
     * sprite.addAnimation ("speed_walk", ["walk0007.png", "walk0008.png", "walk0009.png", "walk0010.png"]);
     * // set the default animation
     * sprite.setCurrentAnimation("simple_walk");
     * // set the renderable position to bottom center
     * sprite.anchorPoint.set(0.5, 1.0);
     */
    createAnimationFromName(names, settings) {
        var tpAtlas = [], indices = {};
        var width = 0, height = 0;
        var region;
        // iterate through the given names
        // and create a "normalized" atlas
        for (var i = 0; i < names.length; ++i) {
            region = this.getRegion(names[i]);
            if (region == null) {
                // throw an error
                throw new Error("Texture - region for " + names[i] + " not found");
            }
            tpAtlas[i] = region;
            // save the corresponding index
            indices[names[i]] = i;
            // calculate the max size of a frame
            width = Math.max(region.width, width);
            height = Math.max(region.height, height);
        }
        // instantiate a new animation sheet object
        return new Sprite(0, 0, Object.assign({
            image: this,
            framewidth: width,
            frameheight: height,
            margin: 0,
            spacing: 0,
            atlas: tpAtlas,
            atlasIndices: indices
        }, settings || {}));
    }
}

/**
 * @classdesc
 * An object to display a fixed or animated sprite on screen.
 * @augments Renderable
 */
class Sprite extends Renderable {
    /**
     * @param {number} x the x coordinates of the sprite object
     * @param {number} y the y coordinates of the sprite object
     * @param {object} settings Configuration parameters for the Sprite object
     * @param {HTMLImageElement|HTMLCanvasElement|TextureAtlas|string} settings.image reference to spritesheet image, a texture atlas or to a texture atlas
     * @param {string} [settings.name=""] name of this object
     * @param {string} [settings.region] region name of a specific region to use when using a texture atlas, see {@link TextureAtlas}
     * @param {number} [settings.framewidth] Width of a single frame within the spritesheet
     * @param {number} [settings.frameheight] Height of a single frame within the spritesheet
     * @param {string|Color} [settings.tint] a tint to be applied to this sprite
     * @param {number} [settings.flipX] flip the sprite on the horizontal axis
     * @param {number} [settings.flipY] flip the sprite on the vertical axis
     * @param {Vector2d} [settings.anchorPoint={x:0.5, y:0.5}] Anchor point to draw the frame at (defaults to the center of the frame).
     * @example
     * // create a single sprite from a standalone image, with anchor in the center
     * var sprite = new me.Sprite(0, 0, {
     *     image : "PlayerTexture",
     *     framewidth : 64,
     *     frameheight : 64,
     *     anchorPoint : new me.Vector2d(0.5, 0.5)
     * });
     *
     * // create a single sprite from a packed texture
     * game.texture = new me.TextureAtlas(
     *     me.loader.getJSON("texture"),
     *     me.loader.getImage("texture")
     * );
     * var sprite = new me.Sprite(0, 0, {
     *     image : game.texture,
     *     region : "npc2.png",
     * });
     */
    constructor(x, y, settings) {

        // call the super constructor
        super(x, y, 0, 0);

        /**
         * pause and resume animation
         * @public
         * @type {boolean}
         * @default false
         * @name Sprite#animationpause
         */
        this.animationpause = false;

        /**
         * animation cycling speed (delay between frame in ms)
         * @public
         * @type {number}
         * @default 100
         * @name Sprite#animationspeed
         */
        this.animationspeed = 100;

        /**
         * global offset for the position to draw from on the source image.
         * @public
         * @type {Vector2d}
         * @default <0.0,0.0>
         * @name offset
         * @memberof Sprite#
         */
        this.offset = pool.pull("Vector2d", 0, 0);

        /**
         * The source texture object this sprite object is using
         * @public
         * @type {TextureAtlas}
         * @name source
         * @memberof Sprite#
         */
        this.source = null;

        // hold all defined animation
        this.anim = {};

        // a flag to reset animation
        this.resetAnim = undefined;

        // current frame information
        // (reusing current, any better/cleaner place?)
        this.current = {
            // the current animation name
            name : "default",
            // length of the current animation name
            length : 0,
            //current frame texture offset
            offset : pool.pull("Vector2d"),
            // current frame size
            width : 0,
            height : 0,
            // Source rotation angle for pre-rotating the source image
            angle : 0,
            // current frame index
            idx : 0
        };

        // animation frame delta
        this.dt = 0;

        // flicker settings
        this._flicker = {
            isFlickering : false,
            duration : 0,
            callback : null,
            state : false
        };

        // set the proper image/texture to use
        if (settings.image instanceof TextureAtlas) {
            this.source = settings.image;
            this.image = this.source.getTexture();
            this.textureAtlas = settings.image;
            // check for defined region
            if (typeof (settings.region) !== "undefined") {
                // use a texture atlas
                var region = this.source.getRegion(settings.region);
                if (region) {
                    // set the sprite region within the texture
                    this.setRegion(region);
                    // update the default "current" frame size
                    this.current.width = settings.framewidth || region.width;
                    this.current.height = settings.frameheight || region.height;
                } else {
                    // throw an error
                    throw new Error("Texture - region for " + settings.region + " not found");
                }
            }
        } else {
            // HTMLImageElement/Canvas or {string}
            this.image = (typeof settings.image === "object") ? settings.image : loader.getImage(settings.image);
            // throw an error if image ends up being null/undefined
            if (!this.image) {
                throw new Error("me.Sprite: '" + settings.image + "' image/texture not found!");
            }
            // update the default "current" frame size
            this.current.width = settings.framewidth = settings.framewidth || this.image.width;
            this.current.height = settings.frameheight = settings.frameheight || this.image.height;
            this.source = renderer.cache.get(this.image, settings);
            this.textureAtlas = this.source.getAtlas();
        }

        // store/reset the current atlas information if specified
        if (typeof(settings.atlas) !== "undefined") {
            this.textureAtlas = settings.atlas;
            this.atlasIndices = settings.atlasIndices;
        }

        // resize based on the active frame
        this.width = this.current.width;
        this.height = this.current.height;

        // apply flip flags if specified
        if (typeof (settings.flipX) !== "undefined") {
            this.flipX(!!settings.flipX);
        }
        if (typeof (settings.flipY) !== "undefined") {
            this.flipY(!!settings.flipY);
        }

        // set the default rotation angle is defined in the settings
        // * WARNING: rotating sprites decreases performance with Canvas Renderer
        if (typeof (settings.rotation) !== "undefined") {
            this.rotate(settings.rotation);
        }

        // update anchorPoint
        if (settings.anchorPoint) {
            this.anchorPoint.set(settings.anchorPoint.x, settings.anchorPoint.y);
        }

        if (typeof (settings.tint) !== "undefined") {
            this.tint.setColor(settings.tint);
        }

        // set the sprite name if specified
        if (typeof (settings.name) === "string") {
            this.name = settings.name;
        }

        // displaying order
        if (typeof settings.z !== "undefined") {
            this.pos.z = settings.z;
        }
        // for sprite, addAnimation will return !=0
        if (this.addAnimation("default", null) !== 0) {
            // set as default
            this.setCurrentAnimation("default");
        }

        // enable currentTransform for me.Sprite based objects
        this.autoTransform = true;
    }

    /**
     * return the flickering state of the object
     * @name isFlickering
     * @memberof Sprite
     * @returns {boolean}
     */
    isFlickering() {
        return this._flicker.isFlickering;
    }

    /**
     * make the object flicker
     * @name flicker
     * @memberof Sprite
     * @param {number} duration expressed in milliseconds
     * @param {Function} callback Function to call when flickering ends
     * @returns {Sprite} Reference to this object for method chaining
     * @example
     * // make the object flicker for 1 second
     * // and then remove it
     * this.flicker(1000, function () {
     *     me.game.world.removeChild(this);
     * });
     */
    flicker(duration, callback) {
        this._flicker.duration = duration;
        if (this._flicker.duration <= 0) {
            this._flicker.isFlickering = false;
            this._flicker.callback = null;
        }
        else if (!this._flicker.isFlickering) {
            this._flicker.callback = callback;
            this._flicker.isFlickering = true;
        }
        return this;
    }

    /**
     * add an animation <br>
     * For fixed-sized cell sprite sheet, the index list must follow the
     * logic as per the following example :<br>
     * <img src="images/spritesheet_grid.png"/>
     * @name addAnimation
     * @memberof Sprite
     * @param {string} name animation id
     * @param {number[]|string[]|object[]} index list of sprite index or name
     * defining the animation. Can also use objects to specify delay for each frame, see below
     * @param {number} [animationspeed] cycling speed for animation in ms
     * @returns {number} frame amount of frame added to the animation (delay between each frame).
     * @see Sprite#animationspeed
     * @example
     * // walking animation
     * this.addAnimation("walk", [ 0, 1, 2, 3, 4, 5 ]);
     * // standing animation
     * this.addAnimation("stand", [ 11, 12 ]);
     * // eating animation
     * this.addAnimation("eat", [ 6, 6 ]);
     * // rolling animation
     * this.addAnimation("roll", [ 7, 8, 9, 10 ]);
     * // slower animation
     * this.addAnimation("roll", [ 7, 8, 9, 10 ], 200);
     * // or get more specific with delay for each frame. Good solution instead of repeating:
     * this.addAnimation("turn", [{ name: 0, delay: 200 }, { name: 1, delay: 100 }])
     * // can do this with atlas values as well:
     * this.addAnimation("turn", [{ name: "turnone", delay: 200 }, { name: "turntwo", delay: 100 }])
     * // define an dying animation that stop on the last frame
     * this.addAnimation("die", [{ name: 3, delay: 200 }, { name: 4, delay: 100 }, { name: 5, delay: Infinity }])
     * // set the standing animation as default
     * this.setCurrentAnimation("stand");
     */
    addAnimation(name, index, animationspeed) {
        this.anim[name] = {
            name : name,
            frames : [],
            idx : 0,
            length : 0
        };

        // # of frames
        var counter = 0;

        if (typeof (this.textureAtlas) !== "object") {
            return 0;
        }


        if (index == null) {
            index = [];
            // create a default animation with all frame
            Object.keys(this.textureAtlas).forEach(function (v, i) {
                index[i] = i;
            });
        }

        // set each frame configuration (offset, size, etc..)
        for (var i = 0, len = index.length; i < len; i++) {
            var frame = index[i];
            var frameObject;
            if (typeof(frame) === "number" || typeof(frame) === "string") {
                frameObject = {
                    name: frame,
                    delay: animationspeed || this.animationspeed
                };
            }
            else {
              frameObject = frame;
            }
            var frameObjectName = frameObject.name;
            if (typeof(frameObjectName) === "number") {
                if (typeof (this.textureAtlas[frameObjectName]) !== "undefined") {
                    // TODO: adding the cache source coordinates add undefined entries in webGL mode
                    this.anim[name].frames[i] = Object.assign(
                        {},
                        this.textureAtlas[frameObjectName],
                        frameObject
                    );
                    counter++;
                }
            } else { // string
                if (this.source.getFormat().includes("Spritesheet")) {
                    throw new Error(
                        "string parameters for addAnimation are not allowed for standard spritesheet based Texture"
                    );
                } else {
                    this.anim[name].frames[i] = Object.assign(
                        {},
                        this.textureAtlas[this.atlasIndices[frameObjectName]],
                        frameObject
                    );
                    counter++;
                }
            }
        }
        this.anim[name].length = counter;

        return counter;
    }

    /**
     * set the current animation
     * this will always change the animation & set the frame to zero
     * @name setCurrentAnimation
     * @memberof Sprite
     * @param {string} name animation id
     * @param {string|Function} [resetAnim] animation id to switch to when complete, or callback
     * @param {boolean} [preserve_dt=false] if false will reset the elapsed time counter since last frame
     * @returns {Sprite} Reference to this object for method chaining
     * @example
     * // set "walk" animation
     * this.setCurrentAnimation("walk");
     *
     * // set "walk" animation if it is not the current animation
     * if (this.isCurrentAnimation("walk")) {
     *     this.setCurrentAnimation("walk");
     * }
     *
     * // set "eat" animation, and switch to "walk" when complete
     * this.setCurrentAnimation("eat", "walk");
     *
     * // set "die" animation, and remove the object when finished
     * this.setCurrentAnimation("die", (function () {
     *    me.game.world.removeChild(this);
     *    return false; // do not reset to first frame
     * }).bind(this));
     *
     * // set "attack" animation, and pause for a short duration
     * this.setCurrentAnimation("die", (function () {
     *    this.animationpause = true;
     *
     *    // back to "standing" animation after 1 second
     *    setTimeout(function () {
     *        this.setCurrentAnimation("standing");
     *    }, 1000);
     *
     *    return false; // do not reset to first frame
     * }).bind(this));
     */
    setCurrentAnimation(name, resetAnim, preserve_dt) {
        if (this.anim[name]) {
            this.current.name = name;
            this.current.length = this.anim[this.current.name].length;
            if (typeof resetAnim === "string") {
                this.resetAnim = this.setCurrentAnimation.bind(this, resetAnim, null, true);
            } else if (typeof resetAnim === "function") {
                this.resetAnim = resetAnim;
            } else {
                this.resetAnim = undefined;
            }
            this.setAnimationFrame(this.current.idx);
            if (!preserve_dt) {
                this.dt = 0;
            }
            this.isDirty = true;
        } else {
            throw new Error("animation id '" + name + "' not defined");
        }
        return this;
    }

    /**
     * reverse the given or current animation if none is specified
     * @name reverseAnimation
     * @memberof Sprite
     * @param {string} [name] animation id
     * @returns {Sprite} Reference to this object for method chaining
     * @see Sprite#animationspeed
     */
    reverseAnimation(name) {
        if (typeof name !== "undefined" && typeof this.anim[name] !== "undefined") {
            this.anim[name].frames.reverse();
        } else {
            this.anim[this.current.name].frames.reverse();
        }
        this.isDirty = true;
        return this;
    }

    /**
     * return true if the specified animation is the current one.
     * @name isCurrentAnimation
     * @memberof Sprite
     * @param {string} name animation id
     * @returns {boolean}
     * @example
     * if (!this.isCurrentAnimation("walk")) {
     *     // do something funny...
     * }
     */
    isCurrentAnimation(name) {
        return this.current.name === name;
    }

    /**
     * change the current texture atlas region for this sprite
     * @see Texture.getRegion
     * @name setRegion
     * @memberof Sprite
     * @param {object} region typically returned through me.Texture.getRegion()
     * @returns {Sprite} Reference to this object for method chaining
     * @example
     * // change the sprite to "shadedDark13.png";
     * mySprite.setRegion(game.texture.getRegion("shadedDark13.png"));
     */
    setRegion(region) {
        // set the source texture for the given region
        this.image = this.source.getTexture(region);
        // set the sprite offset within the texture
        this.current.offset.setV(region.offset);
        // set angle if defined
        this.current.angle = region.angle;
        // update the default "current" size
        this.width = this.current.width = region.width;
        this.height = this.current.height = region.height;
        // set global anchortPoint if defined
        if (region.anchorPoint) {
            this.anchorPoint.set(
                this._flip.x && region.trimmed === true ? 1 - region.anchorPoint.x : region.anchorPoint.x,
                this._flip.y && region.trimmed === true ? 1 - region.anchorPoint.y : region.anchorPoint.y
            );
        }
        this.isDirty = true;
        return this;
    }

    /**
     * force the current animation frame index.
     * @name setAnimationFrame
     * @memberof Sprite
     * @param {number} [idx=0] animation frame index
     * @returns {Sprite} Reference to this object for method chaining
     * @example
     * // reset the current animation to the first frame
     * this.setAnimationFrame();
     */
    setAnimationFrame(idx) {
        this.current.idx = (idx || 0) % this.current.length;
        return this.setRegion(this.getAnimationFrameObjectByIndex(this.current.idx));
    }

    /**
     * return the current animation frame index.
     * @name getCurrentAnimationFrame
     * @memberof Sprite
     * @returns {number} current animation frame index
     */
    getCurrentAnimationFrame() {
        return this.current.idx;
    }

    /**
     * Returns the frame object by the index.
     * @name getAnimationFrameObjectByIndex
     * @memberof Sprite
     * @ignore
     * @param {number} id the frame id
     * @returns {number} if using number indices. Returns {object} containing frame data if using texture atlas
     */
    getAnimationFrameObjectByIndex(id) {
        return this.anim[this.current.name].frames[id];
    }

    /**
     * update function. <br>
     * automatically called by the game manager {@link game}
     * @name update
     * @memberof Sprite
     * @protected
     * @param {number} dt time since the last update in milliseconds.
     * @returns {boolean} true if the Sprite is dirty
     */
    update(dt) {
        // Update animation if necessary
        if (!this.animationpause && this.current && this.current.length > 0) {
            var duration = this.getAnimationFrameObjectByIndex(this.current.idx).delay;
            this.dt += dt;
            while (this.dt >= duration) {
                this.isDirty = true;
                this.dt -= duration;

                var nextFrame = (this.current.length > 1? this.current.idx+1: this.current.idx);
                this.setAnimationFrame(nextFrame);

                // Switch animation if we reach the end of the strip and a callback is defined
                if (this.current.idx === 0 && typeof this.resetAnim === "function") {
                    // Otherwise is must be callable
                    if (this.resetAnim() === false) {
                        // Reset to last frame
                        this.setAnimationFrame(this.current.length - 1);

                        // Bail early without skipping any more frames.
                        this.dt %= duration;
                        break;
                    }
                }
                // Get next frame duration
                duration = this.getAnimationFrameObjectByIndex(this.current.idx).delay;
            }
        }

        // update the sprite bounding box
        /*
        if (this.isDirty === true && !this.currentTransform.isIdentity()) {
            this.getBounds().clear();
            this.getBounds().addFrame(
                0,
                0,
                this.current.width,
                this.current.height,
                this.currentTransform
            );
            this.updateBoundsPos(this.pos.x, this.pos.y);
        }
        */

        //update the "flickering" state if necessary
        if (this._flicker.isFlickering) {
            this._flicker.duration -= dt;
            if (this._flicker.duration < 0) {
                if (typeof (this._flicker.callback) === "function") {
                    this._flicker.callback();
                }
                this.flicker(-1);
            }
            this.isDirty = true;
        }

        return super.update(dt);
    }

    /**
     * Destroy function<br>
     * @ignore
     */
    destroy() {
        pool.push(this.offset);
        this.offset = undefined;
        super.destroy();
    }

    /**
     * draw this srite (automatically called by melonJS)
     * @name draw
     * @memberof Sprite
     * @protected
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer instance
     * @param {Camera2d} [viewport] the viewport to (re)draw
     */
    draw(renderer, viewport) {   // eslint-disable-line no-unused-vars
        // do nothing if we are flickering
        if (this._flicker.isFlickering) {
            this._flicker.state = !this._flicker.state;
            if (!this._flicker.state) {
                return;
            }
        }

        // the frame to draw
        var frame = this.current;

        // cache the current position and size
        var xpos = this.pos.x,
            ypos = this.pos.y;

        var w = frame.width,
            h = frame.height;

        // frame offset in the texture/atlas
        var frame_offset = frame.offset;
        var g_offset = this.offset;


        // remove image's TexturePacker/ShoeBox rotation
        if (frame.angle !== 0) {
            renderer.translate(-xpos, -ypos);
            renderer.rotate(frame.angle);
            xpos -= h;
            w = frame.height;
            h = frame.width;
        }

        renderer.drawImage(
            this.image,
            g_offset.x + frame_offset.x, // sx
            g_offset.y + frame_offset.y, // sy
            w, h,                        // sw,sh
            xpos, ypos,                  // dx,dy
            w, h                         // dw,dh
        );
    }
}

var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAA8FBMVEUgICBrqDHRZVtqpzEhJCAjKCBurTIfHyDQZFptrDEWAB8OAB7VZ1wtIiIAEhYlISDYaF4SAB4pIiEAFhkcFh8eGyBopDAMAB5noS8kKyAAGhtjmy4bEB9lni8ZBR/HYFdPeim/XFQ9XCUaCh9flS1VhCtSfyorOSEVHh4HHB1EZyatVExhmC5ajCxHbSc0SyMuQCInMiFKcSgxRSI6VSRBYiWdTUZdki09JyZ8PzpYiSs3UCRlNjK1WE9ckC1MdShbjywyJCONRkDKYliUSUNeMzBDKShXMC2kUEl1PDeEQj1OLStnNjNxOjZsODQAAAcMh1CFAAAU4UlEQVR42uyaa3fSMBjHk5EQkgClkBZKoXblNhlswIooc2N6pp7jUb//x/FpRbnt4JWwzv7eraQvfs/zby7tUEpKSkpKSkpKSkpKSkpKSkqKTsg30P8E+FIArJllqQaglMXQt6tPuhogGSlaLWFKKU2hEB33eqPRqDemRAlhRhdbVjwIBj8xogajhpBSkNH1dOJ37mYDt1mr2UCt1mwOZned7qQfjhxPVs0WovTpRIFFNkpIU42CSWfm2phnIzjHP+DLS9hutjuL4IqZUigC9yU/CWDBhBROOJkPbBxL4swKjDf/jEvBbXe4CMeiKixKEx0EAq03JbqeDJs4Ul9a7mE5AqqAazM/pJCb5JaAUmWa42nHBflYDf8y8WC4qznv9yRKZAUIRUKO+/Maz/J1+d8ugu0rK3kVoNSTVhDZr8v/WRGyQw8lC0KJMK989+/sVzXILiRNzmrACGXSC4Z2lsf2f08GN2lyHgJCLUn6bRw1/2dim+A9hIKiJMAQ6NOJu7f5a7r8B+u/7N7BAzMZBaBIkkkz0t83sfMsgDHsgN1BOybaFNvww2qblMgEUGKqi2aU/X3u2HZnHf8iuL4aO0S1PKDVQM54dBn0F50718bfq5CwOYBQIaaDVfd37MG91u5MwhER8WHQU8qC2wCEmFJefEYUrBdedGe15b4xQasAtaqXt/wh/W87W1679YNeCxQbjNCItTchBFheRErAmHEYb575ch/Qeuz9ByXpdHH2QX2wx4NuMBbSbJCfn3IJWZ4dndBvZ6Bytt949A8AbZjT6OHftQeDTHtx2VgebhFj6KfAmGisJaS46k+mj/4sELW/N+QP6UOIXf/Sqwq0p/F7okA8KU312BcAqmTf3k1/1Hx7HlgyskfsL96h7b3XMNCRcYQzz+KH9N3FSC57fxiYUTDOWLmAjgcjpBo2d9oPKxdv95Fs0UPGl5XPinWDVYqGwdBxYFQJH/Mdfc5nQUuyw77KYYXKm/ub09PzV/Xn5SNVAOJ/B/Hf0W8HwiQUHRTwf/2slM/nS6WbN/XjZIDK6534w8zv9r1In6GDUq6/y+VzMaVTdGYg7cDj38/wHX17YknQPzSGUb8p5U5icqX7ovaZkBFk+nw7/hx3epIdvPtAufIpf7Ikl39W0B0BRpToQPy32j8IZUPPW+xC8S0E4Afv6noLwGgL3WZ32u8roetbTqF4v1aA/JdKGWmEUc8ZgP/m0j+4riKKNFEoflwrQO6D1gQwKnrulj/mXUto048XgZV+/vQMaYQ5otfc8s/Wpprav5oFz5cRgHXwo85VgFHw55nN+Ld7UvMnPOP5y2elXMRJ6VzDA7DPH2e7XstBemHl+vubfAk4efGc6SsAo9542x9fVJH+D/lQgfrnF+fn9++KWv0bdHP+z3A7rFKC9MMMo1KsVIr1ssYHgFiqvemfdUemg45EuVAuFMpIH4SI4ZZ/2xEOQ8eCAUgjVHa3/G+txuN/Z/+vYE51suU/9NT/5G8GIL3uPxfsCfwf11fyrW1FgRiGTkna0vZpYHQUXRHdVZBhvCMorP7/V+3oyprgPiy2Dxk2HzA06TknpyHz19CjVfcpf9kj+6SBtqgcMPz/q/vPdPgwLP/DsCM1f2vTf7Ifap5/hYXQ/FGnX7S16LdABADc23oqVP91kYfgrU5b1GxKHSCo7tILzR/z9eJ8nliv0zqAMZ8ATEJfaP6+7jlj3CDlXpHVfsfnH+eyn4kMzMdGQRNO7fNkGEXbGTigBkDq1lZzU07BnaXzIab6LCMAuEEmdWcD8+ax9uNTckxFqyWxwKBgKXZrzerHtAbcPhFQ0R8oAExdChXADIt1Tz0KkGi9TjML1CBLqgA0YZGIFZhZqVNUtf9GCdBbF0IF4Be/vvQYz6pyxhRwH+QC4CpXoAgELvE6iKMtfwJLzv+5YU2iDasOR0MJMBdMgFsMK6ICrppGY+rELGAdhFpAYoXYgRdBRzsLUtB3L/z+7zpITFvHYhQAdorGyQudAdCuNe8qoJjVNgYAF0M+9iFbAe9tK2w4BKIIdVJ0CLASv7jeBFo7cBwCrxcgP1IAjEv5ALipwII1gmGGMR4A2uEB+blJK4x4E1kdZhQA5xYowPe58z3lwKfH199WbQRAc/LpuwPWu17k0qaFCnANAgHSvKJcZdMCxJtgOsQuKsexG2uCwMxa8O8aUa/axHZCe/OUZA42ag0Avqi5ll2nYSAaRQEbZI+NrbKwEFFYJURCiEcpqEE0aZOmBfH/f4PLQ+OEttwxLKg3jq5Or3TG9jyOJ/FjgSIGZvBRLhB1oFvi7/3X5CIDhZHodOLtfyyEXUlh0IGzyDoQM+rbGljFRNaE2ZOXj0MT3pALxGQo8v1z1ILRBb6+hTJoZgLvBoMYRjZAeALuv/v/hZCzeTxWRIu/iwEvbqQMmKcxUekwHqF/KQSo74OCVX8rCyQoC9C/QYBZENZTcYMlRkqjWFlVZfn9OWGXwcoDVFKewD+fo33v9AwQD3HGFqH5XsXHACWVA7BObfp+YyoL4BKpLvb+MuvBlVn1q03iwIONVNFy1jPUBvGyPOaGJT4GGOPAHd9v66bIuy7Pi3p5GKoTrYSdeRXaQrk7LD02P2Gbejv2FqrYdugFxgHM5ChBEFNpIn/czxaObdMJrcXP4Z94sdxZUGZmAZmA+7ws0im4a9oenFQsKg58uE8NhBgE43+LlBysa65FmvJweIppMzobsmJKWve+EFrMsUJ3+wEqGaUKPA9XkSYNhj0xUd8xYkbBsU516lnMhv+LFs1nKCX7BZYVjIUQZ8FC830PRjG6LnSqBzCSPcloP0U9IaLZhknntlynSGhOS+yV/bWuEla1EPwSONXdAc0VKYv4ZcyoWQBGEDp/2zdI/zyrYgfyR6CAL7nm18BC18pJFnlLhuUMsScgvs9CwjrXyOgCq/Q9yIQpBa0Q/DqW6+JoJSNX9AGNT4S2uezhx8B9kBvu2AZGjpQubwLRglHKLnX6Z7DodmgBQjDHkji7O3+MoFFZgITx+pLiMdiChL1G7DUL8DWQLBDPw3dGh5Yjn38YT+TuMrhuvy71HbGiGyzRAg8DVYQQzO49evYg7ArLiP7v82/7n3OcZ8u6F36+IzjfVCqivwkTetqNCHpP2nvdfS74PJTr7zH+NM9pTflPwTMbcN1YkgEwFcL7EXIddf85LQ1SrtZ8FsO6uh13w7Abt02nZ7tjbiuR1+2Xn2COYPxaCCM3+KCqQz86fnpDSgOkPQg+i/dtb8E6P/zUt8Vln+/pF4fVD7D103Gbz8B8cIbULeJlHXqLM2ZQZDHEuGMnpsF+m0Alpfk+pKmAtZdCJNf5wUGJYAervRB8eggotSH2SlAy2myBchi14VbCxKlzka+BScWCqofBUASYCbsVKAQzD65g7CbmEl9OCTQtocEm74ysiPsq6imhilLVxANyUfR2o9i0SN7YstH8DP+9db+DYcD/iFsgqnXWd02SXAc9CrLpx124yFd2w35HlQ4tEPCHxPwO9haY7oG1NbQbMnLPYPbw2YNIMYAlxeTIDlP+WP0axAUhTrGzefUXEeK+kXetvU3DUDQtqdxKSQwJG1romIbQSLWhfuChFRioG92rsP//c3AiwbErxfKxBMoFf/am5cyPc+899/hDkTOJHZ4IKMQQrC6irDZTh+YVa9VHlsbuyK6uEe7tINCdK9hVutGkUgL/S0pox5cEchPX2X9qrXVfuIQIoAcsDN2sj+yb5XuVU8JZlgkpZ+PMzMbhvG0AwKqfteh6O3VZbqL8J4tNhggAluxxBgaNEIK7A/BNWvkWC7DCV/X+3qsMU0+LkqiS75NyMUhD+LqqrjdT51TPlQeAVTZ11nXpW1nm1sDOWhA1blBBcGEincwV1crqwV7Vq6r0U8ZxiCEevONwtzaaKnGS6X3lCGRHSwaAuyzU4Uyr5tjaLv4wL6+cm3BbxwFw9pSujJsfowBY2UfAutHeyRftZGwXb4RxY2+XDQHAgQGAlblMHI382xeRABwnSicBpyDYjS/HADYILhiYFAMA6k8DUDgANCQAfue0bPy3AeC3QD48AGK2gHLOgJFwAKhDENfgvwkArkGGCH0SDcAuEeKp8MhQYcEAtFT4EU2Fn9nB0HvJAExQHEMwRIfDogFgw2GI7eGXIhkANyESlxITvQLc/2UwAO+cLILgW4BMikIg46TF01QwAGxaHOwBuoI9uQBwhRGMPbs09nouFwCo3fAlLG6GCooFAMVRrGVaXTUz5XGxAHjK44xAQioArUBiZgskYiUyUrcAKhygdDEiqT2xPACZDS6qSe2+y04hIROAFM5aSO6F2qe5pmxDAMBJivJCydFhqsiOK9SHhQLQNb/ahTHFycsglh7EFogB4IQUSyORsqT841Aay8aBxR7VqYlQHPfK33SysAUVwY/qzF/ZO5kRfKLljAkidJMfZaEPgJXVD+ubNnUZqL0yS0upwKAOWidW7ZY++UhSIRQxp79KmAvth8sIha5Q8VZJ0B6YdquFaZlBTjyl7UMQEQcXyG8fZ93TN+MHCJv75l4bzWQ3+RhlRI8A2UzGozpEdpvjgSDRYALh7TY6qS+PWpHvBcT9nmdizk+nmQHsNq+xAHoRuLkYt21k32qlQ/01D0es0gVUCIcAZUimdbG+u7z/XOP7PQgsiu395WpbNKUKaEKqNmbyeZFoNiEKOscrDHkf1bxpmz91GdZY2HWHhjWHlt3kRc6bS/I2IoijIkyadZ7nJTNZU5PpByHAAmhXvkgfGqXUACY77fOc5h2SeXRciTNQ2Gkef56oOAsNtF1KQwCRIN/9CxqFZII8E5WXFpdFiZeW2oNHyRrIhSAfGrMHUCUfrKN8yAI+oYyUkFK2HaVFW2khtR/rPzDal+UkZGjwzOMAwRSJkReScwyi5QGdEvxI2wqZSEdNeGryRNYl018dT9X/zlIzndt0eHR4MNSnVXyPgoAGR3tKYidJ8dOa4PRCTTD2eRl7CUyEmAqirIHqbuxveuOcAjIuApwAHjNFKqmC5lsZIdH8zGuuzp8mYJQCTgGo/FARix7KMSQzYzn8vAAU8gFGcPQS+DJ8AH4rndH8PqQ3S35yd2U7isNAMFHasWw/WcopQhRBIBICQsggJCIx/P9XrTMcDWbZY5YQs36Yh4EZXNXl7vJB3Hkjd7fCkCfc3/ZGbgh4zp5xwYbuBdBWGr00pF2OrT0E6p/sIH6V1uRHTANeDv1NE/j4rB1mFYMHgTYJsJtnrGORL1W9w107NA4/u+gqjL+cFXprU2+cbSvA828GxFKImwRmLpDiji6WwCdvsuDjOU1MA7iI+WzXBj4MmfFpQKuAeC7wOdss6n8afe8qjaUaqNdRWoeEPt1g4wPGpFkMUJKuIruDAaA/ahsToVmXr4NnYanq4GI4eq4waLKJZxADYF12MvFIEO3EZKPLTMxxhADo1ztK0zgtxIND3JhieKnTeKEEhacT4F9OHOB+qRkMXHZwcCOzgwxFv76IfKszMxgg4bqNDDa26cSs01hsmKMtDlj9X8La4sfAdHkvHn6vHhngtGcGAJT+EX+3RxnwDDV+GPf7rIYUQGQa/tyj3RFA063GwN4f98cAJT6f3HaIDaukO1FS8GCuMTCveGz10yhJvIWGP+rWolKSFkMtEw7LvuaGMa/yW/y208iO8GMxXEXslnRnE8LrUyEFIpqhht8edb5aRWNeawzYLJMvnxhQsMKZw16KHw2RzoC7iF+dCOJ0PGX2a/Hj0sNFA5gIPl4zDFD+KzX8dfzhoyh0zwCzP/nrREA8MQu0HtjOSHTeAcwDxcDVPt/d1iGQVygQiKx2rq1FIPh4BX7MA/G5AOEwCNZKBN3PjuJEbCLX0cZgVL90kY6SxFcW5E4EZegTq9N+ECssdszWyZ8X/DX4UYc+n+oydFx7SgR0Z4sogEzWgc684x6s9PV1GMS6DbsmguGMc9IRBUC4HM3d+w+d9jIlAxKOIi0R2A5z85HkHWRDCiQV5YIxR8PP7KWAfiblsSxyV++P6tDhQz5dBS38emLfhV9ZkKa/Q8xknKAdu04Fiw/OLfKssFCLAJf1xEH4PZpQ3ZBvMCdddcvejxLhE3hO8KnkzQ7hX8t/LfvdnwAiiz327IoCli9jwUFxQP8l9kBgLKzNvhX/Pc/zpo+JqD4M+NpBEVzlAjeaNqkYA4Hv00s8wetswJDj6/BPfQNOKlCAsN7+rIPtSMjXKy4SIH8rBGoBEPCkqGYHx8XMfx3+wUdombE9RzhfBg8ocIPDUnHAfULgr0JP1R8Vs13kovZvEq2TqfCbsC1xMkXFzsY46RxsPxuQioRWCQC/RA5AFPhUCL9cL6JW+j+Dz1rXTfuXPzaSiNEcY3XHgT3YLRvCheSeBQR5oKpdIQfLS6WQUM4mA8e9Qa/7TWPCf/FpfLwcIgU6B0zBGe6zWVklMlQ8jD2/BX0mg3pjLkUo07jcZIsWPEP0OvwgA9l78r9vBAT5jB5QcESjYDlRvpsuN01dES/lnEupfqQeVKtmtMx2+dBhJ/APmHSdaWGW+rERPyymAVKgtRMq5rYIg2g4z/P9YbFY7PN8PoyC4wuI/QH8yUokxDIu/Ofk7YVFFmllSyfhjJCxFvIXaqa99Ah+MKnF2KzBf0dBElbrAdNk8IAKbL9/txJIlK1EajT8Yzb0hTXb2pjC/7k5X55qvqzCxHT458mL4M10iDL4bsMSEuxGifDeAv5RBcBFPDsEWMq/H3vmOttlIbhFzKt8v5SBL/hquW85QBL+Xvmuk3+W/H2CfyuDccvBIrKxsP859jb0LNqvy1RweK/gYwMCiZDVKMsDdlLCr2m4vEWBD+bTTcFFCu8XfI0Dr53XjbL9yeRh/dNgo0+yo+10s1LcJW+O/ryo05IQ8ricZYt5pGg4Wr6bxo6/taP5YTprKh624AmYavn+urVgfC6F9KpSef7JYTtQ7jcInLYFyhcP8sMkW27KwudCcA/I+4f+Tgnn+a5CKCT3SVWs6ros63q1qgg9/do7vY3+L6H/0a4dqgAAg1AULYPBsjax+P//uA3TwuJAxj3RJiYf7xJ5rBVVLNzHcA8T7fkZl6iePpchSDvs8b9XBwAAAAAAqGQCc31B4/xqSwwAAAAASUVORK5CYII=";

// a basic progress bar object
class ProgressBar extends Renderable {
    /**
     * @ignore
     */
    constructor(x, y, w, h) {
        super(x, y, w, h);

        this.barHeight = h;
        this.anchorPoint.set(0, 0);

        on(LOADER_PROGRESS, this.onProgressUpdate, this);
        on(VIEWPORT_ONRESIZE, this.resize, this);

        this.anchorPoint.set(0, 0);

        // store current progress
        this.progress = 0;
    }

    /**
     * make sure the screen is refreshed every frame
     * @ignore
     */
    onProgressUpdate(progress) {
        this.progress = ~~(progress * this.width);
        this.isDirty = true;
    }

    /**
     * draw function
     * @ignore
     */
    draw (renderer) {
        // draw the progress bar
        renderer.setColor("black");
        renderer.fillRect(this.pos.x, viewport.centerY, renderer.getWidth(), this.barHeight / 2);

        renderer.setColor("#55aa00");
        renderer.fillRect(this.pos.x, viewport.centerY, this.progress, this.barHeight / 2);
    }

    /**
     * Called by engine before deleting the object
     * @ignore
     */
    onDestroyEvent() {
        // cancel the callback
        off(LOADER_PROGRESS, this.onProgressUpdate);
        off(VIEWPORT_ONRESIZE, this.resize);
    }

}
/**
 * the melonJS Logo
 * @ignore
 */
class IconLogo extends Sprite {
    constructor(x, y) {
        // TODO: create a sprite or texture from a Base64 encoded image
        var image = new Image();
        image.src = img;
        super(x, y, {
            image : image,
            framewidth : 256,
            frameheight : 256
        });
    }
}

/**
 * a default loading screen
 * @ignore
 */
class DefaultLoadingScreen extends Stage {
    /**
     * call when the loader is resetted
     * @ignore
     */
    onResetEvent() {
        var barHeight = 8;

        // set a background color
        world.backgroundColor.parseCSS("#202020");

        // progress bar
        world.addChild(new ProgressBar(
            0,
            renderer.getHeight() / 2,
            renderer.getWidth(),
            barHeight
        ), 1);

        // melonJS logo
        world.addChild(new IconLogo(
            renderer.getWidth() / 2,
            (renderer.getHeight() / 2)

        ), 2);
    }
}

// current state
var _state = -1;

// requestAnimeFrame Id
var _animFrameId = -1;

// whether the game state is "paused"
var _isPaused = false;

// list of stages
var _stages = {};

// fading transition parameters between screen
var _fade = {
    color : "",
    duration : 0
};

// callback when state switch is done
/** @ignore */
var _onSwitchComplete = null;

// just to keep track of possible extra arguments
var _extraArgs = null;

// store the elapsed time during pause/stop period
var _pauseTime = 0;

/**
 * @ignore
 */
function _startRunLoop() {
    // ensure nothing is running first and in valid state
    if ((_animFrameId === -1) && (_state !== -1)) {
        // start the main loop
        _animFrameId = globalThis.requestAnimationFrame(_renderFrame);
    }
}

/**
 * Resume the game loop after a pause.
 * @ignore
 */
function _resumeRunLoop() {
    // ensure game is actually paused and in valid state
    if (_isPaused && (_state !== -1)) {
        _isPaused = false;
    }
}

/**
 * Pause the loop for most stage objects.
 * @ignore
 */
function _pauseRunLoop() {
    // Set the paused boolean to stop updates on (most) entities
    _isPaused = true;
}

/**
 * this is only called when using requestAnimFrame stuff
 * @param {number} time current timestamp in milliseconds
 * @ignore
 */
function _renderFrame(time) {
    var stage = _stages[_state].stage;
    // update all game objects
    update(time, stage);
    // render all game objects
    draw(stage);
    // schedule the next frame update
    if (_animFrameId !== -1) {
        _animFrameId = globalThis.requestAnimationFrame(_renderFrame);
    }
}

/**
 * stop the SO main loop
 * @ignore
 */
function _stopRunLoop() {
    // cancel any previous animationRequestFrame
    globalThis.cancelAnimationFrame(_animFrameId);
    _animFrameId = -1;
}

/**
 * start the SO main loop
 * @ignore
 */
function _switchState(state) {
    // clear previous interval if any
    _stopRunLoop();

    // call the stage destroy method
    if (_stages[_state]) {
        // just notify the object
        _stages[_state].stage.destroy();
    }

    if (_stages[state]) {
        // set the global variable
        _state = state;

        // call the reset function with _extraArgs as arguments
        _stages[_state].stage.reset.apply(_stages[_state].stage, _extraArgs);

        // and start the main loop of the
        // new requested state
        _startRunLoop();

        // publish the pause event
        emit(STATE_CHANGE);

        // execute callback if defined
        if (_onSwitchComplete) {
            _onSwitchComplete();
        }

        // force repaint
        repaint();
    }
}

// initialize me.state on system boot
on(BOOT, () => {
    // set the built-in loading stage
    state.set(state.LOADING, new DefaultLoadingScreen());
    // set and enable the default stage
    state.set(state.DEFAULT, new Stage());
    // enable by default as soon as the display is initialized
    on(VIDEO_INIT, () => {
        state.change(state.DEFAULT, true);
    });
});


/**
 * a State Manager (state machine)
 * @namespace state
 */

var state = {

    /**
     * default state ID for Loading Stage
     * @constant
     * @name LOADING
     * @memberof state
     */
    LOADING : 0,

    /**
     * default state ID for Menu Stage
     * @constant
     * @name MENU
     * @memberof state
     */
    MENU : 1,

    /**
     * default state ID for "Ready" Stage
     * @constant
     * @name READY
     * @memberof state
     */
    READY : 2,

    /**
     * default state ID for Play Stage
     * @constant
     * @name PLAY
     * @memberof state
     */
    PLAY : 3,

    /**
     * default state ID for Game Over Stage
     * @constant
     * @name GAMEOVER
     * @memberof state
     */
    GAMEOVER : 4,

    /**
     * default state ID for Game End Stage
     * @constant
     * @name GAME_END
     * @memberof state
     */
    GAME_END : 5,

    /**
     * default state ID for High Score Stage
     * @constant
     * @name SCORE
     * @memberof state
     */
    SCORE : 6,

    /**
     * default state ID for Credits Stage
     * @constant
     * @name CREDITS
     * @memberof state
     */
    CREDITS : 7,

    /**
     * default state ID for Settings Stage
     * @constant
     * @name SETTINGS
     * @memberof state
     */
    SETTINGS : 8,

    /**
     * default state ID for the default Stage
     * (the default stage is the one running as soon as melonJS is started)
     * @constant
     * @name SETTINGS
     * @memberof state
     */
    DEFAULT : 9,

    /**
     * default state ID for user defined constants<br>
     * @constant
     * @name USER
     * @memberof state
     * @example
     * var STATE_INFO = me.state.USER + 0;
     * var STATE_WARN = me.state.USER + 1;
     * var STATE_ERROR = me.state.USER + 2;
     * var STATE_CUTSCENE = me.state.USER + 3;
     */
    USER : 100,

    /**
     * Stop the current stage.
     * @name stop
     * @memberof state
     * @public
     * @param {boolean} [pauseTrack=false] pause current track on screen stop.
     */
    stop(pauseTrack=false) {
        // only stop when we are not loading stuff
        if ((_state !== this.LOADING) && this.isRunning()) {
            // stop the main loop
            _stopRunLoop();

            // current music stop
            if (pauseTrack === true) {
                pauseTrack();
            }

            // store time when stopped
            _pauseTime = globalThis.performance.now();

            // publish the stop notification
            emit(STATE_STOP);
        }
    },

    /**
     * pause the current stage
     * @name pause
     * @memberof state
     * @public
     * @param {boolean} [music=false] pause current music track on screen pause
     */
    pause(music=false) {
        // only pause when we are not loading stuff
        if ((_state !== this.LOADING) && !this.isPaused()) {
            // stop the main loop
            _pauseRunLoop();
            // current music stop
            if (music === true) {
                pauseTrack();
            }

            // store time when paused
            _pauseTime = globalThis.performance.now();

            // publish the pause event
            emit(STATE_PAUSE);
        }
    },

    /**
     * Restart the current stage from a full stop.
     * @name restart
     * @memberof state
     * @public
     * @param {boolean} [music=false] resume current music track on screen resume
     */
    restart(music=false) {
        if (!this.isRunning()) {
            // restart the main loop
            _startRunLoop();
            // current music stop
            if (music === true) {
                resumeTrack();
            }

            // calculate the elpased time
            _pauseTime = globalThis.performance.now() - _pauseTime;

            // force repaint
            repaint();

            // publish the restart notification
            emit(STATE_RESTART, _pauseTime);
        }
    },

    /**
     * resume the current stage
     * @name resume
     * @memberof state
     * @public
     * @param {boolean} [music=false] resume current music track on screen resume
     */
    resume(music=false) {
        if (this.isPaused()) {
            // resume the main loop
            _resumeRunLoop();
            // current music stop
            if (music === true) {
                resumeTrack();
            }

            // calculate the elpased time
            _pauseTime = globalThis.performance.now() - _pauseTime;

            // publish the resume event
            emit(STATE_RESUME, _pauseTime);
        }
    },

    /**
     * return the running state of the state manager
     * @name isRunning
     * @memberof state
     * @public
     * @returns {boolean} true if a "process is running"
     */
    isRunning() {
        return _animFrameId !== -1;
    },

    /**
     * Return the pause state of the state manager
     * @name isPaused
     * @memberof state
     * @public
     * @returns {boolean} true if the game is paused
     */
    isPaused() {
        return _isPaused;
    },

    /**
     * associate the specified state with a Stage
     * @name set
     * @memberof state
     * @public
     * @param {number} state State ID (see constants)
     * @param {Stage} stage Instantiated Stage to associate with state ID
     * @param {boolean} [start = false] if true the state will be changed immediately after adding it.
     * @example
     * class MenuButton extends me.GUI_Object {
     *     onClick() {
     *         // Change to the PLAY state when the button is clicked
     *         me.state.change(me.state.PLAY);
     *         return true;
     *     }
     * };
     *
     * class MenuScreen extends me.Stage {
     *     onResetEvent() {
     *         // Load background image
     *         me.game.world.addChild(
     *             new me.ImageLayer(0, 0, {
     *                 image : "bg",
     *                 z: 0 // z-index
     *             }
     *         );
     *
     *         // Add a button
     *         me.game.world.addChild(
     *             new MenuButton(350, 200, { "image" : "start" }),
     *             1 // z-index
     *         );
     *
     *         // Play music
     *         me.audio.playTrack("menu");
     *     }
     *
     *     onDestroyEvent() {
     *         // Stop music
     *         me.audio.stopTrack();
     *     }
     * };
     *
     * me.state.set(me.state.MENU, new MenuScreen());
     */
    set(state, stage, start = false) {
        if (!(stage instanceof Stage)) {
            throw new Error(stage + " is not an instance of me.Stage");
        }
        _stages[state] = {};
        _stages[state].stage = stage;
        _stages[state].transition = true;

        if (start === true) {
            this.change(state);
        }
    },

    /**
     * returns the stage associated with the specified state
     * (or the current one if none is specified)
     * @name set
     * @memberof state
     * @public
     * @param {number} [state] State ID (see constants)
     * @returns {Stage}
     */
    get(state = _state) {
        if (typeof _stages[state] !== "undefined") {
            return _stages[state].stage;
        } else {
            return undefined;
        }

    },

    /**
     * return a reference to the current stage<br>
     * useful to call a object specific method
     * @name current
     * @memberof state
     * @public
     * @returns {Stage}
     */
    current() {
        return this.get();
    },

    /**
     * specify a global transition effect
     * @name transition
     * @memberof state
     * @public
     * @param {string} effect (only "fade" is supported for now)
     * @param {Color|string} color a CSS color value
     * @param {number} [duration=1000] expressed in milliseconds
     */
    transition(effect, color, duration) {
        if (effect === "fade") {
            _fade.color = color;
            _fade.duration = duration;
        }
    },

    /**
     * enable/disable transition for a specific state (by default enabled for all)
     * @name setTransition
     * @memberof state
     * @public
     * @param {number} state State ID (see constants)
     * @param {boolean} enable
     */
    setTransition(state, enable) {
        _stages[state].transition = enable;
    },

    /**
     * change the game/app state
     * @name change
     * @memberof state
     * @public
     * @param {number} state State ID (see constants)
     * @param {boolean} forceChange if true the state will be changed immediately
     * @param {object} [...arguments] extra arguments to be passed to the reset functions
     * @example
     * // The onResetEvent method on the play screen will receive two args:
     * // "level_1" and the number 3
     * me.state.change(me.state.PLAY, "level_1", 3);
     */
    change(state, forceChange) {
        // Protect against undefined Stage
        if (typeof(_stages[state]) === "undefined") {
            throw new Error("Undefined Stage for state '" + state + "'");
        }

        // do nothing if already the current state
        if (!this.isCurrent(state)) {
            _extraArgs = null;
            if (arguments.length > 1) {
                // store extra arguments if any
                _extraArgs = Array.prototype.slice.call(arguments, 1);
            }
            // if fading effect
            if (_fade.duration && _stages[state].transition) {
                _onSwitchComplete = () => {
                    viewport.fadeOut(_fade.color, _fade.duration);
                };
                viewport.fadeIn(
                    _fade.color,
                    _fade.duration,
                    function () {
                        defer(_switchState, this, state);
                    }
                );

            }
            // else just switch without any effects
            else {
                // wait for the last frame to be
                // "finished" before switching
                if (forceChange === true) {
                    _switchState(state);
                } else {
                    defer(_switchState, this, state);
                }
            }
        }
    },

    /**
     * return true if the specified state is the current one
     * @name isCurrent
     * @memberof state
     * @public
     * @param {number} state State ID (see constants)
     * @returns {boolean} true if the specified state is the current one
     */
    isCurrent(state) {
        return _state === state;
    }

};

/**
 * set and interpret a TMX property value
 * @ignore
 */
function setTMXValue(name, type, value) {
    var match;

    if (typeof(value) !== "string") {
        // Value is already normalized (e.g. with JSON maps)
        return value;
    }

    switch (type) {

        case "int" :
        case "float" :
            value = Number(value);
            break;

        case "bool" :
            value = (value === "true");
            break;

        default :
            // try to parse it anyway
            if (!value || isBoolean(value)) {
                // if value not defined or boolean
                value = value ? (value === "true") : true;
            }
            else if (isNumeric(value)) {
                // check if numeric
                value = Number(value);
            }
            else if (value.search(/^json:/i) === 0) {
                // try to parse it
                match = value.split(/^json:/i)[1];
                try {
                    value = JSON.parse(match);
                }
                catch (e) {
                    throw new Error("Unable to parse JSON: " + match);
                }
            }
            else if (value.search(/^eval:/i) === 0) {
                // try to evaluate it
                match = value.split(/^eval:/i)[1];
                try {
                    // eslint-disable-next-line
                    value = Function("'use strict';return (" + match + ")")();
                }
                catch (e) {
                    throw new Error("Unable to evaluate: " + match);
                }
            }
            else if (
                ((match = value.match(/^#([\da-fA-F])([\da-fA-F]{3})$/))) ||
                ((match = value.match(/^#([\da-fA-F]{2})([\da-fA-F]{6})$/)))
            ) {
                value = "#" + match[2] + match[1];
            }

            // normalize values
            if (name.search(/^(ratio|anchorPoint)$/) === 0) {
                // convert number to vector
                if (typeof(value) === "number") {
                    value = {
                        "x" : value,
                        "y" : value
                    };
                }
            }
    }
    // return the interpreted value
    return value;
}

/**
 * @ignore
 */
function parseAttributes(obj, elt) {
    // do attributes
    if (elt.attributes && elt.attributes.length > 0) {
        for (var j = 0; j < elt.attributes.length; j++) {
            var attribute = elt.attributes.item(j);
            if (typeof(attribute.name) !== "undefined") {
                // DOM4 (Attr no longer inherit from Node)
                obj[attribute.name] = attribute.value;
            } else {
                // else use the deprecated ones
                obj[attribute.nodeName] = attribute.nodeValue;
            }
        }
    }
}

/**
 * decompress zlib/gzip data (NOT IMPLEMENTED)
 * @ignore
 * @name decompress
 * @param  {number[]} data Array of bytes
 * @param  {string} format compressed data format ("gzip","zlib")
 */
function decompress() {
    throw new Error("GZIP/ZLIB compressed TMX Tile Map not supported!");
}
/**
 * Decode a CSV encoded array into a binary array
 * @ignore
 * @name decodeCSV
 * @param  {string} input CSV formatted data (only numbers, everything else will be converted to NaN)
 * @returns {number[]} Decoded data
 */
function decodeCSV(input) {
    var entries = input.replace("\n", "").trim().split(",");

    var result = [];
    for (var i = 0; i < entries.length; i++) {
        result.push(+entries[i]);
    }
    return result;
}
/**
 * Decode a base64 encoded string into a byte array
 * @ignore
 * @name decodeBase64AsArray
 * @param {string} input Base64 encoded data
 * @param {number} [bytes] number of bytes per array entry
 * @returns {Uint32Array} Decoded data
 */
function decodeBase64AsArray(input, bytes) {
    bytes = bytes || 1;

    var i, j, len;
    var dec = globalThis.atob(input.replace(/[^A-Za-z0-9\+\/\=]/g, ""));
    var ar = new Uint32Array(dec.length / bytes);

    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt((i * bytes) + j) << (j << 3);
        }
    }
    return ar;
}
/**
 * Decode the given data
 * @ignore
 */
function decode(data, encoding, compression) {
    compression = compression || "none";
    encoding = encoding || "none";

    switch (encoding) {
        case "csv":
            return decodeCSV(data);

        case "base64":
            var decoded = decodeBase64AsArray(data, 4);
            return (
                (compression === "none") ?
                decoded :
                decompress()
            );

        case "none":
            return data;

        case "xml":
            throw new Error("XML encoding is deprecated, use base64 instead");

        default:
            throw new Error("Unknown layer encoding: " + encoding);
    }
}
/**
 * Normalize TMX format to Tiled JSON format
 * @ignore
 */
function normalize(obj, item) {
    var nodeName = item.nodeName;

    switch (nodeName) {
        case "data":
            var data = parse(item);
            // #956 Support for Infinite map
            // workaround to prevent the parsing code from crashing
            data.text = data.text || data.chunk.text;
            // When no encoding is given, the tiles are stored as individual XML tile elements.
            data.encoding = data.encoding || "xml";
            obj.data = decode(data.text, data.encoding, data.compression);
            obj.encoding = "none";
            break;

        case "imagelayer":
        case "layer":
        case "objectgroup":
        case "group":
            var layer = parse(item);
            layer.type = (nodeName === "layer" ? "tilelayer" : nodeName);
            if (layer.image) {
                layer.image = layer.image.source;
            }

            obj.layers = obj.layers || [];
            obj.layers.push(layer);
            break;

        case "animation":
            obj.animation = parse(item).frames;
            break;

        case "frame":
        case "object":
            var name = nodeName + "s";
            obj[name] = obj[name] || [];
            obj[name].push(parse(item));
            break;

        case "tile":
            var tile = parse(item);
            if (tile.image) {
                tile.imagewidth = tile.image.width;
                tile.imageheight = tile.image.height;
                tile.image = tile.image.source;
            }
            obj.tiles = obj.tiles || {};
            obj.tiles[tile.id] = tile;
            break;

        case "tileset":
            var tileset = parse(item);
            if (tileset.image) {
                tileset.imagewidth = tileset.image.width;
                tileset.imageheight = tileset.image.height;
                tileset.image = tileset.image.source;
            }

            obj.tilesets = obj.tilesets || [];
            obj.tilesets.push(tileset);
            break;

        case "polygon":
        case "polyline":
            obj[nodeName] = [];

            // Get a point array
            var points = parse(item).points.split(" ");

            // And normalize them into an array of vectors
            for (var i = 0, v; i < points.length; i++) {
                v = points[i].split(",");
                obj[nodeName].push({
                    "x" : +v[0],
                    "y" : +v[1]
                });
            }

            break;

        case "properties":
            obj.properties = parse(item);
            break;

        case "property":
            var property = parse(item);
            // for custom properties, text is used
            var value = (typeof property.value !== "undefined") ? property.value : property.text;

            obj[property.name] = setTMXValue(
                property.name,
                // in XML type is undefined for "string" values
                property.type || "string",
                value
            );
            break;

        default:
            obj[nodeName] = parse(item);
            break;
    }
}
/**
 * Parse a XML TMX object and returns the corresponding javascript object
 * @ignore
 */
function parse(xml) {
    // Create the return object
    var obj = {};

    var text = "";

    if (xml.nodeType === 1) {
        // do attributes
        parseAttributes(obj, xml);
    }

    // do children
    if (xml.hasChildNodes()) {
        for (var i = 0; i < xml.childNodes.length; i++) {
            var item = xml.childNodes.item(i);

            switch (item.nodeType) {
                case 1:
                    normalize(obj, item);
                    break;

                case 3:
                    text += item.nodeValue.trim();
                    break;
            }
        }
    }

    if (text) {
        obj.text = text;
    }

    return obj;
}
/**
 * Apply TMX Properties to the given object
 * @ignore
 */
function applyTMXProperties(obj, data) {
    var properties = data.properties;
    var types = data.propertytypes;
    if (typeof(properties) !== "undefined") {
        for (var property in properties) {
            if (properties.hasOwnProperty(property)) {
                var type = "string";
                var name = property;
                var value = properties[property];
                // proof-check for new and old JSON format
                if (typeof properties[property].name !== "undefined") {
                    name = properties[property].name;
                }
                if (typeof(types) !== "undefined") {
                    type = types[property];
                } else if (typeof properties[property].type !== "undefined") {
                    type = properties[property].type;
                }
                if (typeof properties[property].value !== "undefined") {
                    value = properties[property].value;
                }
                // set the value
                obj[name] = setTMXValue(name, type, value);
            }
        }
    }
}

// bitmask constants to check for flipped & rotated tiles
const TMX_FLIP_H          = 0x80000000,
      TMX_FLIP_V          = 0x40000000,
      TMX_FLIP_AD         = 0x20000000,
      TMX_CLEAR_BIT_MASK$1  = ~(0x80000000 | 0x40000000 | 0x20000000);

/**
 * @classdesc
 * a basic tile object
 * @augments Bounds
 */
class Tile extends Bounds {
    /**
     * @param {number} x x index of the Tile in the map
     * @param {number} y y index of the Tile in the map
     * @param {number} gid tile gid
     * @param {TMXTileset} tileset the corresponding tileset object
     */
    constructor(x, y, gid, tileset) {
        var width, height;

        // call the parent constructor
        super();

        // determine the tile size
        if (tileset.isCollection) {
            var image = tileset.getTileImage(gid & TMX_CLEAR_BIT_MASK$1);
            width = image.width;
            height = image.height;
        } else {
            width = tileset.tilewidth;
            height = tileset.tileheight;
        }

        this.setMinMax(0, 0, width, height);

        /**
         * tileset
         * @public
         * @type {TMXTileset}
         * @name Tile#tileset
         */
        this.tileset = tileset;

        /**
         * the tile transformation matrix (if defined)
         * @ignore
         */
        this.currentTransform = null;

        // Tile col / row pos
        this.col = x;
        this.row = y;

        /**
         * tileId
         * @public
         * @type {number}
         * @name Tile#tileId
         */
        this.tileId = gid;
        /**
         * True if the tile is flipped horizontally<br>
         * @public
         * @type {boolean}
         * @name Tile#flipX
         */
        this.flippedX  = (this.tileId & TMX_FLIP_H) !== 0;
        /**
         * True if the tile is flipped vertically<br>
         * @public
         * @type {boolean}
         * @name Tile#flippedY
         */
        this.flippedY  = (this.tileId & TMX_FLIP_V) !== 0;
        /**
         * True if the tile is flipped anti-diagonally<br>
         * @public
         * @type {boolean}
         * @name Tile#flippedAD
         */
        this.flippedAD = (this.tileId & TMX_FLIP_AD) !== 0;

        /**
         * Global flag that indicates if the tile is flipped<br>
         * @public
         * @type {boolean}
         * @name Tile#flipped
         */
        this.flipped = this.flippedX || this.flippedY || this.flippedAD;

        // create and apply transformation matrix if required
        if (this.flipped === true) {
            if (this.currentTransform === null) {
                this.currentTransform = new Matrix2d();
            }
            this.setTileTransform(this.currentTransform.identity());
        }

        // clear out the flags and set the tileId
        this.tileId &= TMX_CLEAR_BIT_MASK$1;
    }

    /**
     * set the transformation matrix for this tile
     * @ignore
     */
    setTileTransform(transform) {
        transform.translate(this.width / 2, this.height / 2);
        if (this.flippedAD) {
            transform.rotate(-90 * Math.PI / 180);
            transform.scale(-1, 1);
        }
        if (this.flippedX) {
            transform.scale(
                this.flippedAD ? 1 : -1, this.flippedAD ? -1 : 1
            );
        }
        if (this.flippedY) {
            transform.scale(
                 this.flippedAD ? -1 : 1, this.flippedAD ? 1 : -1
             );
        }
        transform.translate(-this.width / 2, -this.height / 2);
    }

    /**
     * return a renderable object for this Tile object
     * @name Tile#getRenderable
     * @public
     * @param {object} [settings] see {@link Sprite}
     * @returns {Renderable} a me.Sprite object
     */
    getRenderable(settings) {
        var renderable;
        var tileset = this.tileset;

        if (tileset.animations.has(this.tileId)) {
            var frames = [];
            var frameId = [];
            (tileset.animations.get(this.tileId).frames).forEach(function (frame) {
                frameId.push(frame.tileid);
                frames.push({
                    name : "" + frame.tileid,
                    delay : frame.duration
                });
            });
            renderable = tileset.texture.createAnimationFromName(frameId, settings);
            renderable.addAnimation(this.tileId - tileset.firstgid, frames);
            renderable.setCurrentAnimation(this.tileId - tileset.firstgid);

        } else {
            if (tileset.isCollection === true) {
                var image = tileset.getTileImage(this.tileId);
                renderable = new Sprite(0, 0,
                    Object.assign({
                        image: image
                    })//, settings)
                );
                renderable.anchorPoint.set(0, 0);
                renderable.scale((settings.width / this.width), (settings.height / this.height));
                if (typeof settings.rotation !== "undefined") {
                    renderable.anchorPoint.set(0.5, 0.5);
                    renderable.currentTransform.rotate(settings.rotation);
                    renderable.currentTransform.translate(settings.width / 2, settings.height / 2);
                    // TODO : move the rotation related code from TMXTiledMap to here (under)
                    settings.rotation = undefined;
                }
            } else {
                renderable = tileset.texture.createSpriteFromName(this.tileId - tileset.firstgid, settings);
                renderable.anchorPoint.set(0, 0);
            }
        }

        // any H/V flipping to apply?
        this.setTileTransform(renderable.currentTransform);

        return renderable;
    }
}

// https://developer.chrome.com/blog/canvas2d/#round-rect

/**
 * @classdesc
 * a rectangle object with rounded corners
 * @augments Rect
 */
class RoundRect extends Rect {
    /**
     * @param {number} x position of the rounded rectangle
     * @param {number} y position of the rounded rectangle
     * @param {number} width the rectangle width
     * @param {number} height the rectangle height
     * @param {number} [radius=20] the radius of the rounded corner
     */
    constructor(x, y, width, height, radius = 20) {
        // parent constructor
        super(x, y, width, height);

        // set the corner radius
        this.radius = radius;
    }

    /** @ignore */
    onResetEvent(x, y, w, h, radius) {
        super.setShape(x, y, w, h);
        this.radius = radius;
    }


    /**
     * the radius of the rounded corner
     * @public
     * @type {number}
     * @default 20
     * @name radius
     * @memberof RoundRect
     */
    get radius() {
        return this._radius;
    }
    set radius(value) {
        // verify the rectangle is at least as wide and tall as the rounded corners.
        if (this.width < 2 * value) {
            value = this.width / 2;
        }
        if (this.height < 2 * value) {
            value = this.height / 2;
        }
        this._radius = value;
    }

    /**
     * copy the position, size and radius of the given rounded rectangle into this one
     * @name copy
     * @memberof RoundRect
     * @param {RoundRect} rrect source rounded rectangle
     * @returns {RoundRect} new rectangle
     */
    copy(rrect) {
        super.setShape(rrect.pos.x, rrect.pos.y, rrect.width, rrect.height);
        this.radius = rrect.radius;
        return this;
    }

    /**
     * Returns true if the rounded rectangle contains the given point
     * @name contains
     * @memberof RoundRect
     * @method
     * @param  {number} x x coordinate
     * @param  {number} y y coordinate
     * @returns {boolean} true if contains
     */

    /**
     * Returns true if the rounded rectangle contains the given point
     * @name contains
     * @memberof RoundRect
     * @param {Vector2d} point
     * @returns {boolean} true if contains
     */
    contains() {
        var arg0 = arguments[0];
        var _x, _y;
        if (arguments.length === 2) {
             // x, y
             _x = arg0;
             _y = arguments[1];
         } else {
             if (arg0 instanceof Rect) {
                 // good enough
                 return super.contains(arg0);
             } else {
                 // vector
                _x = arg0.x;
                _y = arg0.y;
             }
        }

        // check whether point is outside the bounding box
        if (_x < this.left || _x >= this.right || _y < this.top || _y >= this.bottom) {
            return false; // outside bounding box
        }

        // check whether point is within the bounding box minus radius
        if ((_x >= this.left + this.radius && _x <= this.right - this.radius) || (_y >= this.top + this.radius && _y <= this.bottom - this.radius)) {
            return true;
        }

        // check whether point is in one of the rounded corner areas
        var tx, ty;
        var radiusX =  Math.max(0, Math.min(this.radius, this.width / 2));
        var radiusY =  Math.max(0, Math.min(this.radius, this.height / 2));

        if (_x < this.left + radiusX && _y < this.top + radiusY) {
            tx = _x - this.left - radiusX;
            ty = _y - this.top - radiusY;
        } else if (_x > this.right - radiusX && _y < this.top + radiusY) {
            tx = _x - this.right + radiusX;
            ty = _y - this.top - radiusY;
        } else if (_x > this.right - radiusX && _y > this.bottom - radiusY) {
            tx = _x - this.right + radiusX;
            ty = _y - this.bottom + radiusY;
        } else if (_x < this.left + radiusX && _y > this.bottom - radiusY) {
            tx = _x - this.left - radiusX;
            ty = _y - this.bottom + radiusY;
        } else {
            return false; // inside and not within the rounded corner area
        }

        // Pythagorean theorem.
        return ((tx * tx) + (ty * ty) <= (radiusX * radiusY));
    }

    /**
     * check if this RoundRect is identical to the specified one
     * @name equals
     * @memberof RoundRect
     * @param {RoundRect} rrect
     * @returns {boolean} true if equals
     */
    equals(rrect) {
        return super.equals(rrect) && this.radius === rrect.radius;
    }

    /**
     * clone this RoundRect
     * @name clone
     * @memberof RoundRect
     * @returns {RoundRect} new RoundRect
     */
    clone() {
        return new RoundRect(this.pos.x, this.pos.y, this.width, this.height, this.radius);
    }
}

/**
 * @classdesc
 * a line segment Object
 * @augments Polygon
 * @param {number} x origin point of the Line
 * @param {number} y origin point of the Line
 * @param {Vector2d[]} points array of vectors defining the Line
 */

class Line extends Polygon {

    /**
     * Returns true if the Line contains the given point
     * @name contains
     * @memberof Line
     * @method
     * @param {Vector2d} point
     * @returns {boolean} true if contains
     */

    /**
     * Returns true if the Line contains the given point
     * @name contains
     * @memberof Line
     * @param  {number} x x coordinate
     * @param  {number} y y coordinate
     * @returns {boolean} true if contains
     */
    contains() {
        var _x, _y;

        if (arguments.length === 2) {
          // x, y
          _x = arguments[0];
          _y = arguments[1];
        } else {
          // vector
          _x = arguments[0].x;
          _y = arguments[0].y;
        }

        // translate the given coordinates,
        // rather than creating temp translated vectors
        _x -= this.pos.x; // Cx
        _y -= this.pos.y; // Cy
        var start = this.points[0]; // Ax/Ay
        var end = this.points[1]; // Bx/By

        //(Cy - Ay) * (Bx - Ax) = (By - Ay) * (Cx - Ax)
        return (_y - start.y) * (end.x - start.x) === (end.y - start.y) * (_x - start.x);
    }

    /**
     * Computes the calculated collision edges and normals.
     * This **must** be called if the `points` array, `angle`, or `offset` is modified manually.
     * @name recalc
     * @memberof Line
     * @returns {Line} this instance for objecf chaining
     */
    recalc() {
        var edges = this.edges;
        var normals = this.normals;
        var indices = this.indices;

        // Copy the original points array and apply the offset/angle
        var points = this.points;

        if (points.length !== 2) {
            throw new Error("Requires exactly 2 points");
        }

        // Calculate the edges/normals
        if (edges[0] === undefined) {
            edges[0] = pool.pull("Vector2d");
        }
        edges[0].copy(points[1]).sub(points[0]);
        if (normals[0] === undefined) {
            normals[0] = pool.pull("Vector2d");
        }
        normals[0].copy(edges[0]).perp().normalize();

        // do not do anything here, indices will be computed by
        // toIndices if array is empty upon function call
        indices.length = 0;

        return this;
    }

    /**
     * clone this line segment
     * @name clone
     * @memberof Line
     * @returns {Line} new Line
     */
    clone() {
        var copy = [];
        this.points.forEach(function (point) {
            copy.push(point.clone());
        });
        return new Line(this.pos.x, this.pos.y, copy);
    }

}

/**
 * @classdesc
 * a simplified path2d implementation, supporting only one path
 */
class Path2D {
    constructor() {
        /**
         * the points defining the current path
         * @public
         * @type {Vector2d[]}
         * @name points
         * @memberof Path2D#
         */
        this.points = [];

        /**
         * space between interpolated points for quadratic and bezier curve approx. in pixels.
         * @public
         * @type {number}
         * @name arcResolution
         * @default 5
         * @memberof Path2D#
         */
        this.arcResolution = 5;

        /* @ignore */
        this.vertices = [];
    }

    /**
     * begin a new path
     * @name beginPath
     * @memberof Path2D
     */
    beginPath() {
        // empty the cache and recycle all vectors
        this.points.forEach((point) => {
            pool.push(point);
        });
        this.points.length = 0;
    }

    /**
     * causes the point of the pen to move back to the start of the current path.
     * It tries to draw a straight line from the current point to the start.
     * If the shape has already been closed or has only one point, this function does nothing.
     * @name closePath
     * @memberof Path2D
     */
    closePath() {
        var points = this.points;
        if (points.length > 1 && !points[points.length-1].equals(points[0])) {
            points.push(pool.pull("Vector2d", points[0].x, points[0].y));
        }
    }

    /**
     * triangulate the shape defined by this path into an array of triangles
     * @name triangulatePath
     * @memberof Path2D
     * @returns {Vector2d[]}
     */
    triangulatePath() {
        var i = 0;
        var points = this.points;
        var vertices = this.vertices;
        var indices = earcut$1.exports(points.flatMap(p => [p.x, p.y]));

        // calculate all vertices
        for (i = 0; i < indices.length; i++ ) {
            if (typeof vertices[i] === "undefined") {
                // increase cache buffer if necessary
                vertices[i] = pool.pull("Vector2d");
            }
            vertices[i].set(points[indices[i]].x, points[indices[i]].y);
        }

        // recycle overhead from a previous triangulation
        while (vertices.length > indices.length) {
            pool.push(vertices[vertices.length-1]);
            vertices.length -= 1;
        }

        return vertices;
    }

    /**
     * moves the starting point of the current path to the (x, y) coordinates.
     * @name moveTo
     * @memberof Path2D
     * @param {number} x the x-axis (horizontal) coordinate of the point.
     * @param {number} y the y-axis (vertical) coordinate of the point.
     */
    moveTo(x, y) {
      this.points.push(pool.pull("Vector2d", x, y));
    }

    /**
     * connects the last point in the current patch to the (x, y) coordinates with a straight line.
     * @name lineTo
     * @memberof Path2D
     * @param {number} x the x-axis coordinate of the line's end point.
     * @param {number} y the y-axis coordinate of the line's end point.
     */
    lineTo(x, y) {
        this.points.push(pool.pull("Vector2d", x, y));
    }

    /**
     * adds an arc to the current path which is centered at (x, y) position with the given radius,
     * starting at startAngle and ending at endAngle going in the given direction by counterclockwise (defaulting to clockwise).
     * @name arc
     * @memberof Path2D
     * @param {number} x the horizontal coordinate of the arc's center.
     * @param {number} y the vertical coordinate of the arc's center.
     * @param {number} radius the arc's radius. Must be positive.
     * @param {number} startAngle the angle at which the arc starts in radians, measured from the positive x-axis.
     * @param {number} endAngle the angle at which the arc ends in radians, measured from the positive x-axis.
     * @param {boolean} [anticlockwise=false] an optional boolean value. If true, draws the arc counter-clockwise between the start and end angles.
     */
    arc(x, y, radius, startAngle, endAngle, anticlockwise = false) {
        var points = this.points;
        // based on from https://github.com/karellodewijk/canvas-webgl/blob/master/canvas-webgl.js
        //bring angles all in [0, 2*PI] range
        if (startAngle === endAngle) return;
        var fullCircle = anticlockwise ? Math.abs(startAngle-endAngle) >= (TAU) : Math.abs(endAngle-startAngle) >= (TAU);

        startAngle = startAngle % (TAU);
        endAngle = endAngle % (TAU);

        if (startAngle < 0) startAngle += TAU;
        if (endAngle < 0) endAngle += TAU;

        if (startAngle >= endAngle) {
            endAngle+= TAU;
        }

        var diff = endAngle - startAngle;
        var direction = 1;
        if (anticlockwise) {
            direction = -1;
            diff = TAU - diff;
        }

        if (fullCircle) diff = TAU;

        var length = diff * radius;
        var nr_of_interpolation_points = length / this.arcResolution;
        var dangle = diff / nr_of_interpolation_points;

        var angle = startAngle;
        for (var j = 0; j < nr_of_interpolation_points; j++) {
            points.push(pool.pull("Vector2d", x + radius * Math.cos(angle), y + radius * Math.sin(angle)));
            angle += direction * dangle;
        }
        points.push(pool.pull("Vector2d", x + radius * Math.cos(endAngle), y + radius * Math.sin(endAngle)));
    }

    /**
     * adds a circular arc to the path with the given control points and radius, connected to the previous point by a straight line.
     * @name arcTo
     * @memberof Path2D
     * @param {number} x1 the x-axis coordinate of the first control point.
     * @param {number} y1 the y-axis coordinate of the first control point.
     * @param {number} x2 the x-axis coordinate of the second control point.
     * @param {number} y2 the y-axis coordinate of the second control point.
     * @param {number} radius the arc's radius. Must be positive.
     */
    arcTo(x1, y1, x2, y2, radius) {
        var points = this.points;
        // based on from https://github.com/karellodewijk/canvas-webgl/blob/master/canvas-webgl.js
        var x0 = points[points.length-1].x, y0 = points[points.length-1].y;

        //a = -incoming vector, b = outgoing vector to x1, y1
        var a = [x0 - x1, y0 - y1];
        var b = [x2 - x1, y2 - y1];

        //normalize
        var l_a = Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2));
        var l_b = Math.sqrt(Math.pow(b[0], 2) + Math.pow(b[1], 2));
        a[0] /= l_a; a[1] /= l_a; b[0] /= l_b; b[1] /= l_b;
        var angle = Math.atan2(a[1], a[0]) - Math.atan2(b[1], b[0]);

        //work out tangent points using tan(Î¸) = opposite / adjacent; angle/2 because hypotenuse is the bisection of a,b
        var tan_angle_div2 = Math.tan(angle/2);
        var adj_l = (radius/tan_angle_div2);

        var tangent_point1 =  [x1 + a[0] * adj_l, y1 + a[1] * adj_l];
        var tangent_point2 =  [x1 + b[0] * adj_l, y1 + b[1] * adj_l];

        points.push(pool.pull("Vector2d", tangent_point1[0], tangent_point1[1]));

        var bisec = [(a[0] + b[0]) / 2.0, (a[1] + b[1]) / 2.0];
        var bisec_l = Math.sqrt(Math.pow(bisec[0], 2) + Math.pow(bisec[1], 2));
        bisec[0] /= bisec_l; bisec[1] /= bisec_l;

        var hyp_l = Math.sqrt(Math.pow(radius, 2) + Math.pow(adj_l, 2));
        var center = [x1 + hyp_l * bisec[0], y1 + hyp_l * bisec[1]];

        var startAngle = Math.atan2(tangent_point1[1] - center[1], tangent_point1[0] - center[0]);
        var endAngle = Math.atan2(tangent_point2[1] - center[1], tangent_point2[0] - center[0]);

        this.arc(center[0], center[1], radius, startAngle, endAngle);
    }

    /**
     * adds an elliptical arc to the path which is centered at (x, y) position with the radii radiusX and radiusY
     * starting at startAngle and ending at endAngle going in the given direction by counterclockwise.
     * @name ellipse
     * @memberof Path2D
     * @param {number} x the x-axis (horizontal) coordinate of the ellipse's center.
     * @param {number} y the  y-axis (vertical) coordinate of the ellipse's center.
     * @param {number} radiusX the ellipse's major-axis radius. Must be non-negative.
     * @param {number} radiusY the ellipse's minor-axis radius. Must be non-negative.
     * @param {number} rotation the rotation of the ellipse, expressed in radians.
     * @param {number} startAngle the angle at which the ellipse starts, measured clockwise from the positive x-axis and expressed in radians.
     * @param {number} endAngle the angle at which the ellipse ends, measured clockwise from the positive x-axis and expressed in radians.
     * @param {boolean} [anticlockwise=false] an optional boolean value which, if true, draws the ellipse counterclockwise (anticlockwise).
     */
    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise = false) {
        var points = this.points;
        // based on from https://github.com/karellodewijk/canvas-webgl/blob/master/canvas-webgl.js
        if (startAngle === endAngle) return;
        var fullCircle = anticlockwise ? Math.abs(startAngle-endAngle) >= (TAU) : Math.abs(endAngle-startAngle) >= (TAU);

        //bring angles all in [0, 2*PI] range
        startAngle = startAngle % (TAU);
        endAngle = endAngle % (TAU);
        if (startAngle < 0) startAngle += TAU;
        if (endAngle < 0) endAngle += TAU;

        if (startAngle>=endAngle) {
            endAngle += TAU;
        }

        var diff = endAngle - startAngle;

        var direction = 1;
        if (anticlockwise) {
            direction = -1;
            diff = TAU - diff;
        }

        if (fullCircle) diff = TAU;

        var length = (diff * radiusX + diff * radiusY) / 2;
        var nr_of_interpolation_points = length / this.arcResolution;
        var dangle = diff / nr_of_interpolation_points;

        var angle = startAngle;
        var cos_rotation = Math.cos(rotation);
        var sin_rotation = Math.sin(rotation);
        for (var j = 0; j < nr_of_interpolation_points; j++) {
            var _x1 = radiusX * Math.cos(angle);
            var _y1 = radiusY * Math.sin(angle);
            var _x2 = x + _x1 * cos_rotation - _y1 * sin_rotation;
            var _y2 = y + _x1 * sin_rotation + _y1 * cos_rotation;
            points.push(pool.pull("Vector2d", _x2, _y2));
            angle += direction * dangle;
        }
        //var x1 = radiusX * Math.cos(endAngle);
        //var y1 = radiusY * Math.sin(endAngle);
        //points.push(pool.pull("Vector2d", x + x1 * cos_rotation - y1 * sin_rotation, y + x1 * sin_rotation + y1 * cos_rotation));
    }

    /**
     * creates a path for a rectangle at position (x, y) with a size that is determined by width and height.
     * @name rect
     * @memberof Path2D
     * @param {number} x the x-axis coordinate of the rectangle's starting point.
     * @param {number} y the y-axis coordinate of the rectangle's starting point.
     * @param {number} width the rectangle's width. Positive values are to the right, and negative to the left.
     * @param {number} height the rectangle's height. Positive values are down, and negative are up.
     */
    rect(x, y, width, height) {
        this.moveTo(x, y);
        this.lineTo(x + width, y);
        this.lineTo(x + width, y + height);
        this.lineTo(x, y + height);
        this.lineTo(x, y);
    }

    /**
     * adds an rounded rectangle to the current path.
     * @name roundRect
     * @memberof Path2D
     * @param {number} x the x-axis coordinate of the rectangle's starting point.
     * @param {number} y the y-axis coordinate of the rectangle's starting point.
     * @param {number} width the rectangle's width. Positive values are to the right, and negative to the left.
     * @param {number} height the rectangle's height. Positive values are down, and negative are up.
     * @param {number} radius the arc's radius to draw the borders. Must be positive.
     */
     roundRect(x, y, width, height, radius) {
        this.moveTo(x + radius, y);
        this.lineTo(x + width - radius, y);
        this.arcTo(x + width, y, x + width, y + radius, radius);
        this.lineTo(x + width, y + height - radius);
        this.arcTo(x + width, y + height, x + width - radius, y + height, radius);
        this.lineTo(x + radius, y + height);
        this.arcTo(x, y + height, x, y + height - radius, radius);
        this.lineTo(x, y + radius);
        this.arcTo(x, y, x + radius, y, radius);
    }
}

/**
 * @classdesc
 * a base renderer object
 */
class Renderer {
    /**
     * @param {object} options The renderer parameters
     * @param {number} options.width The width of the canvas without scaling
     * @param {number} options.height The height of the canvas without scaling
     * @param {HTMLCanvasElement} [options.canvas] The html canvas to draw to on screen
     * @param {boolean} [options.doubleBuffering=false] Whether to enable double buffering
     * @param {boolean} [options.antiAlias=false] Whether to enable anti-aliasing, use false (default) for a pixelated effect.
     * @param {boolean} [options.failIfMajorPerformanceCaveat=true] If true, the renderer will switch to CANVAS mode if the performances of a WebGL context would be dramatically lower than that of a native application making equivalent OpenGL calls.
     * @param {boolean} [options.transparent=false] Whether to enable transparency on the canvas (performance hit when enabled)
     * @param {boolean} [options.blendMode="normal"] the default blend mode to use ("normal", "multiply")
     * @param {boolean} [options.subPixel=false] Whether to enable subpixel rendering (performance hit when enabled)
     * @param {boolean} [options.verbose=false] Enable the verbose mode that provides additional details as to what the renderer is doing
     * @param {number} [options.zoomX=width] The actual width of the canvas with scaling applied
     * @param {number} [options.zoomY=height] The actual height of the canvas with scaling applied
     */
    constructor(options) {
        /**
         * The given constructor options
         * @public
         * @name settings
         * @memberof Renderer#
         * @type {object}
         */
        this.settings = options;

        /**
         * true if the current rendering context is valid
         * @name isContextValid
         * @memberof Renderer#
         * @default true
         * type {boolean}
         */
        this.isContextValid = true;

        /**
         * The Path2D instance used by the renderer to draw primitives
         * @name path2D
         * @type {Path2D}
         * @memberof Renderer#
         */
        this.path2D = new Path2D();

        /**
         * @ignore
         */
        this.currentScissor = new Int32Array([ 0, 0, this.settings.width, this.settings.height ]);

        /**
         * @ignore
         */
        this.maskLevel = 0;

        /**
         * @ignore
         */
        this.currentBlendMode = "none";

        // create the main screen canvas
        if (device.ejecta === true) {
            // a main canvas is already automatically created by Ejecta
            this.canvas = document.getElementById("canvas");
        } else if (typeof globalThis.canvas !== "undefined") {
            // a global canvas is available, e.g. webapp adapter for wechat
            this.canvas = globalThis.canvas;
        } else if (typeof this.settings.canvas !== "undefined") {
            this.canvas = this.settings.canvas;
        } else {
            this.canvas = createCanvas(this.settings.zoomX, this.settings.zoomY);
        }

        // canvas object and context
        this.backBufferCanvas = this.canvas;
        this.context = null;

        // global color
        this.currentColor = new Color(0, 0, 0, 1.0);

        // global tint color
        this.currentTint = new Color(255, 255, 255, 1.0);

        // the projectionMatrix (set through setProjection)
        this.projectionMatrix = new Matrix3d();

        // default uvOffset
        this.uvOffset = 0;

        // reset the instantiated renderer on game reset
        on(GAME_RESET, () => {
            renderer.reset();
        });
    }

    /**
     * prepare the framebuffer for drawing a new frame
     * @name clear
     * @memberof Renderer
     */
    clear() {}

    /**
     * Reset context state
     * @name reset
     * @memberof Renderer
     */
    reset() {
        this.resetTransform();
        this.setBlendMode(this.settings.blendMode);
        this.setColor("#000000");
        this.clearTint();
        this.cache.clear();
        this.currentScissor[0] = 0;
        this.currentScissor[1] = 0;
        this.currentScissor[2] = this.backBufferCanvas.width;
        this.currentScissor[3] = this.backBufferCanvas.height;
        this.clearMask();
    }

    /**
     * return a reference to the system canvas
     * @name getCanvas
     * @memberof Renderer
     * @returns {HTMLCanvasElement}
     */
    getCanvas() {
        return this.backBufferCanvas;
    }

    /**
     * return a reference to the screen canvas
     * @name getScreenCanvas
     * @memberof Renderer
     * @returns {HTMLCanvasElement}
     */
    getScreenCanvas() {
        return this.canvas;
    }

    /**
     * return a reference to the screen canvas corresponding 2d Context<br>
     * (will return buffered context if double buffering is enabled, or a reference to the Screen Context)
     * @name getScreenContext
     * @memberof Renderer
     * @returns {CanvasRenderingContext2D}
     */
    getScreenContext() {
        return this.context;
    }

    /**
     * returns the current blend mode for this renderer
     * @name getBlendMode
     * @memberof Renderer
     * @returns {string} blend mode
     */
    getBlendMode() {
        return this.currentBlendMode;
    }

    /**
     * Returns the 2D Context object of the given Canvas<br>
     * Also configures anti-aliasing and blend modes based on constructor options.
     * @name getContext2d
     * @memberof Renderer
     * @param {HTMLCanvasElement} canvas
     * @param {boolean} [transparent=true] use false to disable transparency
     * @returns {CanvasRenderingContext2D}
     */
    getContext2d(canvas, transparent) {
        if (typeof canvas === "undefined" || canvas === null) {
            throw new Error(
                "You must pass a canvas element in order to create " +
                "a 2d context"
            );
        }

        if (typeof canvas.getContext === "undefined") {
            throw new Error(
                "Your browser does not support HTML5 canvas."
            );
        }

        if (typeof transparent !== "boolean") {
            transparent = true;
        }

        var _context = canvas.getContext("2d", {
                "alpha" : transparent
        });

        if (!_context.canvas) {
            _context.canvas = canvas;
        }
        this.setAntiAlias(_context, this.settings.antiAlias);
        return _context;
    }

    /**
     * return the width of the system Canvas
     * @name getWidth
     * @memberof Renderer
     * @returns {number}
     */
    getWidth() {
        return this.backBufferCanvas.width;
    }

    /**
     * return the height of the system Canvas
     * @name getHeight
     * @memberof Renderer
     * @returns {number} height of the system Canvas
     */
    getHeight() {
        return this.backBufferCanvas.height;
    }

    /**
     * get the current fill & stroke style color.
     * @name getColor
     * @memberof Renderer
     * @returns {Color} current global color
     */
    getColor() {
        return this.currentColor;
    }

    /**
     * return the current global alpha
     * @name globalAlpha
     * @memberof Renderer
     * @returns {number}
     */
    globalAlpha() {
        return this.currentColor.glArray[3];
    }

    /**
     * check if the given rect or bounds overlaps with the renderer screen coordinates
     * @name overlaps
     * @memberof Renderer
     * @param {Rect|Bounds} bounds
     * @returns {boolean} true if overlaps
     */
    overlaps(bounds) {
        return (
            bounds.left <= this.getWidth() && bounds.right >= 0 &&
            bounds.top <= this.getHeight() && bounds.bottom >= 0
        );
    }


    /**
     * resizes the system canvas
     * @name resize
     * @memberof Renderer
     * @param {number} width new width of the canvas
     * @param {number} height new height of the canvas
     */
    resize(width, height) {
        if (width !== this.backBufferCanvas.width || height !== this.backBufferCanvas.height) {
            this.canvas.width = this.backBufferCanvas.width = width;
            this.canvas.height = this.backBufferCanvas.height = height;
            this.currentScissor[0] = 0;
            this.currentScissor[1] = 0;
            this.currentScissor[2] = width;
            this.currentScissor[3] = height;
            // publish the corresponding event
            emit(CANVAS_ONRESIZE, width, height);
        }
    }

    /**
     * enable/disable image smoothing (scaling interpolation) for the given context
     * @name setAntiAlias
     * @memberof Renderer
     * @param {CanvasRenderingContext2D} context
     * @param {boolean} [enable=false]
     */
    setAntiAlias(context, enable) {
        var canvas = context.canvas;

        // enable/disable antialis on the given Context2d object
        setPrefixed("imageSmoothingEnabled", enable === true, context);

        // set antialias CSS property on the main canvas
        if (enable !== true) {
            // https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering
            canvas.style["image-rendering"] = "optimizeSpeed"; // legal fallback
            canvas.style["image-rendering"] = "-moz-crisp-edges"; // Firefox
            canvas.style["image-rendering"] = "-o-crisp-edges"; // Opera
            canvas.style["image-rendering"] = "-webkit-optimize-contrast"; // Safari
            canvas.style["image-rendering"] = "optimize-contrast"; // CSS 3
            canvas.style["image-rendering"] = "crisp-edges"; // CSS 4
            canvas.style["image-rendering"] = "pixelated"; // CSS 4
            canvas.style.msInterpolationMode = "nearest-neighbor"; // IE8+
        } else {
            canvas.style["image-rendering"] = "auto";
        }
    }

    /**
     * set/change the current projection matrix (WebGL only)
     * @name setProjection
     * @memberof Renderer
     * @param {Matrix3d} matrix
     */
    setProjection(matrix) {
        this.projectionMatrix.copy(matrix);
    }

    /**
     * stroke the given shape
     * @name stroke
     * @memberof Renderer
     * @param {Rect|RoundRect|Polygon|Line|Ellipse} shape a shape object to stroke
     * @param {boolean} [fill=false] fill the shape with the current color if true
     */
    stroke(shape, fill) {
        if (shape instanceof RoundRect) {
            this.strokeRoundRect(shape.left, shape.top, shape.width, shape.height, shape.radius, fill);
            return;
        }
        if (shape instanceof Rect || shape instanceof Bounds) {
            this.strokeRect(shape.left, shape.top, shape.width, shape.height, fill);
            return;
        }
        if (shape instanceof Line || shape instanceof Polygon) {
            this.strokePolygon(shape, fill);
            return;
        }
        if (shape instanceof Ellipse) {
            this.strokeEllipse(
                shape.pos.x,
                shape.pos.y,
                shape.radiusV.x,
                shape.radiusV.y,
                fill
            );
            return;
        }
        throw new Error("Invalid geometry for fill/stroke");
    }

    /**
     * fill the given shape
     * @name fill
     * @memberof Renderer
     * @param {Rect|RoundRect|Polygon|Line|Ellipse} shape a shape object to fill
     */
    fill(shape) {
        this.stroke(shape, true);
    }

    /**
     * tint the given image or canvas using the given color
     * @name tint
     * @memberof Renderer
     * @param {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas} src the source image to be tinted
     * @param {Color|string} color the color that will be used to tint the image
     * @param {string} [mode="multiply"] the composition mode used to tint the image
     * @returns {HTMLCanvasElement|OffscreenCanvas} a new canvas element representing the tinted image
     */
    tint(src, color, mode) {
        var canvas = createCanvas(src.width, src.height, true);
        var context = this.getContext2d(canvas);

        context.save();

        context.fillStyle = color instanceof Color ? color.toRGB() : color;
        context.fillRect(0, 0, src.width, src.height);

        context.globalCompositeOperation = mode || "multiply";
        context.drawImage(src, 0, 0);
        context.globalCompositeOperation = "destination-atop";
        context.drawImage(src, 0, 0);

        context.restore();

        return canvas;
    }

    /**
     * A mask limits rendering elements to the shape and position of the given mask object.
     * So, if the renderable is larger than the mask, only the intersecting part of the renderable will be visible.
     * Mask are not preserved through renderer context save and restore.
     * @name setMask
     * @memberof Renderer
     * @param {Rect|RoundRect|Polygon|Line|Ellipse} [mask] the shape defining the mask to be applied
     * @param {boolean} [invert=false] either the given shape should define what is visible (default) or the opposite
     */
    // eslint-disable-next-line no-unused-vars
    setMask(mask) {}

    /**
     * disable (remove) the rendering mask set through setMask.
     * @name clearMask
     * @see Renderer#setMask
     * @memberof Renderer
     */
    clearMask() {}

    /**
     * set a coloring tint for sprite based renderables
     * @name setTint
     * @memberof Renderer
     * @param {Color} tint the tint color
     * @param {number} [alpha] an alpha value to be applied to the tint
     */
    setTint(tint, alpha = tint.alpha) {
        // global tint color
        this.currentTint.copy(tint);
        this.currentTint.alpha *= alpha;
    }

    /**
     * clear the rendering tint set through setTint.
     * @name clearTint
     * @see Renderer#setTint
     * @memberof Renderer
     */
    clearTint() {
        // reset to default
        this.currentTint.setColor(255, 255, 255, 1.0);
    }

    /**
     * @ignore
     */
    drawFont(/*bounds*/) {}

}

/**
 * @classdesc
 * a canvas renderer object
 * @augments Renderer
 */
class CanvasRenderer extends Renderer {
    /**
     * @param {object} options The renderer parameters
     * @param {number} options.width The width of the canvas without scaling
     * @param {number} options.height The height of the canvas without scaling
     * @param {HTMLCanvasElement} [options.canvas] The html canvas to draw to on screen
     * @param {boolean} [options.doubleBuffering=false] Whether to enable double buffering
     * @param {boolean} [options.antiAlias=false] Whether to enable anti-aliasing
     * @param {boolean} [options.transparent=false] Whether to enable transparency on the canvas (performance hit when enabled)
     * @param {boolean} [options.subPixel=false] Whether to enable subpixel renderering (performance hit when enabled)
     * @param {boolean} [options.textureSeamFix=true] enable the texture seam fix when rendering Tile when antiAlias is off for the canvasRenderer
     * @param {number} [options.zoomX=width] The actual width of the canvas with scaling applied
     * @param {number} [options.zoomY=height] The actual height of the canvas with scaling applied
     */
    constructor(options) {
        // parent constructor
        super(options);

        // defined the 2d context
        this.context = this.getContext2d(this.getScreenCanvas(), this.settings.transparent);

        // create the back buffer if we use double buffering
        if (this.settings.doubleBuffering) {
            this.backBufferCanvas = createCanvas(this.settings.width, this.settings.height, true);
            this.backBufferContext2D = this.getContext2d(this.backBufferCanvas);
        }
        else {
            this.backBufferCanvas = this.getScreenCanvas();
            this.backBufferContext2D = this.context;
        }

        this.setBlendMode(this.settings.blendMode);

        // apply the default color to the 2d context
        this.setColor(this.currentColor);

        // create a texture cache
        this.cache = new TextureCache();

        if (this.settings.textureSeamFix !== false && !this.settings.antiAlias) {
            // enable the tile texture seam fix with the canvas renderer
            this.uvOffset = 1;
        }

        // context lost & restore event for canvas
        this.getScreenCanvas().addEventListener("contextlost", (e) => {
            e.preventDefault();
            this.isContextValid = false;
            emit(ONCONTEXT_LOST, this);
        }, false );
        // ctx.restoreContext()
        this.getScreenCanvas().addEventListener("contextrestored", () => {
            this.isContextValid = true;
            emit(ONCONTEXT_RESTORED, this);
        }, false );
    }

    /**
     * Reset context state
     * @name reset
     * @memberof CanvasRenderer
     */
    reset() {
        super.reset();
        this.clearColor(this.currentColor, this.settings.transparent !== true);
    }

    /**
     * Reset the canvas transform to identity
     * @name resetTransform
     * @memberof CanvasRenderer
     */
    resetTransform() {
        this.backBufferContext2D.setTransform(1, 0, 0, 1, 0, 0);
    }

    /**
     * set a blend mode for the given context. <br>
     * Supported blend mode between Canvas and WebGL remderer : <br>
     * - "normal" : this is the default mode and draws new content on top of the existing content <br>
     * <img src="images/normal-blendmode.png" width="510"/> <br>
     * - "multiply" : the pixels of the top layer are multiplied with the corresponding pixel of the bottom layer. A darker picture is the result. <br>
     * <img src="images/multiply-blendmode.png" width="510"/> <br>
     * - "additive or lighter" : where both content overlap the color is determined by adding color values. <br>
     * <img src="images/lighter-blendmode.png" width="510"/> <br>
     * - "screen" : The pixels are inverted, multiplied, and inverted again. A lighter picture is the result (opposite of multiply) <br>
     * <img src="images/screen-blendmode.png" width="510"/> <br>
     * @name setBlendMode
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
     * @memberof CanvasRenderer
     * @param {string} [mode="normal"] blend mode : "normal", "multiply", "lighter, "additive", "screen"
     * @param {CanvasRenderingContext2D} [context]
     */
    setBlendMode(mode = "normal", context) {
        context = context || this.getContext();
        this.currentBlendMode = mode;
        switch (mode) {
            case "screen" :
                context.globalCompositeOperation = "screen";
                break;

            case "lighter" :
            case "additive" :
                context.globalCompositeOperation = "lighter";
                break;

            case "multiply" :
                context.globalCompositeOperation = "multiply";
                break;

            default : // normal
                context.globalCompositeOperation = "source-over";
                this.currentBlendMode = "normal";
                break;
        }

        // transparent setting will override the given blendmode for this.context
        if (this.settings.doubleBuffering && this.settings.transparent) {
            // Clears the front buffer for each frame blit
            this.context.globalCompositeOperation = "copy";
        }
    }

    /**
     * prepare the framebuffer for drawing a new frame
     * @name clear
     * @memberof CanvasRenderer
     */
    clear() {
        if (this.settings.transparent) {
            this.clearColor("rgba(0,0,0,0)", true);
        }
    }

    /**
     * render the main framebuffer on screen
     * @name flush
     * @memberof CanvasRenderer
     */
    flush() {
        if (this.settings.doubleBuffering) {
            this.context.drawImage(this.backBufferCanvas, 0, 0);
        }
    }

    /**
     * Clears the main framebuffer with the given color
     * @name clearColor
     * @memberof CanvasRenderer
     * @param {Color|string} [color="#000000"] CSS color.
     * @param {boolean} [opaque=false] Allow transparency [default] or clear the surface completely [true]
     */
    clearColor(color = "#000000", opaque) {
        this.save();
        this.resetTransform();
        this.backBufferContext2D.globalCompositeOperation = opaque ? "copy" : "source-over";
        this.backBufferContext2D.fillStyle = (color instanceof Color) ? color.toRGBA() : color;
        this.fillRect(0, 0, this.backBufferCanvas.width, this.backBufferCanvas.height);
        this.restore();
    }

    /**
     * Erase the pixels in the given rectangular area by setting them to transparent black (rgba(0,0,0,0)).
     * @name clearRect
     * @memberof CanvasRenderer
     * @param {number} x x axis of the coordinate for the rectangle starting point.
     * @param {number} y y axis of the coordinate for the rectangle starting point.
     * @param {number} width The rectangle's width.
     * @param {number} height The rectangle's height.
     */
    clearRect(x, y, width, height) {
        this.getContext().clearRect(x, y, width, height);
    }

    /**
     * Create a pattern with the specified repetition
     * @name createPattern
     * @memberof CanvasRenderer
     * @param {Image} image Source image
     * @param {string} repeat Define how the pattern should be repeated
     * @returns {CanvasPattern}
     * @see ImageLayer#repeat
     * @example
     * var tileable   = renderer.createPattern(image, "repeat");
     * var horizontal = renderer.createPattern(image, "repeat-x");
     * var vertical   = renderer.createPattern(image, "repeat-y");
     * var basic      = renderer.createPattern(image, "no-repeat");
     */
    createPattern(image, repeat) {
        return this.getContext().createPattern(image, repeat);
    }

    /**
     * Draw an image onto the main using the canvas api
     * @name drawImage
     * @memberof CanvasRenderer
     * @param {Image} image An element to draw into the context. The specification permits any canvas image source (CanvasImageSource), specifically, a CSSImageValue, an HTMLImageElement, an SVGImageElement, an HTMLVideoElement, an HTMLCanvasElement, an ImageBitmap, or an OffscreenCanvas.
     * @param {number} sx The X coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
     * @param {number} sy The Y coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
     * @param {number} sw The width of the sub-rectangle of the source image to draw into the destination context. If not specified, the entire rectangle from the coordinates specified by sx and sy to the bottom-right corner of the image is used.
     * @param {number} sh The height of the sub-rectangle of the source image to draw into the destination context.
     * @param {number} dx The X coordinate in the destination canvas at which to place the top-left corner of the source image.
     * @param {number} dy The Y coordinate in the destination canvas at which to place the top-left corner of the source image.
     * @param {number} dw The width to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in width when drawn.
     * @param {number} dh The height to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in height when drawn.
     * @example
     * // Position the image on the canvas:
     * renderer.drawImage(image, dx, dy);
     * // Position the image on the canvas, and specify width and height of the image:
     * renderer.drawImage(image, dx, dy, dWidth, dHeight);
     * // Clip the image and position the clipped part on the canvas:
     * renderer.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
     */
    drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        var context = this.getContext();

        if (typeof sw === "undefined") {
            sw = dw = image.width;
            sh = dh = image.height;
            dx = sx;
            dy = sy;
            sx = 0;
            sy = 0;
        }
        else if (typeof dx === "undefined") {
            dx = sx;
            dy = sy;
            dw = sw;
            dh = sh;
            sw = image.width;
            sh = image.height;
            sx = 0;
            sy = 0;
        }

        if (this.settings.subPixel === false) {
            // clamp to pixel grid
            dx = ~~dx;
            dy = ~~dy;
        }

        // apply a tint if required
        var source = image;
        var tint = this.currentTint.toArray();
        if (tint[0] !== 1.0 || tint[1] !== 1.0 || tint[2] !== 1.0) {
            // get a tinted version of this image from the texture cache
            source = this.cache.tint(image, this.currentTint.toRGB());
        }
        context.drawImage(source, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    /**
     * Draw a pattern within the given rectangle.
     * @name drawPattern
     * @memberof CanvasRenderer
     * @param {CanvasPattern} pattern Pattern object
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @see CanvasRenderer#createPattern
     */
    drawPattern(pattern, x, y, width, height) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        var context = this.getContext();
        var fillStyle = context.fillStyle;
        context.fillStyle = pattern;
        context.fillRect(x, y, width, height);
        context.fillStyle = fillStyle;
    }

    /**
     * Stroke an arc at the specified coordinates with given radius, start and end points
     * @name strokeArc
     * @memberof CanvasRenderer
     * @param {number} x arc center point x-axis
     * @param {number} y arc center point y-axis
     * @param {number} radius
     * @param {number} start start angle in radians
     * @param {number} end end angle in radians
     * @param {boolean} [antiClockwise=false] draw arc anti-clockwise
     * @param {boolean} [fill=false] also fill the shape with the current color if true
     */
    strokeArc(x, y, radius, start, end, antiClockwise, fill = false) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        var context = this.getContext();

        context.translate(x, y);
        context.beginPath();
        context.arc(0, 0, radius, start, end, antiClockwise || false);
        context[fill === true ? "fill" : "stroke"]();
        context.translate(-x, -y);
    }

    /**
     * Fill an arc at the specified coordinates with given radius, start and end points
     * @name fillArc
     * @memberof CanvasRenderer
     * @param {number} x arc center point x-axis
     * @param {number} y arc center point y-axis
     * @param {number} radius
     * @param {number} start start angle in radians
     * @param {number} end end angle in radians
     * @param {boolean} [antiClockwise=false] draw arc anti-clockwise
     */
    fillArc(x, y, radius, start, end, antiClockwise) {
        this.strokeArc(x, y, radius, start, end, antiClockwise || false, true);
    }

    /**
     * Stroke an ellipse at the specified coordinates with given radius
     * @name strokeEllipse
     * @memberof CanvasRenderer
     * @param {number} x ellipse center point x-axis
     * @param {number} y ellipse center point y-axis
     * @param {number} w horizontal radius of the ellipse
     * @param {number} h vertical radius of the ellipse
     * @param {boolean} [fill=false] also fill the shape with the current color if true
     */
    strokeEllipse(x, y, w, h, fill = false) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        var context = this.getContext();

        var hw = w,
            hh = h,
            lx = x - hw,
            rx = x + hw,
            ty = y - hh,
            by = y + hh;

        var xmagic = hw * 0.551784,
            ymagic = hh * 0.551784,
            xmin = x - xmagic,
            xmax = x + xmagic,
            ymin = y - ymagic,
            ymax = y + ymagic;

        context.beginPath();
        context.moveTo(x, ty);
        context.bezierCurveTo(xmax, ty, rx, ymin, rx, y);
        context.bezierCurveTo(rx, ymax, xmax, by, x, by);
        context.bezierCurveTo(xmin, by, lx, ymax, lx, y);
        context.bezierCurveTo(lx, ymin, xmin, ty, x, ty);
        context[fill === true ? "fill" : "stroke"]();
        context.closePath();
    }

    /**
     * Fill an ellipse at the specified coordinates with given radius
     * @name fillEllipse
     * @memberof CanvasRenderer
     * @param {number} x ellipse center point x-axis
     * @param {number} y ellipse center point y-axis
     * @param {number} w horizontal radius of the ellipse
     * @param {number} h vertical radius of the ellipse
     */
    fillEllipse(x, y, w, h) {
        this.strokeEllipse(x, y, w, h, true);
    }

    /**
     * Stroke a line of the given two points
     * @name strokeLine
     * @memberof CanvasRenderer
     * @param {number} startX the start x coordinate
     * @param {number} startY the start y coordinate
     * @param {number} endX the end x coordinate
     * @param {number} endY the end y coordinate
     */
    strokeLine(startX, startY, endX, endY) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }

        var context = this.getContext();

        context.beginPath();
        context.moveTo(startX, startY);
        context.lineTo(endX, endY);
        context.stroke();
    }

    /**
     * Fill a line of the given two points
     * @name fillLine
     * @memberof CanvasRenderer
     * @param {number} startX the start x coordinate
     * @param {number} startY the start y coordinate
     * @param {number} endX the end x coordinate
     * @param {number} endY the end y coordinate
     */
    fillLine(startX, startY, endX, endY) {
        this.strokeLine(startX, startY, endX, endY);
    }

    /**
     * Stroke the given me.Polygon on the screen
     * @name strokePolygon
     * @memberof CanvasRenderer
     * @param {Polygon} poly the shape to draw
     * @param {boolean} [fill=false] also fill the shape with the current color if true
     */
    strokePolygon(poly, fill = false) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        var context = this.getContext();

        this.translate(poly.pos.x, poly.pos.y);
        context.beginPath();
        context.moveTo(poly.points[0].x, poly.points[0].y);
        var point;
        for (var i = 1; i < poly.points.length; i++) {
            point = poly.points[i];
            context.lineTo(point.x, point.y);
        }
        context.lineTo(poly.points[0].x, poly.points[0].y);
        context[fill === true ? "fill" : "stroke"]();
        context.closePath();
        this.translate(-poly.pos.x, -poly.pos.y);
    }

    /**
     * Fill the given me.Polygon on the screen
     * @name fillPolygon
     * @memberof CanvasRenderer
     * @param {Polygon} poly the shape to draw
     */
    fillPolygon(poly) {
        this.strokePolygon(poly, true);
    }

    /**
     * Stroke a rectangle at the specified coordinates
     * @name strokeRect
     * @memberof CanvasRenderer
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {boolean} [fill=false] also fill the shape with the current color if true
     */
    strokeRect(x, y, width, height, fill = false) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        var context = this.getContext();

        context[fill === true ? "fillRect" : "strokeRect"](x, y, width, height);
    }

    /**
     * Draw a filled rectangle at the specified coordinates
     * @name fillRect
     * @memberof CanvasRenderer
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */
    fillRect(x, y, width, height) {
        this.strokeRect(x, y, width, height, true);
    }

    /**
     * Stroke a rounded rectangle at the specified coordinates
     * @name strokeRoundRect
     * @memberof CanvasRenderer
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} radius
     * @param {boolean} [fill=false] also fill the shape with the current color if true
     */
    strokeRoundRect(x, y, width, height, radius, fill = false) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        var context = this.getContext();

        context.beginPath();
        context.roundRect(x, y, width, height, radius);
        context[fill === true ? "fill" : "stroke"]();
    }

    /**
     * Draw a rounded filled rectangle at the specified coordinates
     * @name fillRoundRect
     * @memberof CanvasRenderer
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} radius
     */
    fillRoundRect(x, y, width, height, radius) {
        this.strokeRoundRect(x, y, width, height, radius, true);
    }


    /**
     * return a reference to the system 2d Context
     * @name getContext
     * @memberof CanvasRenderer
     * @returns {CanvasRenderingContext2D}
     */
    getContext() {
        return this.backBufferContext2D;
    }

    /**
     * return a reference to the font 2d Context
     * @ignore
     */
    getFontContext() {
        // in canvas mode we can directly use the 2d context
        return this.getContext();
    }

    /**
     * save the canvas context
     * @name save
     * @memberof CanvasRenderer
     */
    save() {
        this.backBufferContext2D.save();
    }

    /**
     * restores the canvas context
     * @name restore
     * @memberof CanvasRenderer
     */
    restore() {
        this.backBufferContext2D.restore();
        this.currentColor.glArray[3] = this.getGlobalAlpha();
        this.currentScissor[0] = 0;
        this.currentScissor[1] = 0;
        this.currentScissor[2] = this.backBufferCanvas.width;
        this.currentScissor[3] = this.backBufferCanvas.height;
    }

    /**
     * rotates the canvas context
     * @name rotate
     * @memberof CanvasRenderer
     * @param {number} angle in radians
     */
    rotate(angle) {
        this.backBufferContext2D.rotate(angle);
    }

    /**
     * scales the canvas context
     * @name scale
     * @memberof CanvasRenderer
     * @param {number} x
     * @param {number} y
     */
    scale(x, y) {
        this.backBufferContext2D.scale(x, y);
    }

    /**
     * Set the current fill & stroke style color.
     * By default, or upon reset, the value is set to #000000.
     * @name setColor
     * @memberof CanvasRenderer
     * @param {Color|string} color css color value
     */
    setColor(color) {
        this.backBufferContext2D.strokeStyle =
        this.backBufferContext2D.fillStyle = (
            color instanceof Color ?
            color.toRGBA() :
            color
        );
    }

    /**
     * Set the global alpha
     * @name setGlobalAlpha
     * @memberof CanvasRenderer
     * @param {number} alpha 0.0 to 1.0 values accepted.
     */
    setGlobalAlpha(alpha) {
        this.backBufferContext2D.globalAlpha = this.currentColor.glArray[3] = alpha;
    }

    /**
     * Return the global alpha
     * @name getGlobalAlpha
     * @memberof CanvasRenderer
     * @returns {number} global alpha value
     */
    getGlobalAlpha() {
        return this.backBufferContext2D.globalAlpha;
    }

    /**
     * Set the line width on the context
     * @name setLineWidth
     * @memberof CanvasRenderer
     * @param {number} width Line width
     */
    setLineWidth(width) {
        this.backBufferContext2D.lineWidth = width;
    }

    /**
     * Reset (overrides) the renderer transformation matrix to the
     * identity one, and then apply the given transformation matrix.
     * @name setTransform
     * @memberof CanvasRenderer
     * @param {Matrix2d} mat2d Matrix to transform by
     */
    setTransform(mat2d) {
        this.resetTransform();
        this.transform(mat2d);
    }

    /**
     * Multiply given matrix into the renderer tranformation matrix
     * @name transform
     * @memberof CanvasRenderer
     * @param {Matrix2d} mat2d Matrix to transform by
     */
    transform(mat2d) {
        var m = mat2d.toArray(),
            a = m[0],
            b = m[1],
            c = m[3],
            d = m[4],
            e = m[6],
            f = m[7];

        if (this.settings.subPixel === false) {
            e |= 0;
            f |= 0;
        }

        this.backBufferContext2D.transform(a, b, c, d, e, f);
    }

    /**
     * Translates the context to the given position
     * @name translate
     * @memberof CanvasRenderer
     * @param {number} x
     * @param {number} y
     */
    translate(x, y) {
        if (this.settings.subPixel === false) {
            this.backBufferContext2D.translate(~~x, ~~y);
        } else {
            this.backBufferContext2D.translate(x, y);
        }
    }

    /**
     * clip the given region from the original canvas. Once a region is clipped,
     * all future drawing will be limited to the clipped region.
     * You can however save the current region using the save(),
     * and restore it (with the restore() method) any time in the future.
     * (<u>this is an experimental feature !</u>)
     * @name clipRect
     * @memberof CanvasRenderer
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */
    clipRect(x, y, width, height) {
        var canvas = this.backBufferCanvas;
        // if requested box is different from the current canvas size;
        if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height) {
            var currentScissor = this.currentScissor;
            // if different from the current scissor box
            if (currentScissor[0] !== x || currentScissor[1] !== y ||
                currentScissor[2] !== width || currentScissor[3] !== height) {
                var context = this.backBufferContext2D;
                context.beginPath();
                context.rect(x, y, width, height);
                context.clip();
                // save the new currentScissor box
                currentScissor[0] = x;
                currentScissor[1] = y;
                currentScissor[2] = width;
                currentScissor[3] = height;
            }
        }
    }

    /**
     * A mask limits rendering elements to the shape and position of the given mask object.
     * So, if the renderable is larger than the mask, only the intersecting part of the renderable will be visible.
     * Mask are not preserved through renderer context save and restore.
     * @name setMask
     * @memberof CanvasRenderer
     * @param {Rect|RoundRect|Polygon|Line|Ellipse} [mask] the shape defining the mask to be applied
     * @param {boolean} [invert=false] either the given shape should define what is visible (default) or the opposite
     */
    setMask(mask, invert = false) {
        var context = this.getContext();

        if (this.maskLevel === 0) {
            // only save context on the first mask
            context.save();
            context.beginPath();
        }

        // https://github.com/melonjs/melonJS/issues/648
        else if (mask instanceof RoundRect) {
            context.roundRect(mask.top, mask.left, mask.width, mask.height, mask.radius);
        } else if (mask instanceof Rect || mask instanceof Bounds) {
            context.rect(mask.top, mask.left, mask.width, mask.height);
        }  else if (mask instanceof Ellipse) {
            const _x = mask.pos.x, _y = mask.pos.y,
                hw = mask.radiusV.x,
                hh = mask.radiusV.y,
                lx = _x - hw,
                rx = _x + hw,
                ty = _y - hh,
                by = _y + hh;

            var xmagic = hw * 0.551784,
                ymagic = hh * 0.551784,
                xmin = _x - xmagic,
                xmax = _x + xmagic,
                ymin = _y - ymagic,
                ymax = _y + ymagic;

            context.moveTo(_x, ty);
            context.bezierCurveTo(xmax, ty, rx, ymin, rx, _y);
            context.bezierCurveTo(rx, ymax, xmax, by, _x, by);
            context.bezierCurveTo(xmin, by, lx, ymax, lx, _y);
            context.bezierCurveTo(lx, ymin, xmin, ty, _x, ty);
        } else {
            const _x = mask.pos.x, _y = mask.pos.y;
            var point;

            context.moveTo(_x + mask.points[0].x, _y + mask.points[0].y);
            for (var i = 1; i < mask.points.length; i++) {
                point = mask.points[i];
                context.lineTo(_x + point.x, _y + point.y);
            }
        }

        this.maskLevel++;

        if (invert === true) {
            context.closePath();
            context.globalCompositeOperation = "destination-atop";
            context.fill();
        } else {
            context.clip();
        }
    }

    /**
     * disable (remove) the rendering mask set through setMask.
     * @name clearMask
     * @see CanvasRenderer#setMask
     * @memberof CanvasRenderer
     */
    clearMask() {
        if (this.maskLevel > 0) {
            this.maskLevel = 0;
            this.getContext().restore();
        }
    }
}

/**
 * Create required arrays for the given layer object
 * @ignore
 */
function initArray(layer) {
    // initialize the array
    layer.layerData = new Array(layer.cols);
    for (var x = 0; x < layer.cols; x++) {
        layer.layerData[x] = new Array(layer.rows);
        for (var y = 0; y < layer.rows; y++) {
            layer.layerData[x][y] = null;
        }
    }
}

/**
 * Set a tiled layer Data
 * @ignore
 */
function setLayerData(layer, data) {
    var idx = 0;
    // initialize the data array
    initArray(layer);
    // set everything
    for (var y = 0; y < layer.rows; y++) {
        for (var x = 0; x < layer.cols; x++) {
            // get the value of the gid
            var gid = data[idx++];
            // fill the array
            if (gid !== 0) {
                // add a new tile to the layer
                layer.layerData[x][y] = layer.getTileById(gid, x, y);
            }
        }
    }
}

/**
 * preRender a tile layer using the given renderer
 * @ignore
 */
function preRenderLayer(layer, renderer) {
    // set everything
    for (var y = 0; y < layer.rows; y++) {
        for (var x = 0; x < layer.cols; x++) {
            // get the value of the gid
            var tile = layer.layerData[x][y];
            // draw the tile if defined
            if (tile instanceof Tile) {
                // add a new tile to the layer
                layer.getRenderer().drawTile(renderer, x, y, tile);
            }
        }
    }
}

/**
 * @classdesc
 * a TMX Tile Layer Object
 * Tiled QT 0.7.x format
 * @augments Renderable
 */
class TMXLayer extends Renderable {
    /**
     * @param {object} map layer data in JSON format ({@link http://docs.mapeditor.org/en/stable/reference/tmx-map-format/#layer})
     * @param {object} data layer data in JSON format ({@link http://docs.mapeditor.org/en/stable/reference/tmx-map-format/#layer})
     * @param {number} tilewidth width of each tile in pixels
     * @param {number} tileheight height of each tile in pixels
     * @param {string} orientation "isometric" or "orthogonal"
     * @param {TMXTilesetGroup} tilesets tileset as defined in Tiled
     * @param {number} z z-index position
     */
    constructor(map, data, tilewidth, tileheight, orientation, tilesets, z) {
        // super constructor
        super(0, 0, 0, 0);

        // tile width & height
        this.tilewidth = data.tilewidth || tilewidth;
        this.tileheight = data.tileheight || tileheight;

        // layer orientation
        this.orientation = orientation;

        /**
         * The Layer corresponding Tilesets
         * @public
         * @type {TMXTilesetGroup}
         * @name TMXLayer#tilesets
         */
        this.tilesets = tilesets;

        // the default tileset
        // XXX: Is this even used?
        this.tileset = (this.tilesets ? this.tilesets.getTilesetByIndex(0) : null);

        // Biggest tile size to draw
        this.maxTileSize = {
            "width" : 0,
            "height" : 0
        };
        for (var i = 0; i < this.tilesets.length; i++) {
            var tileset = this.tilesets.getTilesetByIndex(i);
            this.maxTileSize.width = Math.max(this.maxTileSize.width, tileset.tilewidth);
            this.maxTileSize.height = Math.max(this.maxTileSize.height, tileset.tileheight);
        }

        /**
         * All animated tilesets in this layer
         * @ignore
         * @type {TMXTileset[]}
         * @name TMXLayer#animatedTilesets
         */
        this.animatedTilesets = [];

        /**
         * Layer contains tileset animations
         * @public
         * @type {boolean}
         * @name TMXLayer#isAnimated
         */
        this.isAnimated = false;

        /**
         * the order in which tiles on orthogonal tile layers are rendered.
         * (valid values are "left-down", "left-up", "right-down", "right-up")
         * @public
         * @type {string}
         * @default "right-down"
         * @name TMXLayer#renderorder
         */
        this.renderorder = data.renderorder || "right-down";

        // for displaying order
        this.pos.z = z;

        // tiled default coordinates are top-left
        this.anchorPoint.set(0, 0);

        // additional TMX flags
        this.name = data.name;
        this.cols = +data.width;
        this.rows = +data.height;

        // layer opacity
        var visible = typeof(data.visible) !== "undefined" ? +data.visible : 1;
        this.setOpacity(visible ? +data.opacity : 0);

        // layer tint
        if (typeof data.tintcolor === "string") {
            // Tiled provides #RRGGBB or #AARRGGBB
            this.tint.parseHex(data.tintcolor, true);
        }

        // layer "real" size
        if (this.orientation === "isometric") {
            this.width = (this.cols + this.rows) * (this.tilewidth / 2);
            this.height = (this.cols + this.rows) * (this.tileheight / 2);
        } else {
            this.width = this.cols * this.tilewidth;
            this.height = this.rows * this.tileheight;
        }

        // check if we have any user-defined properties
        applyTMXProperties(this, data);

        // check for the correct rendering method
        if (typeof (this.preRender) === "undefined") {
            this.preRender = world.preRender;
        }

        // set a renderer
        this.setRenderer(map.getRenderer());


        // initialize and set the layer data
        setLayerData(this,
            decode(
                data.data,
                data.encoding,
                data.compression
            )
        );
    }


    // called when the layer is added to the game world or a container
    onActivateEvent() {

        if (this.animatedTilesets === undefined) {
            this.animatedTilesets = [];
        }

        if (this.tilesets) {
            var tileset = this.tilesets.tilesets;
            for (var i = 0; i < tileset.length; i++) {
                if (tileset[i].isAnimated) {
                    this.animatedTilesets.push(tileset[i]);
                }
            }
        }

        this.isAnimated = this.animatedTilesets.length > 0;

        // Force pre-render off when tileset animation is used
        if (this.isAnimated) {
            this.preRender = false;
        }

        // Resize the bounding rect
        this.getBounds().addBounds(this.getRenderer().getBounds(), true);
        this.getBounds().shift(this.pos);

        // if pre-rendering method is use, create an offline canvas/renderer
        if ((this.preRender === true) && (!this.canvasRenderer)) {
            this.canvasRenderer = new CanvasRenderer({
                canvas : createCanvas(this.width, this.height),
                widht : this.width,
                heigth : this.height,
                transparent : true
            });
            preRenderLayer(this, this.canvasRenderer);
        }
    }

    // called when the layer is removed from the game world or a container
    onDeactivateEvent() {
        // clear all allocated objects
        //this.layerData = undefined;
        this.animatedTilesets = undefined;
    }

    /**
     * Set the TMX renderer for this layer object
     * @name setRenderer
     * @memberof TMXLayer
     * @public
     * @param {TMXRenderer} renderer
     * @example
     * // use the parent map default renderer
     * var layer = new me.TMXLayer(...);
     * layer.setRenderer(map.getRenderer());
     */
    setRenderer(renderer) {
        this.renderer = renderer;
    }

    /**
     * Return the layer current renderer object
     * @name getRenderer
     * @memberof TMXLayer
     * @public
     * @returns {TMXRenderer} renderer
     */
    getRenderer() {
        return this.renderer;
    }


    /**
     * Return the TileId of the Tile at the specified position
     * @name getTileId
     * @memberof TMXLayer
     * @public
     * @param {number} x X coordinate (in world/pixels coordinates)
     * @param {number} y Y coordinate (in world/pixels coordinates)
     * @returns {number} TileId or null if there is no Tile at the given position
     */
    getTileId(x, y) {
        var tile = this.getTile(x, y);
        return (tile ? tile.tileId : null);
    }

    /**
     * Return the Tile object at the specified position
     * @name getTile
     * @memberof TMXLayer
     * @public
     * @param {number} x X coordinate (in world/pixels coordinates)
     * @param {number} y Y coordinate (in world/pixels coordinates)
     * @returns {Tile} corresponding tile or null if there is no defined tile at the coordinate or if outside of the layer bounds
     * @example
     * // get the TMX Map Layer called "Front layer"
     * var layer = me.game.world.getChildByName("Front Layer")[0];
     * // get the tile object corresponding to the latest pointer position
     * var tile = layer.getTile(me.input.pointer.x, me.input.pointer.y);
     */
    getTile(x, y) {
        var tile = null;

        if (this.contains(x, y)) {
            var coord = this.getRenderer().pixelToTileCoords(x, y, pool.pull("Vector2d"));
            tile = this.cellAt(coord.x, coord.y);
            pool.push(coord);
        }
        return tile;
    }

    /**
     * assign the given Tile object to the specified position
     * @name getTile
     * @memberof TMXLayer
     * @public
     * @param {Tile} tile the tile object to be assigned
     * @param {number} x x coordinate (in world/pixels coordinates)
     * @param {number} y y coordinate (in world/pixels coordinates)
     * @returns {Tile} the tile object
     */
    setTile(tile, x, y) {
        this.layerData[x][y] = tile;
        return tile;
    }

    /**
     * return a new the Tile object corresponding to the given tile id
     * @name setTile
     * @memberof TMXLayer
     * @public
     * @param {number} tileId tileId
     * @param {number} x X coordinate (in world/pixels coordinates)
     * @param {number} y Y coordinate (in world/pixels coordinates)
     * @returns {Tile} the tile object
     */
    getTileById(tileId, x, y) {
        if (!this.tileset.contains(tileId)) {
            // look for the corresponding tileset
            this.tileset = this.tilesets.getTilesetByGid(tileId);
        }
        return new Tile(x, y, tileId, this.tileset);
    }

    /**
     * Return the Tile object at the specified tile coordinates
     * @name cellAt
     * @memberof TMXLayer
     * @public
     * @param {number} x x position of the tile (in Tile unit)
     * @param {number} y x position of the tile (in Tile unit)
     * @param {number} [boundsCheck=true] check first if within the layer bounds
     * @returns {Tile} corresponding tile or null if there is no defined tile at the position or if outside of the layer bounds
     * @example
     * // return the first tile at offset 0, 0
     * var tile = layer.cellAt(0, 0);
     */
    cellAt(x, y, boundsCheck) {
        var _x = ~~x;
        var _y = ~~y;

        var renderer = this.getRenderer();
        // boundsCheck only used internally by the tiled renderer, when the layer bound check was already done
        if (boundsCheck === false || (_x >= 0 && _x < renderer.cols && _y >= 0 && _y < renderer.rows)) {
            return this.layerData[_x][_y];
        } else {
            return null;
        }
    }

    /**
     * clear the tile at the specified position
     * @name clearTile
     * @memberof TMXLayer
     * @public
     * @param {number} x X coordinate (in map coordinates: row/column)
     * @param {number} y Y coordinate (in map coordinates: row/column)
     * @example
     * me.game.world.getChildByType(me.TMXLayer).forEach(function(layer) {
     *     // clear all tiles at the given x,y coordinates
     *     layer.clearTile(x, y);
     * });
     */
    clearTile(x, y) {
        // clearing tile
        this.layerData[x][y] = null;
        // erase the corresponding area in the canvas
        if (this.preRender) {
            this.canvasRenderer.clearRect(x * this.tilewidth, y * this.tileheight, this.tilewidth, this.tileheight);
        }
    }

    /**
     * update animations in a tileset layer
     * @ignore
     */
    update(dt) {
        if (this.isAnimated) {
            var result = false;
            for (var i = 0; i < this.animatedTilesets.length; i++) {
                result = this.animatedTilesets[i].update(dt) || result;
            }
            return result;
        }

        return false;
    }

    /**
     * draw a tileset layer
     * @ignore
     */
    draw(renderer, rect) {
        // use the offscreen canvas
        if (this.preRender) {
            var width = Math.min(rect.width, this.width);
            var height = Math.min(rect.height, this.height);

            // draw using the cached canvas
            renderer.drawImage(
                this.canvasRenderer.getCanvas(),
                rect.pos.x, rect.pos.y, // sx,sy
                width, height,          // sw,sh
                rect.pos.x, rect.pos.y, // dx,dy
                width, height           // dw,dh
            );
        }
        // dynamically render the layer
        else {
            // draw the layer
            this.getRenderer().drawTileLayer(renderer, this, rect);
        }
    }
}

/* eslint-disable no-unused-vars */

/**
 * @classdesc
 * The map renderer base class
 */
class TMXRenderer {
    /**
     * @param {number} cols width of the tilemap in tiles
     * @param {number} rows height of the tilemap in tiles
     * @param {number} tilewidth width of each tile in pixels
     * @param {number} tileheight height of each tile in pixels
     */
    constructor(cols, rows, tilewidth, tileheight) {
        this.cols = cols;
        this.rows = rows;
        this.tilewidth = tilewidth;
        this.tileheight = tileheight;
        this.bounds = new Bounds();
    }

    /**
     * return true if the renderer can render the specified map or layer
     * @name TMXRenderer#canRender
     * @public
     * @param {TMXTileMap|TMXLayer} component TMX Map or Layer
     * @returns {boolean}
     */
    canRender(component) {
        return (
            /*
            // layers can have different size within
            // the same maps, so commenting these two lines
            (this.cols === component.cols) &&
            (this.rows === component.rows) &&
            */
            (this.tilewidth === component.tilewidth) &&
            (this.tileheight === component.tileheight)
        );
    }

    /**
     * return the bounding rect for this map renderer
     * @name TMXRenderer#getBounds
     * @public
     * @param {TMXLayer} [layer] calculate the bounding rect for a specific layer (will return a new bounds object)
     * @returns {Bounds}
     */
    getBounds(layer) {
        var bounds = layer instanceof TMXLayer ? pool.pull("Bounds") : this.bounds;
        bounds.setMinMax(
            0, 0,
            this.cols * this.tilewidth,
            this.rows * this.tileheight
        );
        return bounds;
    }

    /**
     * return the tile position corresponding to the specified pixel
     * @name TMXRenderer#pixelToTileCoords
     * @public
     * @param {number} x X coordinate
     * @param {number} y Y coordinate
     * @param {Vector2d} [v] an optional vector object where to put the return values
     * @returns {Vector2d}
     */
    pixelToTileCoords(x, y, v) {
        return v;
    }

    /**
     * return the pixel position corresponding of the specified tile
     * @name TMXRenderer#tileToPixelCoords
     * @public
     * @param {number} col tile horizontal position
     * @param {number} row tile vertical position
     * @param {Vector2d} [v] an optional vector object where to put the return values
     * @returns {Vector2d}
     */
    tileToPixelCoords(col, row, v) {
        return v;
    }

    /**
     * draw the given tile at the specified layer
     * @name TMXRenderer#drawTile
     * @public
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer object
     * @param {number} x X coordinate where to draw the tile
     * @param {number} y Y coordinate where to draw the tile
     * @param {Tile} tile the tile object to draw
     */
    drawTile(renderer, x, y, tile) {
    }

    /**
     * draw the given TMX Layer for the given area
     * @name TMXRenderer#drawTileLayer
     * @public
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer object
     * @param {TMXLayer} layer a TMX Layer object
     * @param {Rect} rect the area of the layer to draw
     */
    drawTileLayer(renderer, layer, rect) {
    }

}
/* eslint-enable no-unused-vars */

/**
 * @classdesc
 * an Orthogonal Map Renderder
 * @augments TMXRenderer
 */
class TMXOrthogonalRenderer extends TMXRenderer {
    /**
     * @param {TMXTileMap} map the TMX map
     */
    constructor(map) {
        super(
            map.cols,
            map.rows,
            map.tilewidth,
            map.tileheight
        );
    }

    /**
     * return true if the renderer can render the specified layer
     * @ignore
     */
    canRender(layer) {
        return (
            (layer.orientation === "orthogonal") &&
            super.canRender(layer)
        );
    }

    /**
     * return the tile position corresponding to the specified pixel
     * @ignore
     */
    pixelToTileCoords(x, y, v) {
        var ret = v || new Vector2d();
        return ret.set(
            x / this.tilewidth,
            y / this.tileheight
        );
    }


    /**
     * return the pixel position corresponding of the specified tile
     * @ignore
     */
    tileToPixelCoords(x, y, v) {
        var ret = v || new Vector2d();
        return ret.set(
            x * this.tilewidth,
            y * this.tileheight
        );
    }

    /**
     * fix the position of Objects to match
     * the way Tiled places them
     * @ignore
     */
    adjustPosition(obj) {
        // only adjust position if obj.gid is defined
        if (typeof(obj.gid) === "number") {
            // Tiled objects origin point is "bottom-left" in Tiled,
            // "top-left" in melonJS)
            obj.y -= obj.height;
        }
    }

    /**
     * draw the tile map
     * @ignore
     */
    drawTile(renderer, x, y, tmxTile) {
        var tileset = tmxTile.tileset;
        // draw the tile
        tileset.drawTile(
            renderer,
            tileset.tileoffset.x + x * this.tilewidth,
            tileset.tileoffset.y + (y + 1) * this.tileheight - tileset.tileheight,
            tmxTile
        );
    }

    /**
     * draw the tile map
     * @ignore
     */
    drawTileLayer(renderer, layer, rect) {
        var incX = 1, incY = 1;

        // get top-left and bottom-right tile position
        var start = this.pixelToTileCoords(
            Math.max(rect.pos.x - (layer.maxTileSize.width - layer.tilewidth), 0),
            Math.max(rect.pos.y - (layer.maxTileSize.height - layer.tileheight), 0),
            pool.pull("Vector2d")
        ).floorSelf();

        var end = this.pixelToTileCoords(
            rect.pos.x + rect.width + this.tilewidth,
            rect.pos.y + rect.height + this.tileheight,
            pool.pull("Vector2d")
        ).ceilSelf();

        //ensure we are in the valid tile range
        end.x = end.x > this.cols ? this.cols : end.x;
        end.y = end.y > this.rows ? this.rows : end.y;

        switch (layer.renderorder) {
            case "right-up" :
                // swapping start.y and end.y
                end.y = start.y + (start.y = end.y) - end.y;
                incY = -1;
                break;
            case "left-down" :
                // swapping start.x and end.x
                end.x = start.x + (start.x = end.x) - end.x;
                incX = -1;
                break;
            case "left-up" :
                // swapping start.x and end.x
                end.x = start.x + (start.x = end.x) - end.x;
                // swapping start.y and end.y
                end.y = start.y + (start.y = end.y) - end.y;
                incX = -1;
                incY = -1;
                break;
        }

        // main drawing loop
        for (var y = start.y; y !== end.y; y+= incY) {
            for (var x = start.x; x !== end.x; x+= incX) {
                var tmxTile = layer.cellAt(x, y, false);
                if (tmxTile) {
                    this.drawTile(renderer, x, y, tmxTile);
                }
            }
        }

        pool.push(start);
        pool.push(end);
    }
}

/**
 * @classdesc
 * an Isometric Map Renderder
 * @augments TMXRenderer
 */
class TMXIsometricRenderer extends TMXRenderer {
    /**
     * @param {TMXTileMap} map the TMX map
     */
    constructor(map) {
        super(
            map.cols,
            map.rows,
            map.tilewidth,
            map.tileheight
        );

        this.hTilewidth = this.tilewidth / 2;
        this.hTileheight = this.tileheight / 2;
        this.originX = this.rows * this.hTilewidth;
    }

    /**
     * return true if the renderer can render the specified layer
     * @ignore
     */
    canRender(layer) {
        return (
            (layer.orientation === "isometric") &&
            super.canRender(layer)
        );
    }

    /**
     * return the bounding rect for this map renderer
     * @name TMXIsometricRenderer#getBounds
     * @public
     * @param {TMXLayer} [layer] calculate the bounding rect for a specific layer (will return a new bounds object)
     * @returns {Bounds}
     */
    getBounds(layer) {
        var bounds = layer instanceof TMXLayer ? pool.pull("Bounds") : this.bounds;
        bounds.setMinMax(
            0, 0,
            (this.cols + this.rows) * (this.tilewidth / 2),
            (this.cols + this.rows) * (this.tileheight / 2)
        );
        return bounds;
    }

    /**
     * return the tile position corresponding to the specified pixel
     * @ignore
     */
    pixelToTileCoords(x, y, v) {
        var ret = v || new Vector2d();
        return ret.set(
            (y / this.tileheight) + ((x - this.originX) / this.tilewidth),
            (y / this.tileheight) - ((x - this.originX) / this.tilewidth)
        );
    }

    /**
     * return the pixel position corresponding of the specified tile
     * @ignore
     */
    tileToPixelCoords(x, y, v) {
        var ret = v || new Vector2d();
        return ret.set(
            (x - y) * this.hTilewidth + this.originX,
            (x + y) * this.hTileheight
        );
    }

    /**
     * fix the position of Objects to match
     * the way Tiled places them
     * @ignore
     */
    adjustPosition(obj) {
        var tileX = obj.x / this.hTilewidth;
        var tileY = obj.y / this.tileheight;
        var isoPos = pool.pull("Vector2d");

        this.tileToPixelCoords(tileX, tileY, isoPos);

        obj.x = isoPos.x;
        obj.y = isoPos.y;

        pool.push(isoPos);
    }

    /**
     * draw the tile map
     * @ignore
     */
    drawTile(renderer, x, y, tmxTile) {
        var tileset = tmxTile.tileset;
        // draw the tile
        tileset.drawTile(
            renderer,
            ((this.cols - 1) * tileset.tilewidth + (x - y) * tileset.tilewidth >> 1),
            (-tileset.tilewidth + (x + y) * tileset.tileheight >> 2),
            tmxTile
        );
    }

    /**
     * draw the tile map
     * @ignore
     */
    drawTileLayer(renderer, layer, rect) {
        // cache a couple of useful references
        var tileset = layer.tileset;

        // get top-left and bottom-right tile position
        var rowItr = this.pixelToTileCoords(
            rect.pos.x - tileset.tilewidth,
            rect.pos.y - tileset.tileheight,
            pool.pull("Vector2d")
        ).floorSelf();
        var tileEnd = this.pixelToTileCoords(
            rect.pos.x + rect.width + tileset.tilewidth,
            rect.pos.y + rect.height + tileset.tileheight,
            pool.pull("Vector2d")
        ).ceilSelf();

        var rectEnd = this.tileToPixelCoords(tileEnd.x, tileEnd.y, pool.pull("Vector2d"));

        // Determine the tile and pixel coordinates to start at
        var startPos = this.tileToPixelCoords(rowItr.x, rowItr.y, pool.pull("Vector2d"));
        startPos.x -= this.hTilewidth;
        startPos.y += this.tileheight;

        /* Determine in which half of the tile the top-left corner of the area we
         * need to draw is. If we're in the upper half, we need to start one row
         * up due to those tiles being visible as well. How we go up one row
         * depends on whether we're in the left or right half of the tile.
         */
        var inUpperHalf = startPos.y - rect.pos.y > this.hTileheight;
        var inLeftHalf  = rect.pos.x - startPos.x < this.hTilewidth;

        if (inUpperHalf) {
            if (inLeftHalf) {
                rowItr.x--;
                startPos.x -= this.hTilewidth;
            }
            else {
                rowItr.y--;
                startPos.x += this.hTilewidth;
            }
            startPos.y -= this.hTileheight;
        }

        // Determine whether the current row is shifted half a tile to the right
        var shifted = inUpperHalf ^ inLeftHalf;

        // initialize the columItr vector
        var columnItr = rowItr.clone();

        // main drawing loop
        for (var y = startPos.y * 2; y - this.tileheight * 2 < rectEnd.y * 2; y += this.tileheight) {
            columnItr.setV(rowItr);
            for (var x = startPos.x; x < rectEnd.x; x += this.tilewidth) {
                var tmxTile = layer.cellAt(columnItr.x, columnItr.y);
                // render if a valid tile position
                if (tmxTile) {
                    tileset = tmxTile.tileset;
                    // offset could be different per tileset
                    var offset  = tileset.tileoffset;
                    // draw our tile
                    tileset.drawTile(
                        renderer,
                        offset.x + x,
                        offset.y + y / 2 - tileset.tileheight,
                        tmxTile
                    );
                }

                // Advance to the next column
                columnItr.x++;
                columnItr.y--;
            }

            // Advance to the next row
            if (!shifted) {
                rowItr.x++;
                startPos.x += this.hTilewidth;
                shifted = true;
            }
            else {
                rowItr.y++;
                startPos.x -= this.hTilewidth;
                shifted = false;
            }
        }

        pool.push(columnItr);
        pool.push(rowItr);
        pool.push(tileEnd);
        pool.push(rectEnd);
        pool.push(startPos);
    }
}

// scope global var & constants
const offsetsStaggerX = [
    {x:   0, y:   0},
    {x: + 1, y: - 1},
    {x: + 1, y:   0},
    {x: + 2, y:   0}
];
const offsetsStaggerY = [
    {x:   0, y:   0},
    {x: - 1, y: + 1},
    {x:   0, y: + 1},
    {x:   0, y: + 2}
];

/**
 * @classdesc
 * an Hexagonal Map Renderder
 * @augments TMXRenderer
 */
class TMXHexagonalRenderer extends TMXRenderer {
    /**
     * @param {TMXTileMap} map the TMX map
     */
    constructor(map) {
        super(
            map.cols,
            map.rows,
            map.tilewidth & ~1,
            map.tileheight & ~1
        );

        this.hexsidelength = map.hexsidelength || 0;
        this.staggerX = map.staggeraxis === "x";
        this.staggerEven = map.staggerindex === "even";

        this.sidelengthx = 0;
        this.sidelengthy = 0;

        if (map.orientation === "hexagonal") {
            if (this.staggerX) {
                this.sidelengthx = this.hexsidelength;
            }
            else {
                this.sidelengthy = this.hexsidelength;
            }
        }

        this.sideoffsetx = (this.tilewidth - this.sidelengthx) / 2;
        this.sideoffsety = (this.tileheight - this.sidelengthy) / 2;

        this.columnwidth = this.sideoffsetx + this.sidelengthx;
        this.rowheight = this.sideoffsety + this.sidelengthy;

        this.centers = [
            new Vector2d(),
            new Vector2d(),
            new Vector2d(),
            new Vector2d()
        ];
    }

    /**
     * return true if the renderer can render the specified layer
     * @ignore
     */
    canRender(layer) {
        return (
            (layer.orientation === "hexagonal") &&
            super.canRender(layer)
        );
    }

    /**
     * return the bounding rect for this map renderer
     * @name TMXHexagonalRenderer#getBounds
     * @public
     * @param {TMXLayer} [layer] calculate the bounding rect for a specific layer (will return a new bounds object)
     * @returns {Bounds}
     */
    getBounds(layer) {
        var bounds = layer instanceof TMXLayer ? pool.pull("Bounds") : this.bounds;

        // The map size is the same regardless of which indexes are shifted.
        if (this.staggerX) {
            bounds.setMinMax(
                0, 0,
                this.cols * this.columnwidth + this.sideoffsetx,
                this.rows * (this.tileheight + this.sidelengthy)
            );
            if (bounds.width > 1) {
                bounds.height += this.rowheight;
            }
        } else {
            bounds.setMinMax(
                0, 0,
                this.cols * (this.tilewidth + this.sidelengthx),
                this.rows * this.rowheight + this.sideoffsety
            );
            if (bounds.height > 1) {
                bounds.width += this.columnwidth;
            }
        }
        return bounds;
    }

    /**
     * @ignore
     */
    doStaggerX (x) {
        return this.staggerX && (x & 1) ^ this.staggerEven;
    }

    /**
     * @ignore
     */
    doStaggerY(y) {
        return !this.staggerX && (y & 1) ^ this.staggerEven;
    }

    /**
     * @ignore
     */
    topLeft(x, y, v) {
        var ret = v || new Vector2d();

        if (!this.staggerX) {
            if ((y & 1) ^ this.staggerEven) {
                ret.set(x, y - 1);
            }
            else {
                ret.set(x - 1, y - 1);
            }
        } else {
            if ((x & 1) ^ this.staggerEven) {
                ret.set(x - 1, y);
            }
            else {
                ret.set(x - 1, y - 1);
            }
        }
        return ret;
    }

    /**
     * @ignore
     */
    topRight(x, y, v) {
        var ret = v || new Vector2d();

        if (!this.staggerX) {
            if ((y & 1) ^ this.staggerEven) {
                ret.set(x + 1, y - 1);
            }
            else {
                ret.set(x, y - 1);
            }
        } else {
            if ((x & 1) ^ this.staggerEven) {
                ret.set(x + 1, y);
            }
            else {
                ret.set(x + 1, y - 1);
            }
        }
        return ret;
    }


    /**
     * @ignore
     */
    bottomLeft(x, y, v) {
        var ret = v || new Vector2d();

        if (!this.staggerX) {
            if ((y & 1) ^ this.staggerEven) {
                ret.set(x, y + 1);
            }
            else {
                ret.set(x - 1, y + 1);
            }
        } else {
            if ((x & 1) ^ this.staggerEven) {
                ret.set(x -1, y + 1);
            }
            else {
                ret.set(x -1, y);
            }
        }
        return ret;
    }

    /**
     * @ignore
     */
    bottomRight(x, y, v) {
        var ret = v || new Vector2d();

        if (!this.staggerX) {
            if ((y & 1) ^ this.staggerEven) {
                ret.set(x + 1, y + 1);
            }
            else {
                ret.set(x, y + 1);
            }
        } else {
            if ((x & 1) ^ this.staggerEven) {
                ret.set(x + 1, y + 1);
            }
            else {
                ret.set(x + 1, y);
            }
        }
        return ret;
    }

    /**
     * return the tile position corresponding to the specified pixel
     * @ignore
     */
    pixelToTileCoords(x, y, v) {
        var ret = v || new Vector2d();

        if (this.staggerX) { //flat top
            x -= this.staggerEven ? this.tilewidth : this.sideoffsetx;
        }
        else { //pointy top
            y -= this.staggerEven ? this.tileheight : this.sideoffsety;
        }

        // Start with the coordinates of a grid-aligned tile
        var referencePoint = pool.pull("Vector2d",
            Math.floor(x / (this.columnwidth * 2)),
            Math.floor((y / (this.rowheight * 2)))
        );

        // Relative x and y position on the base square of the grid-aligned tile
        var rel = pool.pull("Vector2d",
            x - referencePoint.x * (this.columnwidth * 2),
            y - referencePoint.y * (this.rowheight * 2)
        );

        // Adjust the reference point to the correct tile coordinates
        if (this.staggerX) {
            referencePoint.x = referencePoint.x * 2;
            if (this.staggerEven) {
                ++referencePoint.x;
            }
        }
        else {
            referencePoint.y = referencePoint.y * 2;
            if (this.staggerEven) {
                ++referencePoint.y;
            }
        }

        // Determine the nearest hexagon tile by the distance to the center
        var left, top, centerX, centerY;
        if (this.staggerX) {
            left = this.sidelengthx / 2;
            centerX = left + this.columnwidth;
            centerY = this.tileheight / 2;

            this.centers[0].set(left, centerY);
            this.centers[1].set(centerX, centerY - this.rowheight);
            this.centers[2].set(centerX, centerY + this.rowheight);
            this.centers[3].set(centerX + this.columnwidth, centerY);
        }
        else {
            top = this.sidelengthy / 2;
            centerX = this.tilewidth / 2;
            centerY = top + this.rowheight;

            this.centers[0].set(centerX, top);
            this.centers[1].set(centerX - this.columnwidth, centerY);
            this.centers[2].set(centerX + this.columnwidth, centerY);
            this.centers[3].set(centerX, centerY + this.rowheight);
        }

        var nearest = 0;
        var minDist = Number.MAX_VALUE;
        for (var i = 0; i < 4; ++i) {
            var dc = this.centers[i].sub(rel).length2();
            if (dc < minDist) {
                minDist = dc;
                nearest = i;
            }
        }

        var offsets = (this.staggerX) ? offsetsStaggerX : offsetsStaggerY;

        ret.set(
            referencePoint.x + offsets[nearest].x,
            referencePoint.y + offsets[nearest].y
        );

        pool.push(referencePoint);
        pool.push(rel);

        return ret;
    }

    /**
     * return the pixel position corresponding of the specified tile
     * @ignore
     */
    tileToPixelCoords(x, y, v) {
        var tileX = Math.floor(x),
            tileY = Math.floor(y);
        var ret = v || new Vector2d();

        if (this.staggerX) {
            ret.y = tileY * (this.tileheight + this.sidelengthy);
            if (this.doStaggerX(tileX)) {
                ret.y += this.rowheight;
            }
            ret.x = tileX * this.columnwidth;
        } else {
            ret.x = tileX * (this.tilewidth + this.sidelengthx);
            if (this.doStaggerY(tileY)) {
                ret.x += this.columnwidth;
            }
            ret.y = tileY * this.rowheight;
        }

        return ret;
    }

    /**
     * fix the position of Objects to match
     * the way Tiled places them
     * @ignore
     */
    adjustPosition(obj) {
        // only adjust position if obj.gid is defined
        if (typeof(obj.gid) === "number") {
            // Tiled objects origin point is "bottom-left" in Tiled,
            // "top-left" in melonJS)
            obj.y -= obj.height;
        }
    }

    /**
     * draw the tile map
     * @ignore
     */
    drawTile(renderer, x, y, tmxTile) {
        var tileset = tmxTile.tileset;
        var point = this.tileToPixelCoords(x, y, pool.pull("Vector2d"));

        // draw the tile
        tileset.drawTile(
            renderer,
            tileset.tileoffset.x + point.x,
            tileset.tileoffset.y + point.y + (this.tileheight - tileset.tileheight),
            tmxTile
        );

        pool.push(point);
    }

    /**
     * draw the tile map
     * @ignore
     */
    drawTileLayer(renderer, layer, rect) {
        var tile;

        // get top-left and bottom-right tile position
        var startTile = this.pixelToTileCoords(
            rect.pos.x,
            rect.pos.y,
            pool.pull("Vector2d")
        );

        // Compensate for the layer position
        startTile.sub(layer.pos);

        // get top-left and bottom-right tile position
        var startPos = this.tileToPixelCoords(
            startTile.x + layer.pos.x,
            startTile.y + layer.pos.y,
            pool.pull("Vector2d")
        );

        var rowTile = startTile.clone();
        var rowPos = startPos.clone();

       /* Determine in which half of the tile the top-left corner of the area we
        * need to draw is. If we're in the upper half, we need to start one row
        * up due to those tiles being visible as well. How we go up one row
        * depends on whether we're in the left or right half of the tile.
        */
        var inUpperHalf = rect.pos.y - startPos.y < this.sideoffsety;
        var inLeftHalf = rect.pos.x - startPos.x < this.sideoffsetx;

        if (inUpperHalf) {
            startTile.y--;
        }
        if (inLeftHalf) {
            startTile.x--;
        }

        var endX = layer.cols;
        var endY = layer.rows;

        if (this.staggerX) {
            //ensure we are in the valid tile range
            startTile.x = Math.max(0, startTile.x);
            startTile.y = Math.max(0, startTile.y);

            startPos = this.tileToPixelCoords(
                startTile.x + layer.pos.x,
                startTile.y + layer.pos.y
            );

            var staggeredRow = this.doStaggerX(startTile.x + layer.pos.x);

            // main drawing loop
            for (; startPos.y < rect.bottom && startTile.y < endY; ) {
                rowTile.setV(startTile);
                rowPos.setV(startPos);

                for (; rowPos.x < rect.right && rowTile.x < endX; rowTile.x+=2) {
                    tile = layer.cellAt(rowTile.x, rowTile.y, false);
                    if (tile) {
                        // draw the tile
                        tile.tileset.drawTile(renderer, rowPos.x, rowPos.y, tile);
                    }
                    rowPos.x += this.tilewidth + this.sidelengthx;
                }

                if (staggeredRow) {
                    startTile.x -= 1;
                    startTile.y += 1;
                    startPos.x -= this.columnwidth;
                    staggeredRow = false;
                } else {
                    startTile.x += 1;
                    startPos.x += this.columnwidth;
                    staggeredRow = true;
                }

                startPos.y += this.rowheight;
            }
            pool.push(rowTile);
            pool.push(rowPos);

        } else {
            //ensure we are in the valid tile range
            startTile.x = Math.max(0, startTile.x);
            startTile.y = Math.max(0, startTile.y);

            startPos = this.tileToPixelCoords(
                startTile.x + layer.pos.x,
                startTile.y + layer.pos.y
            );

            // Odd row shifting is applied in the rendering loop, so un-apply it here
            if (this.doStaggerY(startTile.y)) {
                startPos.x -= this.columnwidth;
            }

            // main drawing loop
            for (; startPos.y < rect.bottom && startTile.y < endY; startTile.y++) {
                rowTile.setV(startTile);
                rowPos.setV(startPos);

                if (this.doStaggerY(startTile.y)) {
                    rowPos.x += this.columnwidth;
                }

                for (; rowPos.x < rect.right && rowTile.x < endX; rowTile.x++) {
                    tile = layer.cellAt(rowTile.x, rowTile.y, false);
                    if (tile) {
                        // draw the tile
                        tile.tileset.drawTile(renderer, rowPos.x, rowPos.y, tile);
                    }
                    rowPos.x += this.tilewidth + this.sidelengthx;
                }
                startPos.y += this.rowheight;
            }
            pool.push(rowTile);
            pool.push(rowPos);
        }

        pool.push(startTile);
        pool.push(startPos);
    }
}

/**
 * @classdesc
 * a Staggered Map Renderder
 * @augments TMXHexagonalRenderer
 */
class TMXStaggeredRenderer extends TMXHexagonalRenderer {

    /**
     * return true if the renderer can render the specified layer
     * @ignore
     */
    canRender(layer) {
        return (
            (layer.orientation === "staggered") &&
            super.canRender(layer)
        );
    }

    /**
     * return the tile position corresponding to the specified pixel
     * @ignore
     */
    pixelToTileCoords(x, y, v) {
        var ret = v || new Vector2d();

        var alignedX = x,
            alignedY = y;

        if (this.staggerX) {
            alignedX -= this.staggerEven ? this.sideoffsetx : 0;
        } else {
            alignedY -= this.staggerEven ? this.sideoffsety : 0;
        }

        // Start with the coordinates of a grid-aligned tile
        var referencePoint = pool.pull("Vector2d",
            Math.floor(alignedX / this.tilewidth),
            Math.floor(alignedY / this.tileheight)
        );

        // Adjust the reference point to the correct tile coordinates
        if (this.staggerX) {
            referencePoint.x = referencePoint.x * 2;
            if (this.staggerEven) {
                ++referencePoint.x;
            }
        } else {
            referencePoint.y = referencePoint.y * 2;
            if (this.staggerEven) {
                ++referencePoint.y;
            }
        }

        // Relative x and y position on the base square of the grid-aligned tile
        var rel = pool.pull("Vector2d",
            alignedX - referencePoint.x * this.tilewidth,
            alignedY - referencePoint.y * this.tileheight
        );

        // Check whether the cursor is in any of the corners (neighboring tiles)
        var y_pos = rel.x * (this.tileheight / this.tilewidth);

        if (this.sideoffsety - y_pos > rel.y) {
            referencePoint = this.topLeft(referencePoint.x, referencePoint.y, referencePoint);
        }
        if (-this.sideoffsety + y_pos > rel.y) {
            referencePoint = this.topRight(referencePoint.x, referencePoint.y, referencePoint);
        }
        if (this.sideoffsety + y_pos < rel.y) {
            referencePoint = this.bottomLeft(referencePoint.x, referencePoint.y, referencePoint);
        }
        if (this.sideoffsety * 3 - y_pos < rel.y) {
            referencePoint = this.bottomRight(referencePoint.x, referencePoint.y, referencePoint);
        }

        ret = this.tileToPixelCoords(referencePoint.x, referencePoint.y, ret);

        ret.set(x - ret.x, y - ret.y);

        // Start with the coordinates of a grid-aligned tile
        ret.set(
            ret.x - (this.tilewidth / 2),
            ret.y * (this.tilewidth / this.tileheight)
        );

        ret.div(this.tilewidth / Math.sqrt(2)).rotate(degToRad(-45)).add(referencePoint);

        pool.push(referencePoint);
        pool.push(rel);

        return ret;
    }
}

/**
 * @classdesc
 * a TMX Tile Set Object
 */
class TMXTileset {
    /**
     *  @param {object} tileset tileset data in JSON format ({@link http://docs.mapeditor.org/en/stable/reference/tmx-map-format/#tileset})
     */
    constructor(tileset) {
        var i = 0;
        // first gid

        // tile properties (collidable, etc..)
        this.TileProperties = [];

        // hold reference to each tile image
        this.imageCollection = [];

        this.firstgid = this.lastgid = +tileset.firstgid;

        // check if an external tileset is defined
        if (typeof(tileset.source) !== "undefined") {
            var src = tileset.source;
            var ext = getExtension(src);
            if (ext === "tsx" || ext === "json") {
                // load the external tileset (TSX/JSON)
                tileset = loader.getTMX(getBasename(src));
                if (!tileset) {
                    throw new Error(src + " external TSX/JSON tileset not found");
                }
            }
        }

        this.name = tileset.name;
        this.tilewidth = +tileset.tilewidth;
        this.tileheight = +tileset.tileheight;
        this.spacing = +tileset.spacing || 0;
        this.margin = +tileset.margin || 0;

        // set tile offset properties (if any)
        this.tileoffset = new Vector2d();

        /**
         * Tileset contains animated tiles
         * @public
         * @type {boolean}
         * @name TMXTileset#isAnimated
         */
        this.isAnimated = false;

        /**
         * true if the tileset is a "Collection of Image" Tileset
         * @public
         * @type {boolean}
         * @name TMXTileset#isCollection
         */
        this.isCollection = false;

        /**
         * Tileset animations
         * @private
         */
        this.animations = new Map();

        /**
         * Remember the last update timestamp to prevent too many animation updates
         * @private
         */
        this._lastUpdate = 0;

        var tiles = tileset.tiles;
        for (i in tiles) {
            if (tiles.hasOwnProperty(i)) {
                if ("animation" in tiles[i]) {
                    this.isAnimated = true;
                    this.animations.set(tiles[+i].animation[0].tileid, {
                        dt      : 0,
                        idx     : 0,
                        frames  : tiles[+i].animation,
                        cur     : tiles[+i].animation[0]
                    });
                }
                // set tile properties, if any
                if ("properties" in tiles[i]) {
                    if (Array.isArray(tiles[i].properties)) { // JSON (new format)
                        var tileProperty = {};
                        for (var j in tiles[i].properties) {
                            tileProperty[tiles[i].properties[j].name] = tiles[i].properties[j].value;
                        }
                        this.setTileProperty(+tiles[i].id + this.firstgid, tileProperty);
                    } else { // XML format
                        this.setTileProperty(+i + this.firstgid, tiles[i].properties);
                    }
                }
                if ("image" in tiles[i]) {
                    var image = loader.getImage(tiles[i].image);
                    if (!image) {
                        throw new Error("melonJS: '" + tiles[i].image + "' file for tile '" + (+i + this.firstgid) + "' not found!");
                    }
                    this.imageCollection[+i + this.firstgid] = image;
                }
            }
        }

        this.isCollection = this.imageCollection.length > 0;

        var offset = tileset.tileoffset;
        if (offset) {
            this.tileoffset.x = +offset.x;
            this.tileoffset.y = +offset.y;
        }

        // set tile properties, if any (JSON old format)
        var tileInfo = tileset.tileproperties;
        if (tileInfo) {
            for (i in tileInfo) {
                if (tileInfo.hasOwnProperty(i)) {
                    this.setTileProperty(+i + this.firstgid, tileInfo[i]);
                }
            }
        }

        // if not a tile image collection
        if (this.isCollection === false) {

            // get the global tileset texture
            this.image = loader.getImage(tileset.image);

            if (!this.image) {
                throw new Error("melonJS: '" + tileset.image + "' file for tileset '" + this.name + "' not found!");
            }

            // create a texture atlas for the given tileset
            this.texture = renderer.cache.get(this.image, {
                framewidth : this.tilewidth,
                frameheight : this.tileheight,
                margin : this.margin,
                spacing : this.spacing
            });
            this.atlas = this.texture.getAtlas();

            // calculate the number of tiles per horizontal line
            var hTileCount = +tileset.columns || Math.round(this.image.width / (this.tilewidth + this.spacing));
            var vTileCount = Math.round(this.image.height / (this.tileheight + this.spacing));
            if (tileset.tilecount % hTileCount > 0) {
                ++vTileCount;
            }
            // compute the last gid value in the tileset
            this.lastgid = this.firstgid + (((hTileCount * vTileCount) - 1) || 0);
            if (tileset.tilecount && this.lastgid - this.firstgid + 1 !== +tileset.tilecount) {
                console.warn(
                    "Computed tilecount (" + (this.lastgid - this.firstgid + 1) +
                    ") does not match expected tilecount (" + tileset.tilecount + ")"
                );
            }
        }
    }

    /**
     * return the tile image from a "Collection of Image" tileset
     * @name TMXTileset#getTileImage
     * @public
     * @param {number} gid
     * @returns {Image} corresponding image or undefined
     */
    getTileImage(gid) {
        return this.imageCollection[gid];
    }


    /**
     * set the tile properties
     * @ignore
     */
    setTileProperty(gid, prop) {
        // set the given tile id
        this.TileProperties[gid] = prop;
    }

    /**
     * return true if the gid belongs to the tileset
     * @name TMXTileset#contains
     * @public
     * @param {number} gid
     * @returns {boolean}
     */
    contains(gid) {
        return gid >= this.firstgid && gid <= this.lastgid;
    }

    /**
     * Get the view (local) tile ID from a GID, with animations applied
     * @name TMXTileset#getViewTileId
     * @public
     * @param {number} gid Global tile ID
     * @returns {number} View tile ID
     */
    getViewTileId(gid) {
        var localId = gid - this.firstgid;

        if (this.animations.has(localId)) {
            // return the current corresponding tile id if animated
            return this.animations.get(localId).cur.tileid;
        }

        return localId;
    }

    /**
     * return the properties of the specified tile
     * @name TMXTileset#getTileProperties
     * @public
     * @param {number} tileId
     * @returns {object}
     */
    getTileProperties(tileId) {
        return this.TileProperties[tileId];
    }

    // update tile animations
    update(dt) {
        var duration = 0,
            now = timer.getTime(),
            result = false;

        if (this._lastUpdate !== now) {
            this._lastUpdate = now;

            this.animations.forEach(function (anim) {
                anim.dt += dt;
                duration = anim.cur.duration;
                while (anim.dt >= duration) {
                    anim.dt -= duration;
                    anim.idx = (anim.idx + 1) % anim.frames.length;
                    anim.cur = anim.frames[anim.idx];
                    duration = anim.cur.duration;
                    result = true;
                }
            });
        }

        return result;
    }

    // draw the x,y tile
    drawTile(renderer, dx, dy, tmxTile) {

        // check if any transformation is required
        if (tmxTile.flipped) {
            renderer.save();
            // apply the tile current transform
            renderer.translate(dx, dy);
            renderer.transform(tmxTile.currentTransform);
            // reset both values as managed through transform();
            dx = dy = 0;
        }

        // check if the tile has an associated image
        if (this.isCollection === true) {
            // draw the tile
            renderer.drawImage(
                this.imageCollection[tmxTile.tileId],
                0, 0,
                tmxTile.width, tmxTile.height,
                dx, dy,
                tmxTile.width, tmxTile.height
            );
        } else {
            // use the tileset texture
            var offset = this.atlas[this.getViewTileId(tmxTile.tileId)].offset;
            // draw the tile
            renderer.drawImage(
                this.image,
                offset.x, offset.y,
                this.tilewidth, this.tileheight,
                dx, dy,
                this.tilewidth + renderer.uvOffset, this.tileheight + renderer.uvOffset
            );
        }

        if (tmxTile.flipped) {
            // restore the context to the previous state
            renderer.restore();
        }
    }
}

// bitmask constants to check for flipped & rotated tiles
const TMX_CLEAR_BIT_MASK = ~(0x80000000 | 0x40000000 | 0x20000000);

/**
 * @classdesc
 * an object containing all tileset
 */
class TMXTilesetGroup {

    constructor() {
        this.tilesets = [];
        this.length = 0;
    }

    /**
     * add a tileset to the tileset group
     * @name TMXTilesetGroup#add
     * @public
     * @param {TMXTileset} tileset
     */
    add(tileset) {
        this.tilesets.push(tileset);
        this.length++;
    }

    /**
     * return the tileset at the specified index
     * @name TMXTilesetGroup#getTilesetByIndex
     * @public
     * @param {number} i
     * @returns {TMXTileset} corresponding tileset
     */
    getTilesetByIndex(i) {
        return this.tilesets[i];
    }

    /**
     * return the tileset corresponding to the specified id <br>
     * will throw an exception if no matching tileset is found
     * @name TMXTilesetGroup#getTilesetByGid
     * @public
     * @param {number} gid
     * @returns {TMXTileset} corresponding tileset
     */
    getTilesetByGid(gid) {
        var invalidRange = -1;

        // clear the gid of all flip/rotation flags
        gid &= TMX_CLEAR_BIT_MASK;

        // cycle through all tilesets
        for (var i = 0, len = this.tilesets.length; i < len; i++) {
            // return the corresponding tileset if matching
            if (this.tilesets[i].contains(gid)) {
                return this.tilesets[i];
            }
            // typically indicates a layer with no asset loaded (collision?)
            if (this.tilesets[i].firstgid === this.tilesets[i].lastgid &&
                gid >= this.tilesets[i].firstgid) {
                // store the id if the [firstgid .. lastgid] is invalid
                invalidRange = i;
            }
        }
        // return the tileset with the invalid range
        if (invalidRange !== -1) {
            return this.tilesets[invalidRange];
        }
        else {
            throw new Error("no matching tileset found for gid " + gid);
        }
    }
}

/**
 * @classdesc
 * a TMX Object defintion, as defined in Tiled
 * (Object definition is translated into the virtual `me.game.world` using `me.Renderable`)
 * @ignore
 */
class TMXObject {

    constructor(map, settings, z) {

        /**
         * point list in JSON format
         * @public
         * @type {object[]}
         * @name points
         * @memberof TMXObject
         */
        this.points = undefined;

        /**
         * object name
         * @public
         * @type {string}
         * @name name
         * @memberof TMXObject
         */
        this.name = settings.name;

        /**
         * object x position
         * @public
         * @type {number}
         * @name x
         * @memberof TMXObject
         */
        this.x = +settings.x;

        /**
         * object y position
         * @public
         * @type {number}
         * @name y
         * @memberof TMXObject
         */
        this.y = +settings.y;

        /**
         * object z order
         * @public
         * @type {number}
         * @name z
         * @memberof TMXObject
         */
        this.z = +z;

        /**
         * object width
         * @public
         * @type {number}
         * @name width
         * @memberof TMXObject
         */
        this.width = +settings.width || 0;

        /**
         * object height
         * @public
         * @type {number}
         * @name height
         * @memberof TMXObject
         */
        this.height = +settings.height || 0;

        /**
         * object gid value
         * when defined the object is a tiled object
         * @public
         * @type {number}
         * @name gid
         * @memberof TMXObject
         */
        this.gid = +settings.gid || null;

        /**
         * tint color
         * @public
         * @type {string}
         * @name tintcolor
         * @memberof TMXObject
         */
        this.tintcolor = settings.tintcolor;

        /**
         * object type
         * @public
         * @type {string}
         * @name type
         * @memberof TMXObject
         */
        this.type = settings.type;

        /**
         * object text
         * @public
         * @type {object}
         * @see http://docs.mapeditor.org/en/stable/reference/tmx-map-format/#text
         * @name type
         * @memberof TMXObject
         */
        this.type = settings.type;

        /**
         * The rotation of the object in radians clockwise (defaults to 0)
         * @public
         * @type {number}
         * @name rotation
         * @memberof TMXObject
         */
        this.rotation = degToRad(+settings.rotation || 0);

        /**
         * object unique identifier per level (Tiled 0.11.x+)
         * @public
         * @type {number}
         * @name id
         * @memberof TMXObject
         */
        this.id = +settings.id || undefined;

        /**
         * object orientation (orthogonal or isometric)
         * @public
         * @type {string}
         * @name orientation
         * @memberof TMXObject
         */
        this.orientation = map.orientation;

        /**
         * the collision shapes defined for this object
         * @public
         * @type {object[]}
         * @name shapes
         * @memberof TMXObject
         */
        this.shapes = undefined;

        /**
         * if true, the object is an Ellipse
         * @public
         * @type {boolean}
         * @name isEllipse
         * @memberof TMXObject
         */
        this.isEllipse = false;

        /**
         * if true, the object is a Polygon
         * @public
         * @type {boolean}
         * @name isPolygon
         * @memberof TMXObject
         */
        this.isPolygon = false;

        /**
         * if true, the object is a PolyLine
         * @public
         * @type {boolean}
         * @name isPolyLine
         * @memberof TMXObject
         */
        this.isPolyLine = false;

        // check if the object has an associated gid
        if (typeof this.gid === "number") {
            this.setTile(map.tilesets);
        }
        else {
            if (typeof(settings.ellipse) !== "undefined") {
                this.isEllipse = true;
            } else if (typeof(settings.polygon) !== "undefined") {
                this.points = settings.polygon;
                this.isPolygon = true;
            } else if (typeof(settings.polyline) !== "undefined") {
                this.points = settings.polyline;
                this.isPolyLine = true;
            }
        }

        // check for text information
        if (typeof settings.text !== "undefined") {
            // a text object
            this.text = settings.text;
            // normalize field name and default value the melonjs way
            this.text.font = settings.text.fontfamily || "sans-serif";
            this.text.size = settings.text.pixelsize || 16;
            this.text.fillStyle = settings.text.color || "#000000";
            this.text.textAlign = settings.text.halign || "left";
            this.text.textBaseline = settings.text.valign || "top";
            this.text.width = this.width;
            this.text.height = this.height;
            // set the object properties
            applyTMXProperties(this.text, settings);
        } else {
            // set the object properties
            applyTMXProperties(this, settings);
            // a standard object
            if (!this.shapes) {
                // else define the object shapes if required
                this.shapes = this.parseTMXShapes();
            }
        }

        // Adjust the Position to match Tiled
        if (!map.isEditor) {
            map.getRenderer().adjustPosition(this);
        }
    }

    /**
     * set the object image (for Tiled Object)
     * @ignore
     */
    setTile(tilesets) {
        // get the corresponding tileset
        var tileset = tilesets.getTilesetByGid(this.gid);

        if (tileset.isCollection === false) {
            // set width and height equal to tile size
            this.width = this.framewidth = tileset.tilewidth;
            this.height = this.frameheight = tileset.tileheight;
        }

        // the object corresponding tile object
        this.tile = new Tile(this.x, this.y, this.gid, tileset);
    }

    /**
     * parses the TMX shape definition and returns a corresponding array of me.Shape object
     * @name parseTMXShapes
     * @memberof TMXObject
     * @private
     * @returns {Polygon[]|Line[]|Ellipse[]} an array of shape objects
     */
    parseTMXShapes() {
        var i = 0;
        var shapes = [];

        // add an ellipse shape
        if (this.isEllipse === true) {
            // ellipse coordinates are the center position, so set default to the corresonding radius
            shapes.push((pool.pull("Ellipse",
                this.width / 2,
                this.height / 2,
                this.width,
                this.height
            )).rotate(this.rotation));
        } else {

            // add a polygon
            if (this.isPolygon === true) {
                var _polygon = pool.pull("Polygon", 0, 0, this.points);
                // make sure it's a convex polygon
                if (_polygon.isConvex() === false ) {
                    throw new Error("collision polygones in Tiled should be defined as Convex");
                }
                shapes.push(_polygon.rotate(this.rotation));
            }

            // add a polyline
            else if (this.isPolyLine === true) {
                var p = this.points;
                var p1, p2;
                var segments = p.length - 1;
                for (i = 0; i < segments; i++) {
                    // clone the value before, as [i + 1]
                    // is reused later by the next segment
                    p1 = pool.pull("Vector2d", p[i].x, p[i].y);
                    p2 = pool.pull("Vector2d", p[i + 1].x, p[i + 1].y);
                    if (this.rotation !== 0) {
                        p1 = p1.rotate(this.rotation);
                        p2 = p2.rotate(this.rotation);
                    }
                    shapes.push(pool.pull("Line", 0, 0, [ p1, p2 ]));
                }
            }

            // it's a rectangle, returns a polygon object anyway
            else {
                shapes.push((pool.pull("Polygon",
                    0, 0, [
                        pool.pull("Vector2d"),  pool.pull("Vector2d", this.width, 0),
                        pool.pull("Vector2d", this.width, this.height), pool.pull("Vector2d", 0, this.height)
                    ]
                )).rotate(this.rotation));
            }

        }

        // Apply isometric projection
        if (this.orientation === "isometric") {
            for (i = 0; i < shapes.length; i++) {
                shapes[i].toIso();
            }
        }

        return shapes;
    }

    /**
     * getObjectPropertyByName
     * @ignore
     */
    getObjectPropertyByName(name) {
        return this[name];
    }
}

/**
 * @classdesc
 * object group definition as defined in Tiled.
 * (group definition is translated into the virtual `me.game.world` using `me.Container`)
 * @ignore
 */
class TMXGroup {

    constructor(map, data, z) {

        /**
         * group name
         * @public
         * @type {string}
         * @name name
         * @memberof TMXGroup
         */
        this.name = data.name;

        /**
         * group width
         * @public
         * @type {number}
         * @name width
         * @memberof TMXGroup
         */
        this.width = data.width || 0;

        /**
         * group height
         * @public
         * @type {number}
         * @name height
         * @memberof TMXGroup
         */
        this.height = data.height || 0;

        /**
         * tint color
         * @public
         * @type {string}
         * @name tintcolor
         * @memberof TMXGroup
         */
        this.tintcolor = data.tintcolor;

        /**
         * group z order
         * @public
         * @type {number}
         * @name z
         * @memberof TMXGroup
         */
        this.z = z;

        /**
         * group objects list definition
         * @see TMXObject
         * @public
         * @type {object[]}
         * @name name
         * @memberof TMXGroup
         */
        this.objects = [];

        var visible = typeof(data.visible) !== "undefined" ? data.visible : true;
        this.opacity = (visible === true) ? clamp(+data.opacity || 1.0, 0.0, 1.0) : 0;

        // check if we have any user-defined properties
        applyTMXProperties(this, data);

        // parse all child objects/layers
        if (data.objects) {
            data.objects.forEach((object) => {
                object.tintcolor = this.tintcolor;
                this.objects.push(new TMXObject(map, object, z));
            });
        }

        if (data.layers) {
            data.layers.forEach((data) => {
                var layer = new TMXLayer(map, data, map.tilewidth, map.tileheight, map.orientation, map.tilesets, z++);
                // set a renderer
                layer.setRenderer(map.getRenderer());
                // resize container accordingly
                this.width = Math.max(this.width, layer.width);
                this.height = Math.max(this.height, layer.height);
                this.objects.push(layer);
            });
        }
    }

    /**
     * reset function
     * @ignore
     */
    destroy() {
        // clear all allocated objects
        this.objects = null;
    }

    /**
     * return the object count
     * @ignore
     */
    getObjectCount() {
        return this.objects.length;
    }

    /**
     * returns the object at the specified index
     * @ignore
     */
    getObjectByIndex(idx) {
        return this.objects[idx];
    }
}

// constant to identify the collision object layer
const COLLISION_GROUP = "collision";

/**
 * set a compatible renderer object
 * for the specified map
 * @ignore
 */
function getNewDefaultRenderer(map) {
    switch (map.orientation) {
        case "orthogonal":
            return new TMXOrthogonalRenderer(map);

        case "isometric":
            return new TMXIsometricRenderer(map);

        case "hexagonal":
            return new TMXHexagonalRenderer(map);

        case "staggered":
            return new TMXStaggeredRenderer(map);

        // if none found, throw an exception
        default:
            throw new Error(map.orientation + " type TMX Tile Map not supported!");
    }
}

/**
 * read the layer Data
 * @ignore
 */
function readLayer(map, data, z) {
    return new TMXLayer(map, data, map.tilewidth, map.tileheight, map.orientation, map.tilesets, z);
}

/**
 * read the Image Layer Data
 * @ignore
 */
function readImageLayer(map, data, z) {
    // Normalize properties
    applyTMXProperties(data.properties, data);

    // create the layer
    var imageLayer = pool.pull("ImageLayer",
        // x/y is deprecated since 0.15 and replace by offsetx/y
        +data.offsetx || +data.x || 0,
        +data.offsety || +data.y || 0,
        Object.assign({
            name: data.name,
            image: data.image,
            ratio : pool.pull("Vector2d", +data.parallaxx || 1.0, +data.parallaxy || 1.0),
            // convert to melonJS color format (note: this should be done earlier when parsing data)
            tint : typeof (data.tintcolor) !== "undefined" ? (pool.pull("Color")).parseHex(data.tintcolor, true) : undefined,
            z: z
        }, data.properties)
    );


    // set some additional flags
    var visible = typeof(data.visible) !== "undefined" ? data.visible : true;
    imageLayer.setOpacity(visible ? +data.opacity : 0);

    return imageLayer;
}

/**
 * read the tileset Data
 * @ignore
 */
function readTileset(data) {
    return (new TMXTileset(data));
}

/**
 * read the object group Data
 * @ignore
 */
function readObjectGroup(map, data, z) {
    return (new TMXGroup(map, data, z));
}

/**
 * @classdesc
 * a TMX Tile Map Object
 * Tiled QT +0.7.x format
 */
class TMXTileMap {
    /**
     * @param {string} levelId name of TMX map
     * @param {object} data TMX map in JSON format
     * @example
     * // create a new level object based on the TMX JSON object
     * var level = new me.TMXTileMap(levelId, me.loader.getTMX(levelId));
     * // add the level to the game world container
     * level.addTo(me.game.world, true);
     */
    constructor(levelId, data) {

        /**
         * the level data (JSON)
         * @ignore
         */
        this.data = data;

        /**
         * name of the tilemap
         * @public
         * @type {string}
         * @name TMXTileMap#name
         */
        this.name = levelId;

        /**
         * width of the tilemap in tiles
         * @public
         * @type {number}
         * @name TMXTileMap#cols
         */
        this.cols = +data.width;
        /**
         * height of the tilemap in tiles
         * @public
         * @type {number}
         * @name TMXTileMap#rows
         */
        this.rows = +data.height;

        /**
         * Tile width
         * @public
         * @type {number}
         * @name TMXTileMap#tilewidth
         */
        this.tilewidth = +data.tilewidth;

        /**
         * Tile height
         * @public
         * @type {number}
         * @name TMXTileMap#tileheight
         */
        this.tileheight = +data.tileheight;

        /**
         * is the map an infinite map
         * @public
         * @type {number}
         * @default 0
         * @name TMXTileMap#infinite
         */
        this.infinite = +data.infinite;

        /**
         * the map orientation type. melonJS supports âorthogonalâ, âisometricâ, âstaggeredâ and âhexagonalâ.
         * @public
         * @type {string}
         * @default "orthogonal"
         * @name TMXTileMap#orientation
         */
        this.orientation = data.orientation;

        /**
         * the order in which tiles on orthogonal tile layers are rendered.
         * (valid values are "left-down", "left-up", "right-down", "right-up")
         * @public
         * @type {string}
         * @default "right-down"
         * @name TMXTileMap#renderorder
         */
        this.renderorder = data.renderorder || "right-down";

        /**
         * the TMX format version
         * @public
         * @type {string}
         * @name TMXTileMap#version
         */
        this.version = data.version;

        /**
         * The Tiled version used to save the file (since Tiled 1.0.1).
         * @public
         * @type {string}
         * @name TMXTileMap#tiledversion
         */
        this.tiledversion = data.tiledversion;

        // tilesets for this map
        this.tilesets = null;

        // layers
        if (typeof this.layers === "undefined") {
            this.layers = [];
        }
        // group objects
        if (typeof this.objectGroups === "undefined") {
            this.objectGroups = [];
        }

        // Check if map is from melon editor
        this.isEditor = data.editor === "melon-editor";


        // object id
        this.nextobjectid = +data.nextobjectid || undefined;

        // hex/iso properties
        this.hexsidelength = +data.hexsidelength;
        this.staggeraxis = data.staggeraxis;
        this.staggerindex = data.staggerindex;

        // calculate the map bounding rect
        this.bounds = this.getRenderer().getBounds().clone();

        // map "real" size
        this.width = this.bounds.width;
        this.height = this.bounds.height;

        // background color
        this.backgroundcolor = data.backgroundcolor;

        // set additional map properties (if any)
        applyTMXProperties(this, data);

        // internal flag
        this.initialized = false;

        if (this.infinite === 1) {
            // #956 Support for Infinite map
            // see as well in me.TMXUtils
            throw new Error("Tiled Infinite Map not supported!");
        }
    }

    /**
     * Return the map default renderer
     * @name getRenderer
     * @memberof TMXTileMap
     * @public
     * @returns {TMXRenderer} a TMX renderer
     */
    getRenderer() {
        if ((typeof(this.renderer) === "undefined") || (!this.renderer.canRender(this))) {
            this.renderer = getNewDefaultRenderer(this);
        }        return this.renderer;
    }

    /**
     * return the map bounding rect
     * @name TMXRenderer#getBounds
     * @public
     * @returns {Bounds}
     */
    getBounds() {
        // calculated in the constructor
        return this.bounds;
    }

    /**
     * parse the map
     * @ignore
     */
    readMapObjects(data) {

        if (this.initialized === true) {
            return;
        }

        // to automatically increment z index
        var zOrder = 0;

        // Tileset information
        if (!this.tilesets) {
            // make sure we have a TilesetGroup Object
            this.tilesets = new TMXTilesetGroup();
        }

        // parse all tileset objects
        if (typeof (data.tilesets) !== "undefined") {
            var tilesets = data.tilesets;
            tilesets.forEach((tileset) => {
                // add the new tileset
                this.tilesets.add(readTileset(tileset));
            });
        }

        // check if a background image is defined
        if (this.background_image) {
            // add a new image layer
            this.layers.push(
                pool.pull("ImageLayer",
                    0, 0, {
                        name : "background_image",
                        image : this.background_image,
                        z : zOrder++
                    }
            ));
        }

        data.layers.forEach((layer) => {
            switch (layer.type) {
                case "imagelayer":
                    this.layers.push(readImageLayer(this, layer, zOrder++));
                    break;

                case "tilelayer":
                    this.layers.push(readLayer(this, layer, zOrder++));
                    break;

                // get the object groups information
                case "objectgroup":
                    this.objectGroups.push(readObjectGroup(this, layer, zOrder++));
                    break;

                // get the object groups information
                case "group":
                    this.objectGroups.push(readObjectGroup(this, layer, zOrder++));
                    break;
            }
        });

        this.initialized = true;
    }


    /**
     * add all the map layers and objects to the given container.
     * note : this will not automatically update the camera viewport
     * @name TMXTileMap#addTo
     * @public
     * @param {Container} container target container
     * @param {boolean} [flatten=true] if true, flatten all objects into the given container, else a `me.Container` object will be created for each corresponding groups
     * @param {boolean} [setViewportBounds=false] if true, set the viewport bounds to the map size, this should be set to true especially if adding a level to the game world container.
     * @example
     * // create a new level object based on the TMX JSON object
     * var level = new me.TMXTileMap(levelId, me.loader.getTMX(levelId));
     * // add the level to the game world container
     * level.addTo(me.game.world, true, true);
     */
    addTo(container, flatten, setViewportBounds) {
        var _sort = container.autoSort;
        var _depth = container.autoDepth;

        var levelBounds = this.getBounds();

        // disable auto-sort and auto-depth
        container.autoSort = false;
        container.autoDepth = false;

        if (this.backgroundcolor) {
            container.backgroundColor.parseCSS(this.backgroundcolor);
        }

        // add all layers instances
        this.getLayers().forEach(function (layer) {
            container.addChild(layer);
        });

        // add all Object instances
        this.getObjects(flatten).forEach(function (object) {
            container.addChild(object);
        });

        // resize the container accordingly
        container.resize(this.bounds.width, this.bounds.height);

        // sort everything (recursively)
        container.sort(true);

        /**
         * callback funtion for the viewport resize event
         * @ignore
         */
        function _setBounds(width, height) {
            // adjust the viewport bounds if level is smaller
            viewport.setBounds(
                0, 0,
                Math.max(levelBounds.width, width),
                Math.max(levelBounds.height, height)
            );
            // center the map if smaller than the current viewport
            container.pos.set(
                Math.max(0, ~~((width - levelBounds.width) / 2)),
                Math.max(0, ~~((height - levelBounds.height) / 2)),
                // don't change the container z position if defined
                container.pos.z
            );
        }

        if (setViewportBounds === true) {
            off(VIEWPORT_ONRESIZE, _setBounds);
            // force viewport bounds update
            _setBounds(viewport.width, viewport.height);
            // Replace the resize handler
            on(VIEWPORT_ONRESIZE, _setBounds, this);
        }

        //  set back auto-sort and auto-depth
        container.autoSort = _sort;
        container.autoDepth = _depth;
    }

    /**
     * return an Array of instantiated objects, based on the map object definition
     * @name TMXTileMap#getObjects
     * @public
     * @param {boolean} [flatten=true] if true, flatten all objects into the returned array.
     * when false, a `me.Container` object will be created for each corresponding groups
     * @returns {Renderable[]} Array of Objects
     */
    getObjects(flatten) {
        var objects = [];
        var isCollisionGroup = false;
        var targetContainer;

        // parse the map for objects
        this.readMapObjects(this.data);

        for (var g = 0; g < this.objectGroups.length; g++) {
            var group = this.objectGroups[g];

            // check if this is the collision shape group
            isCollisionGroup = group.name.toLowerCase().includes(COLLISION_GROUP);

            if (flatten === false) {
                // create a new container
                targetContainer = new Container(0, 0, this.width, this.height);

                // tiled uses 0,0 by default
                targetContainer.anchorPoint.set(0, 0);

                // set additional properties
                targetContainer.name = group.name;
                targetContainer.pos.z = group.z;
                targetContainer.setOpacity(group.opacity);

                // disable auto-sort and auto-depth
                targetContainer.autoSort = false;
                targetContainer.autoDepth = false;
            }

            // iterate through the group and add all object into their
            // corresponding target Container
            for (var o = 0; o < group.objects.length; o++) {
                // TMX object settings
                var settings = group.objects[o];
                // reference to the instantiated object
                var obj;
                // a reference to the default shape
                var shape;

                // Tiled uses 0,0 by default
                if (typeof (settings.anchorPoint) === "undefined") {
                    settings.anchorPoint = {x : 0, y : 0};
                }
                // convert to melonJS renderable argument name
                if (typeof (settings.tintcolor) !== "undefined") {
                    settings.tint = pool.pull("Color");
                    settings.tint.parseHex(settings.tintcolor, true);
                }

                /// XXX Clean/rewrite all this part to remove object
                /// specific instantiation logic/details from here

                // groups can contains either text, objects or layers
                if (settings instanceof TMXLayer) {
                    // layers are already instantiated & initialized
                    obj = settings;
                    // z value set already
                } else if (typeof settings.text === "object") {
                    // Tiled uses 0,0 by default
                    if (typeof (settings.text.anchorPoint) === "undefined") {
                        settings.text.anchorPoint = settings.anchorPoint;
                    }
                    if (settings.text.bitmap === true) {
                        obj = pool.pull("BitmapText", settings.x, settings.y, settings.text);
                    } else {
                        obj = pool.pull("Text", settings.x, settings.y, settings.text);
                    }
                    // set the obj z order
                    obj.pos.z = settings.z;
                } else if (typeof settings.tile === "object") {
                    // create a default shape if none is specified
                    shape = settings.shapes;
                    if (typeof shape === "undefined") {
                        shape = pool.pull("Polygon", 0, 0, [
                            pool.pull("Vector2d", 0,          0),
                            pool.pull("Vector2d", this.width, 0),
                            pool.pull("Vector2d", this.width, this.height)
                        ]);
                    }
                    // check if a me.Tile object is embedded
                    obj = settings.tile.getRenderable(settings);
                    obj.body = new Body(obj, shape);
                    obj.body.setStatic(true);
                    // set the obj z order
                    obj.pos.setMuted(settings.x, settings.y, settings.z);
                } else {
                    // pull the corresponding object from the object pool
                    if (typeof settings.name !== "undefined" && settings.name !== "") {
                        obj = pool.pull(
                            settings.name,
                            settings.x, settings.y,
                            settings
                        );
                    } else {
                        // unnamed shape object
                        obj = pool.pull(
                            "Renderable",
                            settings.x, settings.y,
                            settings.width, settings.height
                        );
                        // create a default shape if none is specified
                        shape = settings.shapes;
                        if (typeof shape === "undefined") {
                            shape = pool.pull("Polygon", 0, 0, [
                                pool.pull("Vector2d", 0,          0),
                                pool.pull("Vector2d", this.width, 0),
                                pool.pull("Vector2d", this.width, this.height)
                            ]);
                        }
                        obj.anchorPoint.set(0, 0);
                        obj.name = settings.name;
                        obj.type = settings.type;
                        obj.id = settings.id;
                        obj.body = new Body(obj, shape);
                        obj.body.setStatic(true);
                        obj.resize(obj.body.getBounds().width, obj.body.getBounds().height);
                    }
                    // set the obj z order
                    obj.pos.z = settings.z;
                }

                if (isCollisionGroup && !settings.name && obj.body) {
                    // configure the body accordingly
                    obj.body.collisionType = collision.types.WORLD_SHAPE;
                    // mark collision shapes as static
                    obj.body.isStatic = true;
                }

                //apply group opacity value to the child objects if group are merged
                if (flatten !== false) {
                    if (obj.isRenderable === true) {
                        obj.setOpacity(obj.getOpacity() * group.opacity);
                        // and to child renderables if any
                        if (obj.renderable instanceof Renderable) {
                            obj.renderable.setOpacity(obj.renderable.getOpacity() * group.opacity);
                        }
                    }
                    // directly add the obj into the objects array
                    objects.push(obj);
                } else /* false*/ {
                    // add it to the new container
                    targetContainer.addChild(obj);
                }

            }

            // if we created a new container
            if ((flatten === false) && (targetContainer.children.length > 0)) {

                // re-enable auto-sort and auto-depth
                targetContainer.autoSort = true;
                targetContainer.autoDepth = true;

                // add our container to the world
                objects.push(targetContainer);
            }
        }
        return objects;
    }

    /**
     * return all the existing layers
     * @name TMXTileMap#getLayers
     * @public
     * @returns {TMXLayer[]} Array of Layers
     */
    getLayers() {
        // parse the map for objects
        this.readMapObjects(this.data);
        return this.layers;
    }

    /**
     * destroy function, clean all allocated objects
     * @name TMXTileMap#destroy
     * @public
     */
    destroy() {
        this.tilesets = undefined;
        this.layers.length = 0;
        this.objectGroups.length = 0;
        this.initialized = false;
    }
}

// our levels
var levels = {};
// level index table
var levelIdx = [];
// current level index
var currentLevelIdx = 0;

/**
 * @ignore
 */
function safeLoadLevel(levelId, options, restart) {
    // clean the destination container
    options.container.reset();

    // reset the renderer
    reset();

    // clean the current (previous) level
    if (levels[level.getCurrentLevelId()]) {
        levels[level.getCurrentLevelId()].destroy();
    }

    // update current level index
    currentLevelIdx = levelIdx.indexOf(levelId);

    // add the specified level to the game world
    loadTMXLevel(levelId, options.container, options.flatten, options.setViewportBounds);

    // publish the corresponding message
    emit(LEVEL_LOADED, levelId);

    // fire the callback
    options.onLoaded(levelId);

    if (restart) {
        // resume the game loop if it was previously running
        state.restart();
    }
}
/**
 * Load a TMX level
 * @name loadTMXLevel
 * @memberof level
 * @private
 * @param {string} levelId level id
 * @param {Container} container target container
 * @param {boolean} [flatten=true] if true, flatten all objects into the given container
 * @param {boolean} [setViewportBounds=false] if true, set the viewport bounds to the map size, this should be set to true especially if adding a level to the game world container.
 * @ignore
 */
function loadTMXLevel(levelId, container, flatten, setViewportBounds) {
    var level = levels[levelId];

    // reset the GUID generator
    // and pass the level id as parameter
    utils.resetGUID(levelId, level.nextobjectid);

    // Tiled use 0,0 anchor coordinates
    container.anchorPoint.set(0, 0);

    // add all level elements to the target container
    level.addTo(container, flatten, setViewportBounds);
}

/**
 * a level manager. once ressources loaded, the level manager contains all references of defined levels.
 * @namespace level
 */

var level = {

    /**
     * add a level into the game manager (usually called by the preloader)
     * @name add
     * @memberof level
     * @public
     * @param {string} format level format (only "tmx" supported)
     * @param {string} levelId the level id (or name)
     * @param {Function} [callback] a function to be called once the level is loaded
     * @returns {boolean} true if the level was loaded
     */
    add(format, levelId, callback) {
        switch (format) {
            case "tmx" :
                // just load the level with the XML stuff
                if (levels[levelId] == null) {
                    //console.log("loading "+ levelId);
                    levels[levelId] = new TMXTileMap(levelId, loader.getTMX(levelId));
                    // level index
                    levelIdx.push(levelId);
                }
                else {
                    //console.log("level %s already loaded", levelId);
                    return false;
                }

                // call the callback if defined
                if (callback) {
                    callback();
                }
                // true if level loaded
                return true;

            default :
                throw new Error("no level loader defined for format " + format);
        }
    },

    /**
     * load a level into the game manager<br>
     * (will also create all level defined entities, etc..)
     * @name load
     * @memberof level
     * @public
     * @param {string} levelId level id
     * @param {object} [options] additional optional parameters
     * @param {Container} [options.container=game.world] container in which to load the specified level
     * @param {Function} [options.onLoaded=ame.onLevelLoaded] callback for when the level is fully loaded
     * @param {boolean} [options.flatten=game.mergeGroup] if true, flatten all objects into the given container
     * @param {boolean} [options.setViewportBounds=true] if true, set the viewport bounds to the map size
     * @returns {boolean} true if the level was successfully loaded
     * @example
     * // the game assets to be be preloaded
     * // TMX maps
     * var resources = [
     *     {name: "a4_level1",   type: "tmx",   src: "data/level/a4_level1.tmx"},
     *     {name: "a4_level2",   type: "tmx",   src: "data/level/a4_level2.tmx"},
     *     {name: "a4_level3",   type: "tmx",   src: "data/level/a4_level3.tmx"},
     *     // ...
     * ];
     *
     * // ...
     *
     * // load a level into the game world
     * me.level.load("a4_level1");
     * ...
     * ...
     * // load a level into a specific container
     * var levelContainer = new me.Container();
     * me.level.load("a4_level2", {container:levelContainer});
     * // add a simple transformation
     * levelContainer.currentTransform.translate(levelContainer.width / 2, levelContainer.height / 2 );
     * levelContainer.currentTransform.rotate(0.05);
     * levelContainer.currentTransform.translate(-levelContainer.width / 2, -levelContainer.height / 2 );
     * // add it to the game world
     * me.game.world.addChild(levelContainer);
     */
    load(levelId, options) {
        options = Object.assign({
            "container"         : world,
            "onLoaded"          : onLevelLoaded,
            "flatten"           : mergeGroup,
            "setViewportBounds" : true
        }, options || {});

        // throw an exception if not existing
        if (typeof(levels[levelId]) === "undefined") {
            throw new Error("level " + levelId + " not found");
        }

        if (levels[levelId] instanceof TMXTileMap) {

            // check the status of the state mngr
            var wasRunning = state.isRunning();

            if (wasRunning) {
                // stop the game loop to avoid
                // some silly side effects
                state.stop();

                utils.function.defer(safeLoadLevel, this, levelId, options, true);
            }
            else {
                safeLoadLevel(levelId, options);
            }
        }
        else {
            throw new Error("no level loader defined");
        }
        return true;
    },

    /**
     * return the current level id<br>
     * @name getCurrentLevelId
     * @memberof level
     * @public
     * @returns {string}
     */
    getCurrentLevelId() {
        return levelIdx[currentLevelIdx];
    },

    /**
     * return the current level definition.
     * for a reference to the live instantiated level,
     * rather use the container in which it was loaded (e.g. me.game.world)
     * @name getCurrentLevel
     * @memberof level
     * @public
     * @returns {TMXTileMap}
     */
    getCurrentLevel() {
        return levels[this.getCurrentLevelId()];
    },

    /**
     * reload the current level
     * @name reload
     * @memberof level
     * @public
     * @param {object} [options] additional optional parameters
     * @param {Container} [options.container=game.world] container in which to load the specified level
     * @param {Function} [options.onLoaded=game.onLevelLoaded] callback for when the level is fully loaded
     * @param {boolean} [options.flatten=game.mergeGroup] if true, flatten all objects into the given container
     * @returns {object} the current level
     */
    reload(options) {
        // reset the level to initial state
        //levels[currentLevel].reset();
        return this.load(this.getCurrentLevelId(), options);
    },

    /**
     * load the next level
     * @name next
     * @memberof level
     * @public
     * @param {object} [options] additional optional parameters
     * @param {Container} [options.container=game.world] container in which to load the specified level
     * @param {Function} [options.onLoaded=game.onLevelLoaded] callback for when the level is fully loaded
     * @param {boolean} [options.flatten=game.mergeGroup] if true, flatten all objects into the given container
     * @returns {boolean} true if the next level was successfully loaded
     */
    next(options) {
        //go to the next level
        if (currentLevelIdx + 1 < levelIdx.length) {
            return this.load(levelIdx[currentLevelIdx + 1], options);
        }
        else {
            return false;
        }
    },

    /**
     * load the previous level<br>
     * @name previous
     * @memberof level
     * @public
     * @param {object} [options] additional optional parameters
     * @param {Container} [options.container=game.world] container in which to load the specified level
     * @param {Function} [options.onLoaded=game.onLevelLoaded] callback for when the level is fully loaded
     * @param {boolean} [options.flatten=game.mergeGroup] if true, flatten all objects into the given container
     * @returns {boolean} true if the previous level was successfully loaded
     */
    previous(options) {
        // go to previous level
        if (currentLevelIdx - 1 >= 0) {
            return this.load(levelIdx[currentLevelIdx - 1], options);
        }
        else {
            return false;
        }
    },

    /**
     * return the amount of level preloaded
     * @name levelCount
     * @memberof level
     * @public
     * @returns {number} the amount of level preloaded
     */
    levelCount() {
        return levelIdx.length;
    }

};

// contains all the images loaded
var imgList = {};
// contains all the TMX loaded
var tmxList = {};
// contains all the binary files loaded
var binList = {};
// contains all the JSON files
var jsonList = {};
// baseURL
var baseURL = {};

// flag to check loading status
var resourceCount = 0;
var loadCount = 0;
var timerId = 0;

/**
 * check the loading status
 * @ignore
 */
function checkLoadStatus(onload) {
    if (loadCount === resourceCount) {
        // wait 1/2s and execute callback (cheap workaround to ensure everything is loaded)
        if (onload || loader.onload) {
            // make sure we clear the timer
            clearTimeout(timerId);
            // trigger the onload callback
            // we call either the supplied callback (which takes precedence) or the global one
            var callback = onload || loader.onload;
            setTimeout(function () {
                callback();
                emit(LOADER_COMPLETE);
            }, 300);
        }
        else {
            throw new Error("no load callback defined");
        }
    }
    else {
        timerId = setTimeout(() => {
            checkLoadStatus(onload);
        }, 100);
    }
}
/**
 * load Images
 * @example
 * preloadImages([
 *     { name : 'image1', src : 'images/image1.png'},
 *     { name : 'image2', src : 'images/image2.png'},
 *     { name : 'image3', src : 'images/image3.png'},
 *     { name : 'image4', src : 'images/image4.png'}
 * ]);
 * @ignore
 */
function preloadImage(img, onload, onerror) {
    // create new Image object and add to list
    imgList[img.name] = new Image();
    imgList[img.name].onload = onload;
    imgList[img.name].onerror = onerror;
    if (typeof (loader.crossOrigin) === "string") {
        imgList[img.name].crossOrigin = loader.crossOrigin;
    }
    imgList[img.name].src = img.src + loader.nocache;
}
/**
 * load a font face
 * @example
 * preloadFontFace(
 *     name: "'kenpixel'", type: "fontface",  src: "url('data/font/kenvector_future.woff2')"
 * ]);
 * @ignore
 */
function preloadFontFace(data, onload, onerror) {
    var font = new FontFace(data.name, data.src);
    // loading promise
    font.load().then(() => {
        // apply the font after the font has finished downloading
        document.fonts.add(font);
        document.body.style.fontFamily = data.name;
        // onloaded callback
        onload();
    }, function () {
        // rejected
        onerror(data.name);
    });
}
/**
 * preload TMX files
 * @ignore
 */
function preloadTMX(tmxData, onload, onerror) {
    /**
     * @ignore
     */
    function addToTMXList(data) {
        // set the TMX content
        tmxList[tmxData.name] = data;

        // add the tmx to the level manager
        if (tmxData.type === "tmx") {
            level.add(tmxData.type, tmxData.name);
        }
    }


    //if the data is in the tmxData object, don't get it via a XMLHTTPRequest
    if (tmxData.data) {
        addToTMXList(tmxData.data);
        onload();
        return;
    }

    var xmlhttp = new XMLHttpRequest();
    // check the data format ('tmx', 'json')
    var format = getExtension(tmxData.src);

    if (xmlhttp.overrideMimeType) {
        if (format === "json") {
            xmlhttp.overrideMimeType("application/json");
        }
        else {
            xmlhttp.overrideMimeType("text/xml");
        }
    }

    xmlhttp.open("GET", tmxData.src + loader.nocache, true);
    xmlhttp.withCredentials = loader.withCredentials;
    // set the callbacks
    xmlhttp.ontimeout = onerror;
    xmlhttp.onreadystatechange = function () {
        if (xmlhttp.readyState === 4) {
            // status = 0 when file protocol is used, or cross-domain origin,
            // (With Chrome use "--allow-file-access-from-files --disable-web-security")
            if ((xmlhttp.status === 200) || ((xmlhttp.status === 0) && xmlhttp.responseText)) {
                var result = null;

                // parse response
                switch (format) {
                    case "xml":
                    case "tmx":
                    case "tsx":
                        // ie9 does not fully implement the responseXML
                        if (device.ua.match(/msie/i) || !xmlhttp.responseXML) {
                            if (globalThis.DOMParser) {
                                // manually create the XML DOM
                                result = (new DOMParser()).parseFromString(xmlhttp.responseText, "text/xml");
                            } else {
                                throw new Error("XML file format loading not supported, use the JSON file format instead");
                            }
                        }
                        else {
                            result = xmlhttp.responseXML;
                        }
                        // converts to a JS object
                        var data = parse(result);
                        switch (format) {
                            case "tmx":
                                result = data.map;
                                break;

                            case "tsx":
                                result = data.tilesets[0];
                                break;
                        }

                        break;

                    case "json":
                        result = JSON.parse(xmlhttp.responseText);
                        break;

                    default:
                        throw new Error("TMX file format " + format + "not supported !");
                }

                //set the TMX content
                addToTMXList(result);

                // fire the callback
                onload();
            }
            else {
                onerror(tmxData.name);
            }
        }
    };
    // send the request
    xmlhttp.send();
}
/**
 * preload JSON files
 * @ignore
 */
function preloadJSON(data, onload, onerror) {
    var xmlhttp = new XMLHttpRequest();

    if (xmlhttp.overrideMimeType) {
        xmlhttp.overrideMimeType("application/json");
    }

    xmlhttp.open("GET", data.src + loader.nocache, true);
    xmlhttp.withCredentials = loader.withCredentials;

    // set the callbacks
    xmlhttp.ontimeout = onerror;
    xmlhttp.onreadystatechange = function () {
        if (xmlhttp.readyState === 4) {
            // status = 0 when file protocol is used, or cross-domain origin,
            // (With Chrome use "--allow-file-access-from-files --disable-web-security")
            if ((xmlhttp.status === 200) || ((xmlhttp.status === 0) && xmlhttp.responseText)) {
                // get the Texture Packer Atlas content
                jsonList[data.name] = JSON.parse(xmlhttp.responseText);
                // fire the callback
                onload();
            }
            else {
                onerror(data.name);
            }
        }
    };
    // send the request
    xmlhttp.send();
}
/**
 * preload Binary files
 * @ignore
 */
function preloadBinary(data, onload, onerror) {
    var httpReq = new XMLHttpRequest();

    // load our file
    httpReq.open("GET", data.src + loader.nocache, true);
    httpReq.withCredentials = loader.withCredentials;
    httpReq.responseType = "arraybuffer";
    httpReq.onerror = onerror;
    httpReq.onload = function () {
        var arrayBuffer = httpReq.response;
        if (arrayBuffer) {
            var byteArray = new Uint8Array(arrayBuffer);
            var buffer = [];
            for (var i = 0; i < byteArray.byteLength; i++) {
                buffer[i] = String.fromCharCode(byteArray[i]);
            }
            binList[data.name] = buffer.join("");
            // callback
            onload();
        }
    };
    httpReq.send();
}
/**
 * preload Binary files
 * @ignore
 */
function preloadJavascript(data, onload, onerror) {
    var script = document.createElement("script");

    script.src = data.src;
    script.type = "text/javascript";
    if (typeof (loader.crossOrigin) === "string") {
        script.crossOrigin = loader.crossOrigin;
    }
    script.defer = true;

    script.onload = () => {
        // callback
        onload();
    };

    script.onerror = () => {
        // callback
        onerror(data.name);
    };

    document.getElementsByTagName("body")[0].appendChild(script);
}
/**
 * a small class to manage loading of stuff and manage resources
 * @namespace loader
 */
var loader = {

    /**
     * to enable/disable caching
     * @ignore
     */
    nocache : "",

    /*
     * PUBLIC STUFF
     */

    /**
     * onload callback
     * @public
     * @name onload
     * @memberof loader
     * @example
     * // set a callback when everything is loaded
     * me.loader.onload = this.loaded.bind(this);
     */
    onload : undefined,

    /**
     * onProgress callback<br>
     * each time a resource is loaded, the loader will fire the specified function,
     * giving the actual progress [0 ... 1], as argument, and an object describing the resource loaded
     * @public
     * @name onProgress
     * @memberof loader
     * @example
     * // set a callback for progress notification
     * me.loader.onProgress = this.updateProgress.bind(this);
     */
    onProgress : undefined,

    /**
     * crossOrigin attribute to configure the CORS requests for Image data element.
     * By default (that is, when the attribute is not specified), CORS is not used at all.
     * The "anonymous" keyword means that there will be no exchange of user credentials via cookies,
     * client-side SSL certificates or HTTP authentication as described in the Terminology section of the CORS specification.<br>
     * @public
     * @type {string}
     * @name crossOrigin
     * @default undefined
     * @memberof loader
     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes
     * @example
     *  // allow for cross-origin texture loading in WebGL
     * me.loader.crossOrigin = "anonymous";
     *
     * // set all ressources to be loaded
     * me.loader.preload(game.resources, this.loaded.bind(this));
     */
    crossOrigin : undefined,

    /**
     * indicates whether or not cross-site Access-Control requests should be made using credentials such as cookies,
     * authorization headers or TLS client certificates. Setting withCredentials has no effect on same-site requests.
     * @public
     * @type {boolean}
     * @name withCredentials
     * @default false
     * @memberof loader
     * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials
     * @example
     *  // enable withCredentials
     * me.loader.withCredentials = true;
     *
     * // set all ressources to be loaded
     * me.loader.preload(game.resources, this.loaded.bind(this));
     */
    withCredentials : false,

    /**
     * just increment the number of already loaded resources
     * @ignore
     */
    onResourceLoaded(res) {
        // increment the loading counter
        loadCount++;

        // currrent progress
        var progress = loadCount / resourceCount;

        // call callback if defined
        if (this.onProgress) {
            // pass the load progress in percent, as parameter
            this.onProgress(progress, res);
        }
        emit(LOADER_PROGRESS, progress, res);
    },

    /**
     * on error callback for image loading
     * @ignore
     */
    onLoadingError(res) {
        throw new Error("Failed loading resource " + res.src);
    },

    /**
     * enable the nocache mechanism
     * @ignore
     */
    setNocache(enable) {
        this.nocache = enable ? "?" + ~~(Math.random() * 10000000) : "";
    },

    /**
     * change the default baseURL for the given asset type.<br>
     * (this will prepend the asset URL and must finish with a '/')
     * @name setBaseURL
     * @memberof loader
     * @public
     * @param {string} type  "*", "audio", binary", "image", "json", "js", "tmx", "tsx"
     * @param {string} [url="./"] default base URL
     * @example
     * // change the base URL relative address for audio assets
     * me.loader.setBaseURL("audio", "data/audio/");
     * // change the base URL absolute address for all object types
     * me.loader.setBaseURL("*", "http://myurl.com/")
     */
    setBaseURL(type, url) {
        if (type !== "*") {
            baseURL[type] = url;
        } else {
            // "wildcards"
            baseURL["audio"] = url;
            baseURL["binary"] = url;
            baseURL["image"] = url;
            baseURL["json"] = url;
            baseURL["js"] = url;
            baseURL["tmx"] = url;
            baseURL["tsx"] = url;
            // XXX ?
            //baseURL["fontface"] = url;
        }
    },

    /**
     * set all the specified game resources to be preloaded.
     * @name preload
     * @memberof loader
     * @public
     * @param {object[]} res
     * @param {string} res.name internal name of the resource
     * @param {string} res.type  "audio", binary", "image", "json","js", "tmx", "tsx", "fontface"
     * @param {string} res.src  path and/or file name of the resource (for audio assets only the path is required)
     * @param {boolean} [res.stream] Set to true to force HTML5 Audio, which allows not to wait for large file to be downloaded before playing.
     * @param {Function} [onload=loader.onload] function to be called when all resources are loaded
     * @param {boolean} [switchToLoadState=true] automatically switch to the loading screen
     * @example
     * game_resources = [
     *   // PNG tileset
     *   {name: "tileset-platformer", type: "image",  src: "data/map/tileset.png"},
     *   // PNG packed texture
     *   {name: "texture", type:"image", src: "data/gfx/texture.png"}
     *   // TSX file
     *   {name: "meta_tiles", type: "tsx", src: "data/map/meta_tiles.tsx"},
     *   // TMX level (XML & JSON)
     *   {name: "map1", type: "tmx", src: "data/map/map1.json"},
     *   {name: "map2", type: "tmx", src: "data/map/map2.tmx"},
     *   {name: "map3", type: "tmx", format: "json", data: {"height":15,"layers":[...],"tilewidth":32,"version":1,"width":20}},
     *   {name: "map4", type: "tmx", format: "xml", data: {xml representation of tmx}},
     *   // audio resources
     *   {name: "bgmusic", type: "audio",  src: "data/audio/"},
     *   {name: "cling",   type: "audio",  src: "data/audio/"},
     *   // binary file
     *   {name: "ymTrack", type: "binary", src: "data/audio/main.ym"},
     *   // JSON file (used for texturePacker)
     *   {name: "texture", type: "json", src: "data/gfx/texture.json"},
     *   // JavaScript file
     *   {name: "plugin", type: "js", src: "data/js/plugin.js"},
     *   // Font Face
     *   { name: "'kenpixel'", type: "fontface",  src: "url('data/font/kenvector_future.woff2')" }
     * ];
     * ...
     * // set all resources to be loaded
     * me.loader.preload(game.resources, this.loaded.bind(this));
     */
    preload(res, onload, switchToLoadState = true) {
        // parse the resources
        for (var i = 0; i < res.length; i++) {
            resourceCount += this.load(
                res[i],
                this.onResourceLoaded.bind(this, res[i]),
                this.onLoadingError.bind(this, res[i])
            );
        }
        // set the onload callback if defined
        if (typeof(onload) !== "undefined") {
            this.onload = onload;
        }

        if (switchToLoadState === true) {
            // swith to the loading screen
            state.change(state.LOADING);
        }

        // check load status
        checkLoadStatus(onload);
    },

    /**
     * Load a single resource (to be used if you need to load additional resource during the game)
     * @name load
     * @memberof loader
     * @public
     * @param {object} res
     * @param {string} res.name internal name of the resource
     * @param {string} res.type  "audio", binary", "image", "json", "tmx", "tsx"
     * @param {string} res.src  path and/or file name of the resource (for audio assets only the path is required)
     * @param {boolean} [res.stream] Set to true to force HTML5 Audio, which allows not to wait for large file to be downloaded before playing.
     * @param {Function} onload function to be called when the resource is loaded
     * @param {Function} onerror function to be called in case of error
     * @returns {number} the amount of corresponding resource to be preloaded
     * @example
     * // load an image asset
     * me.loader.load({name: "avatar",  type:"image",  src: "data/avatar.png"}, this.onload.bind(this), this.onerror.bind(this));
     *
     * // start loading music
     * me.loader.load({
     *     name   : "bgmusic",
     *     type   : "audio",
     *     src    : "data/audio/"
     * }, function () {
     *     me.audio.play("bgmusic");
     * });
     */
    load(res, onload, onerror) {
        // transform the url if necessary
        if (typeof (baseURL[res.type]) !== "undefined") {
            res.src = baseURL[res.type] + res.src;
        }
        // check ressource type
        switch (res.type) {
            case "binary":
                // reuse the preloadImage fn
                preloadBinary.call(this, res, onload, onerror);
                return 1;

            case "image":
                // reuse the preloadImage fn
                preloadImage.call(this, res, onload, onerror);
                return 1;

            case "json":
                preloadJSON.call(this, res, onload, onerror);
                return 1;

            case "js":
                preloadJavascript.call(this, res, onload, onerror);
                return 1;

            case "tmx":
            case "tsx":
                preloadTMX.call(this, res, onload, onerror);
                return 1;

            case "audio":
                load(res, !!res.stream, onload, onerror);
                return 1;

            case "fontface":
                preloadFontFace.call(this, res, onload, onerror);
                return 1;

            default:
                throw new Error("load : unknown or invalid resource type : " + res.type);
        }
    },

    /**
     * unload specified resource to free memory
     * @name unload
     * @memberof loader
     * @public
     * @param {object} res
     * @param {string} res.name internal name of the resource
     * @param {string} res.type  "audio", binary", "image", "json", "tmx", "tsx"
     * @returns {boolean} true if unloaded
     * @example me.loader.unload({name: "avatar",  type:"image"});
     */
    unload(res) {
        switch (res.type) {
            case "binary":
                if (!(res.name in binList)) {
                    return false;
                }

                delete binList[res.name];
                return true;

            case "image":
                if (!(res.name in imgList)) {
                    return false;
                }
                delete imgList[res.name];
                return true;

            case "json":
                if (!(res.name in jsonList)) {
                    return false;
                }

                delete jsonList[res.name];
                return true;

            case "js":
                // ??
                return true;

            case "fontface":
                // ??
                return true;

            case "tmx":
            case "tsx":
                if (!(res.name in tmxList)) {
                    return false;
                }

                delete tmxList[res.name];
                return true;

            case "audio":
                return unload(res.name);

            default:
                throw new Error("unload : unknown or invalid resource type : " + res.type);
        }
    },

    /**
     * unload all resources to free memory
     * @name unloadAll
     * @memberof loader
     * @public
     * @example me.loader.unloadAll();
     */
    unloadAll() {
        var name;

        // unload all binary resources
        for (name in binList) {
            if (binList.hasOwnProperty(name)) {
                this.unload({
                    "name" : name,
                    "type" : "binary"
                });
            }
        }

        // unload all image resources
        for (name in imgList) {
            if (imgList.hasOwnProperty(name)) {
                this.unload({
                    "name" : name,
                    "type" : "image"
                });
            }
        }

        // unload all tmx resources
        for (name in tmxList) {
            if (tmxList.hasOwnProperty(name)) {
                this.unload({
                    "name" : name,
                    "type" : "tmx"
                });
            }
        }

        // unload all in json resources
        for (name in jsonList) {
            if (jsonList.hasOwnProperty(name)) {
                this.unload({
                    "name" : name,
                    "type" : "json"
                });
            }
        }

        // unload all audio resources
        unloadAll();
    },

    /**
     * return the specified TMX/TSX object
     * @name getTMX
     * @memberof loader
     * @public
     * @param {string} elt name of the tmx/tsx element ("map1");
     * @returns {object} requested element or null if not found
     */
    getTMX(elt) {
        // force as string
        elt = "" + elt;
        if (elt in tmxList) {
            return tmxList[elt];
        }
        return null;
    },

    /**
     * return the specified Binary object
     * @name getBinary
     * @memberof loader
     * @public
     * @param {string} elt name of the binary object ("ymTrack");
     * @returns {object} requested element or null if not found
     */
    getBinary(elt) {
        // force as string
        elt = "" + elt;
        if (elt in binList) {
            return binList[elt];
        }
        return null;
    },

    /**
     * return the specified Image Object
     * @name getImage
     * @memberof loader
     * @public
     * @param {string} image name of the Image element ("tileset-platformer");
     * @returns {HTMLImageElement} requested element or null if not found
     */
    getImage(image) {
        // force as string and extract the base name
        image = getBasename("" + image);
        if (image in imgList) {
            // return the corresponding Image object
            return imgList[image];
        }
        return null;
    },

    /**
     * return the specified JSON Object
     * @name getJSON
     * @memberof loader
     * @public
     * @param {string} elt name of the json file to load
     * @returns {object}
     */
    getJSON(elt) {
        // force as string
        elt = "" + elt;
        if (elt in jsonList) {
            return jsonList[elt];
        }
        return null;
    }

};

// external import

/**
 * @namespace audio
 */

/**
 * audio channel list
 * @ignore
 */
let audioTracks = {};

/**
 * current active track
 * @ignore
 */
let current_track_id = null;

/**
 * error retry counter
 * @ignore
 */
let retry_counter = 0;

/**
 * list of active audio formats
 * @ignore
 */
let audioExts = [];

/**
 * event listener callback on load error
 * @ignore
 */
let soundLoadError = function (sound_name, onerror_cb) {
    // check the retry counter
    if (retry_counter++ > 3) {
        // something went wrong
        var errmsg = "melonJS: failed loading " + sound_name;
        {
            // throw an exception and stop everything !
            throw new Error(errmsg);
        }
    // else try loading again !
    }
    else {
        audioTracks[sound_name].load();
    }
};

/**
 * Specify either to stop on audio loading error or not<br>
 * if true, melonJS will throw an exception and stop loading<br>
 * if false, melonJS will disable sounds and output a warning message
 * in the console<br>
 * @name stopOnAudioError
 * @type {boolean}
 * @default true
 * @memberof audio
 */
let stopOnAudioError = true;

/**
 * Initialize and configure the audio support.<br>
 * melonJS supports a wide array of audio codecs that have varying browser support :
 * <i> ("mp3", "mpeg", opus", "ogg", "oga", "wav", "aac", "caf", "m4a", "m4b", "mp4", "weba", "webm", "dolby", "flac")</i>.<br>
 * For a maximum browser coverage the recommendation is to use at least two of them,
 * typically default to webm and then fallback to mp3 for the best balance of small filesize and high quality,
 * webm has nearly full browser coverage with a great combination of compression and quality, and mp3 will fallback gracefully for other browsers.
 * It is important to remember that melonJS selects the first compatible sound based on the list of extensions and given order passed here.
 * So if you want webm to be used before mp3, you need to put the audio format in that order.
 * @function audio.init
 * @param {string} [format="mp3"] audio format to prioritize
 * @returns {boolean} Indicates whether audio initialization was successful
 * @example
 * // initialize the "sound engine", giving "webm" as default desired audio format, and "mp3" as a fallback
 * if (!me.audio.init("webm,mp3")) {
 *     alert("Sorry but your browser does not support html 5 audio !");
 *     return;
 * }
 */
 function init$1(format = "mp3") {
    // convert it into an array
    audioExts = format.split(",");

    return !howler.Howler.noAudio;
}
/**
 * check if the given audio format is supported
 * @function audio.hasFormat
 * @param {string} codec audio format : "mp3", "mpeg", opus", "ogg", "oga", "wav", "aac", "caf", "m4a", "m4b", "mp4", "weba", "webm", "dolby", "flac"
 * @returns {boolean} return true if the given audio format is supported
 */
function hasFormat(codec) {
    return hasAudio() && howler.Howler.codecs(codec);
}
/**
 * check if audio (HTML5 or WebAudio) is supported
 * @function audio.hasAudio
 * @returns {boolean} return true if audio (HTML5 or WebAudio) is supported
 */
function hasAudio() {
    return !howler.Howler.noAudio;
}
/**
 * enable audio output <br>
 * only useful if audio supported and previously disabled through
 * @function audio.enable
 * @see audio#disable
 */
function enable() {
    unmuteAll();
}
/**
 * disable audio output
 * @function audio.disable
 */
function disable() {
    muteAll();
}
/**
 * Load an audio file.<br>
 * <br>
 * sound item must contain the following fields :<br>
 * - name    : name of the sound<br>
 * - src     : source path<br>
 * @ignore
 */
function load(sound, html5, onload_cb, onerror_cb) {
    var urls = [];
    if (audioExts.length === 0) {
        throw new Error("target audio extension(s) should be set through me.audio.init() before calling the preloader.");
    }
    for (var i = 0; i < audioExts.length; i++) {
        urls.push(sound.src + sound.name + "." + audioExts[i] + loader.nocache);
    }
    audioTracks[sound.name] = new howler.Howl({
        src : urls,
        volume : howler.Howler.volume(),
        html5 : html5 === true,
        xhrWithCredentials : loader.withCredentials,
        /**
         * @ignore
         */
        onloaderror() {
            soundLoadError.call(this, sound.name, onerror_cb);
        },
        /**
         * @ignore
         */
        onload() {
            retry_counter = 0;
            if (onload_cb) {
                onload_cb();
            }
        }
    });

    return 1;
}
/**
 * play the specified sound
 * @function audio.play
 * @param {string} sound_name audio clip name - case sensitive
 * @param {boolean} [loop=false] loop audio
 * @param {Function} [onend] Function to call when sound instance ends playing.
 * @param {number} [volume=default] Float specifying volume (0.0 - 1.0 values accepted).
 * @returns {number} the sound instance ID.
 * @example
 * // play the "cling" audio clip
 * me.audio.play("cling");
 * // play & repeat the "engine" audio clip
 * me.audio.play("engine", true);
 * // play the "gameover_sfx" audio clip and call myFunc when finished
 * me.audio.play("gameover_sfx", false, myFunc);
 * // play the "gameover_sfx" audio clip with a lower volume level
 * me.audio.play("gameover_sfx", false, null, 0.5);
 */
function play(sound_name, loop = false, onend, volume) {
    var sound = audioTracks[sound_name];
    if (sound && typeof sound !== "undefined") {
        var id = sound.play();
        if (typeof loop === "boolean") {
            // arg[0] can take different types in howler 2.0
            sound.loop(loop, id);
        }
        sound.volume(typeof(volume) === "number" ? clamp(volume, 0.0, 1.0) : howler.Howler.volume(), id);
        if (typeof(onend) === "function") {
            if (loop === true) {
                sound.on("end", onend, id);
            }
            else {
                sound.once("end", onend, id);
            }
        }
        return id;
    } else {
        throw new Error("audio clip " + sound_name + " does not exist");
    }
}
/**
 * Fade a currently playing sound between two volumee.
 * @function audio.fade
 * @param {string} sound_name audio clip name - case sensitive
 * @param {number} from Volume to fade from (0.0 to 1.0).
 * @param {number} to Volume to fade to (0.0 to 1.0).
 * @param {number} duration Time in milliseconds to fade.
 * @param {number} [id] the sound instance ID. If none is passed, all sounds in group will fade.
 */
function fade(sound_name, from, to, duration, id) {
    var sound = audioTracks[sound_name];
    if (sound && typeof sound !== "undefined") {
        sound.fade(from, to, duration, id);
    } else {
        throw new Error("audio clip " + sound_name + " does not exist");
    }
}
/**
 * get/set the position of playback for a sound.
 * @function audio.seek
 * @param {string} sound_name audio clip name - case sensitive
 * @param {number} [seek] the position to move current playback to (in seconds).
 * @param {number} [id] the sound instance ID. If none is passed, all sounds in group will changed.
 * @returns {number} return the current seek position (if no extra parameters were given)
 * @example
 * // return the current position of the background music
 * var current_pos = me.audio.seek("dst-gameforest");
 * // set back the position of the background music to the beginning
 * me.audio.seek("dst-gameforest", 0);
 */
function seek(sound_name, ...args) {
    var sound = audioTracks[sound_name];
    if (sound && typeof sound !== "undefined") {
        return sound.seek(...args);
    } else {
        throw new Error("audio clip " + sound_name + " does not exist");
    }
}
/**
 * get or set the rate of playback for a sound.
 * @function audio.rate
 * @param {string} sound_name audio clip name - case sensitive
 * @param {number} [rate] playback rate : 0.5 to 4.0, with 1.0 being normal speed.
 * @param {number} [id] the sound instance ID. If none is passed, all sounds in group will be changed.
 * @returns {number} return the current playback rate (if no extra parameters were given)
 * @example
 * // get the playback rate of the background music
 * var rate = me.audio.rate("dst-gameforest");
 * // speed up the playback of the background music
 * me.audio.rate("dst-gameforest", 2.0);
 */
function rate(sound_name, ...args) {
    var sound = audioTracks[sound_name];
    if (sound && typeof sound !== "undefined") {
        return sound.rate(...args);
    } else {
        throw new Error("audio clip " + sound_name + " does not exist");
    }
}
/**
 * stop the specified sound on all channels
 * @function audio.stop
 * @param {string} [sound_name] audio clip name (case sensitive). If none is passed, all sounds are stopped.
 * @param {number} [id] the sound instance ID. If none is passed, all sounds in group will stop.
 * @example
 * me.audio.stop("cling");
 */
function stop(sound_name, id) {
    if (typeof sound_name !== "undefined") {
        var sound = audioTracks[sound_name];
        if (sound && typeof sound !== "undefined") {
            sound.stop(id);
            // remove the defined onend callback (if any defined)
            sound.off("end", undefined, id);
        } else {
            throw new Error("audio clip " + sound_name + " does not exist");
        }
    } else {
        howler.Howler.stop();
    }
}
/**
 * pause the specified sound on all channels<br>
 * this function does not reset the currentTime property
 * @function audio.pause
 * @param {string} sound_name audio clip name - case sensitive
 * @param {number} [id] the sound instance ID. If none is passed, all sounds in group will pause.
 * @example
 * me.audio.pause("cling");
 */
function pause(sound_name, id) {
    var sound = audioTracks[sound_name];
    if (sound && typeof sound !== "undefined") {
        sound.pause(id);
    } else {
        throw new Error("audio clip " + sound_name + " does not exist");
    }
}
/**
 * resume the specified sound on all channels<br>
 * @function audio.resume
 * @param {string} sound_name audio clip name - case sensitive
 * @param {number} [id] the sound instance ID. If none is passed, all sounds in group will resume.
 * @example
 * // play a audio clip
 * var id = me.audio.play("myClip");
 * ...
 * // pause it
 * me.audio.pause("myClip", id);
 * ...
 * // resume
 * me.audio.resume("myClip", id);
 */
function resume(sound_name, id) {
    var sound = audioTracks[sound_name];
    if (sound && typeof sound !== "undefined") {
        sound.play(id);
    } else {
        throw new Error("audio clip " + sound_name + " does not exist");
    }
}
/**
 * play the specified audio track<br>
 * this function automatically set the loop property to true<br>
 * and keep track of the current sound being played.
 * @function audio.playTrack
 * @param {string} sound_name audio track name - case sensitive
 * @param {number} [volume=default] Float specifying volume (0.0 - 1.0 values accepted).
 * @returns {number} the sound instance ID.
 * @example
 * me.audio.playTrack("awesome_music");
 */
function playTrack(sound_name, volume) {
    current_track_id = sound_name;
    return play(
        current_track_id,
        true,
        null,
        volume
    );
}
/**
 * stop the current audio track
 * @function audio.stopTrack
 * @see audio#playTrack
 * @example
 * // play a awesome music
 * me.audio.playTrack("awesome_music");
 * // stop the current music
 * me.audio.stopTrack();
 */
function stopTrack() {
    if (current_track_id !== null) {
        audioTracks[current_track_id].stop();
        current_track_id = null;
    }
}
/**
 * pause the current audio track
 * @function audio.pauseTrack
 * @example
 * me.audio.pauseTrack();
 */
function pauseTrack() {
    if (current_track_id !== null) {
        audioTracks[current_track_id].pause();
    }
}
/**
 * resume the previously paused audio track
 * @function audio.resumeTrack
 * @example
 * // play an awesome music
 * me.audio.playTrack("awesome_music");
 * // pause the audio track
 * me.audio.pauseTrack();
 * // resume the music
 * me.audio.resumeTrack();
 */
function resumeTrack() {
    if (current_track_id !== null) {
        audioTracks[current_track_id].play();
    }
}
/**
 * returns the current track Id
 * @function audio.getCurrentTrack
 * @returns {string} audio track name
 */
function getCurrentTrack() {
    return current_track_id;
}
/**
 * set the default global volume
 * @function audio.setVolume
 * @param {number} volume Float specifying volume (0.0 - 1.0 values accepted).
 */
function setVolume(volume) {
    howler.Howler.volume(volume);
}
/**
 * get the default global volume
 * @function audio.getVolume
 * @returns {number} current volume value in Float [0.0 - 1.0] .
 */
function getVolume() {
    return howler.Howler.volume();
}
/**
 * mute or unmute the specified sound, but does not pause the playback.
 * @function audio.mute
 * @param {string} sound_name audio clip name - case sensitive
 * @param {number} [id] the sound instance ID. If none is passed, all sounds in group will mute.
 * @param {boolean} [mute=true] True to mute and false to unmute
 * @example
 * // mute the background music
 * me.audio.mute("awesome_music");
 */
function mute(sound_name, id, mute) {
    // if not defined : true
    mute = (typeof(mute) === "undefined" ? true : !!mute);
    var sound = audioTracks[sound_name];
    if (sound && typeof(sound) !== "undefined") {
        sound.mute(mute, id);
    } else {
        throw new Error("audio clip " + sound_name + " does not exist");
    }
}
/**
 * unmute the specified sound
 * @function audio.unmute
 * @param {string} sound_name audio clip name
 * @param {number} [id] the sound instance ID. If none is passed, all sounds in group will unmute.
 */
function unmute(sound_name, id) {
    mute(sound_name, id, false);
}
/**
 * mute all audio
 * @function audio.muteAll
 */
function muteAll() {
    howler.Howler.mute(true);
}
/**
 * unmute all audio
 * @function audio.unmuteAll
 */
function unmuteAll() {
    howler.Howler.mute(false);
}
/**
 * Returns true if audio is muted globally.
 * @function audio.muted
 * @returns {boolean} true if audio is muted globally
 */
function muted() {
    return howler.Howler._muted;
}
/**
 * unload specified audio track to free memory
 * @function audio.unload
 * @param {string} sound_name audio track name - case sensitive
 * @returns {boolean} true if unloaded
 * @example
 * me.audio.unload("awesome_music");
 */
function unload(sound_name) {
    if (!(sound_name in audioTracks)) {
        return false;
    }

    // destroy the Howl object
    audioTracks[sound_name].unload();
    delete audioTracks[sound_name];
    return true;
}
/**
 * unload all audio to free memory
 * @function audio.unloadAll
 * @example
 * me.audio.unloadAll();
 */
function unloadAll() {
    for (var sound_name in audioTracks) {
        if (audioTracks.hasOwnProperty(sound_name)) {
            unload(sound_name);
        }
    }
}

var audio = /*#__PURE__*/Object.freeze({
	__proto__: null,
	stopOnAudioError: stopOnAudioError,
	init: init$1,
	hasFormat: hasFormat,
	hasAudio: hasAudio,
	enable: enable,
	disable: disable,
	load: load,
	play: play,
	fade: fade,
	seek: seek,
	rate: rate,
	stop: stop,
	pause: pause,
	resume: resume,
	playTrack: playTrack,
	stopTrack: stopTrack,
	pauseTrack: pauseTrack,
	resumeTrack: resumeTrack,
	getCurrentTrack: getCurrentTrack,
	setVolume: setVolume,
	getVolume: getVolume,
	mute: mute,
	unmute: unmute,
	muteAll: muteAll,
	unmuteAll: unmuteAll,
	muted: muted,
	unload: unload,
	unloadAll: unloadAll
});

/**
 * allow to access and manage the device localStorage
 * @example
 * // Initialize "score" and "lives" with default values
 * // This loads the properties from localStorage if they exist, else it sets the given defaults
 * me.save.add({ score : 0, lives : 3 });
 *
 * // Print all
 * // On first load, this prints { score : 0, lives : 3 }
 * // On further reloads, it prints { score : 31337, lives : 3, complexObject : ... }
 * // Because the following changes will be saved to localStorage
 * console.log(JSON.stringify(me.save));
 *
 * // Save score
 * me.save.score = 31337;
 *
 * // Also supports complex objects thanks to the JSON backend
 * me.save.add({ complexObject : {} })
 * me.save.complexObject = { a : "b", c : [ 1, 2, 3, "d" ], e : { f : [{}] } };
 *
 * // WARNING: Do not set any child properties of complex objects directly!
 * // Changes made that way will not save. Always set the entire object value at once.
 * // If you cannot live with this limitation, there's a workaround:
 * me.save.complexObject.c.push("foo"); // Modify a child property
 * me.save.complexObject = me.save.complexObject; // Save the entire object!
 *
 * // Remove "lives" from localStorage
 * me.save.remove("lives");
 * @namespace save
 */

 // Variable to hold the object data
 var data = {};

 /**
  * a function to check if the given key is a reserved word
  * @ignore
  */
 function isReserved(key) {
     return (key === "add" || key === "remove");
 }


// Initialize me.save on Boot event
on(BOOT, () => {
    // Load previous data if local Storage is supported
    if (typeof globalThis.localStorage !== "undefined") {
        var me_save_content = globalThis.localStorage.getItem("me.save");

        if (typeof me_save_content === "string" && me_save_content.length > 0) {
            var keys = JSON.parse(me_save_content) || [];
            keys.forEach(function (key) {
                data[key] = JSON.parse(globalThis.localStorage.getItem("me.save." + key));
            });
        }
    }
});

var save = {

    /**
     * Add new keys to localStorage and set them to the given default values if they do not exist
     * @name add
     * @memberof save
     * @param {object} props key and corresponding values
     * @example
     * // Initialize "score" and "lives" with default values
     * me.save.add({ score : 0, lives : 3 });
     * // get or set the value through me.save
     * me.save.score = 1000;
     */
    add(props) {
        var obj = save;

        Object.keys(props).forEach(function (key) {
            if (isReserved(key)) {
                return;
            }

            (function (prop) {
                Object.defineProperty(obj, prop, {
                    configurable : true,
                    enumerable : true,
                    /**
                     * @ignore
                     */
                    get () {
                        return data[prop];
                    },
                    /**
                     * @ignore
                     */
                    set (value) {
                        data[prop] = value;
                        if (device.localStorage === true) {
                            globalThis.localStorage.setItem("me.save." + prop, JSON.stringify(value));
                        }
                    }
                });
            })(key);

            // Set default value for key
            if (!(key in data)) {
                obj[key] = props[key];
            }
        });

        // Save keys
        if (device.localStorage === true) {
            globalThis.localStorage.setItem("me.save", JSON.stringify(Object.keys(data)));
        }
    },

    /**
     * Remove a key from localStorage
     * @name remove
     * @memberof save
     * @param {string} key key to be removed
     * @example
     * // Remove the "score" key from localStorage
     * me.save.remove("score");
     */
    remove (key) {
        if (!isReserved(key)) {
            if (typeof data[key] !== "undefined") {
                delete data[key];
                if (device.localStorage === true) {
                    globalThis.localStorage.removeItem("me.save." + key);
                    globalThis.localStorage.setItem("me.save", JSON.stringify(Object.keys(data)));
                }
            }
        }
    }
};

// track if DOMContentLoaded was called already
let readyBound = false;

// is the DOM ready ?
let isDOMReady = false;

// check if the dom is ready
function _domReady() {

    // Make sure that the DOM is not already loaded
    if (!isDOMReady) {
        // be sure document.body is there
        if (typeof globalThis.document !== "undefined" && !globalThis.document.body) {
            return setTimeout(_domReady, 13);
        }

        // clean up loading event
        if (typeof globalThis.document !== "undefined" && typeof globalThis.document.removeEventListener === "function") {
            globalThis.document.removeEventListener(
                "DOMContentLoaded",
                _domReady,
                false
            );
        }

        if (typeof globalThis.removeEventListener === "function") {
            // remove the event on globalThis.onload (always added in `onReady`)
            globalThis.removeEventListener("load", _domReady, false);
        }

        // execute all callbacks
        emit(DOM_READY);

        // Remember that the DOM is ready
        isDOMReady = true;
    }
}
// https://developer.mozilla.org/en-US/docs/Web/API/Window/DOMContentLoaded_event
function DOMContentLoaded(fn) {
    // If the DOM is already ready
    if (isDOMReady) {
        // Execute the function immediately
        fn.call(globalThis, []);
    }
    else {
        // else add the function to the DOM_READY event
        once(DOM_READY, fn, globalThis);
        // bind dom load event if not done yet
        if (!readyBound) {
            // directly call domReady if document is already "ready"
            if (((typeof process !== "undefined") && (process.release.name === "node")) || (typeof globalThis.document !== "undefined" && globalThis.document.readyState === "complete")) {
                // defer the fn call to ensure our script is fully loaded
                globalThis.setTimeout(_domReady, 0);
            }
            else {
                if (typeof globalThis.document !== "undefined" && typeof globalThis.document.addEventListener === "function") {
                    // Use the handy event callback
                    globalThis.document.addEventListener("DOMContentLoaded", _domReady, false);
                }
                // A fallback to globalThis.onload, that will always work
                globalThis.addEventListener("load", _domReady, false);
            }
            readyBound = true;
        }
    }
}

// private properties
let accelInitialized = false;
let deviceOrientationInitialized = false;

// swipe utility fn & flag
let swipeEnabled = true;

/**
 * @ignore
 */
function _disableSwipeFn(e) {
    e.preventDefault();
    if (typeof globalThis.scroll === "function") {
        globalThis.scroll(0, 0);
    }
    return false;
}
// a cache DOMRect object
let _domRect = {left: 0, top: 0, x: 0, y: 0, width: 0, height: 0, right: 0, bottom: 0};

/**
 * detect the device type
 * @ignore
 */
function _detectDevice() {
    // iOS Device ?
    device.iOS = /iPhone|iPad|iPod/i.test(device.ua);
    // Android Device ?
    device.android = /Android/i.test(device.ua);
    device.android2 = /Android 2/i.test(device.ua);
    // Linux platform
    device.linux = /Linux/i.test(device.ua);
    // Chrome OS ?
    device.chromeOS = /CrOS/.test(device.ua);
    // Windows Device ?
    device.wp = /Windows Phone/i.test(device.ua);
    // Blackberry device ?
    device.BlackBerry = /BlackBerry/i.test(device.ua);
    // Kindle device ?
    device.Kindle = /Kindle|Silk.*Mobile Safari/i.test(device.ua);
    // Mobile platform
    device.isMobile = /Mobi/i.test(device.ua) ||
                         device.iOS ||
                         device.android ||
                         device.wp ||
                         device.BlackBerry ||
                         device.Kindle || false;
    // ejecta
    device.ejecta = (typeof globalThis.ejecta !== "undefined");
    // Wechat
    device.isWeixin = /MicroMessenger/i.test(device.ua);
}
/**
 * check the device capapbilities
 * @ignore
 */
function _checkCapabilities() {

    // detect device type/platform
    _detectDevice();

    // Touch/Gesture Event feature detection
    device.TouchEvent = !!("ontouchstart" in globalThis);
    device.PointerEvent = !!globalThis.PointerEvent;
    globalThis.gesture = prefixed("gesture");

    // detect touch capabilities
    device.touch = device.TouchEvent || device.PointerEvent;

    // max amount of touch points ; always at least return 1 (e.g. headless chrome will return 0)
    device.maxTouchPoints = device.touch ? (device.PointerEvent ? globalThis.navigator.maxTouchPoints || 1 : 10) : 1;

    // detect wheel event support
    // Modern browsers support "wheel", Webkit and IE support at least "mousewheel
    device.wheel = typeof globalThis.document !== "undefined" && "onwheel" in globalThis.document.createElement("div");

    // pointerlock detection (pointerLockElement can be null when the feature is supported)
    device.hasPointerLockSupport = typeof globalThis.document !== "undefined" && typeof globalThis.document.pointerLockElement !== "undefined";

    // device orientation and motion detection
    device.hasDeviceOrientation = !!globalThis.DeviceOrientationEvent;
    device.hasAccelerometer = !!globalThis.DeviceMotionEvent;

    // support the ScreenOrientation API
    device.ScreenOrientation = (typeof screen !== "undefined") &&
                               (typeof screen.orientation !== "undefined");

    // fullscreen api detection & polyfill when possible
    device.hasFullscreenSupport = typeof globalThis.document !== "undefined" && (prefixed("fullscreenEnabled", globalThis.document) || globalThis.document.mozFullScreenEnabled);

    if (device.hasFullscreenSupport === true) {
        globalThis.document.exitFullscreen = typeof globalThis.document !== "undefined" && (prefixed("cancelFullScreen", globalThis.document) || prefixed("exitFullscreen", globalThis.document));
    }


    // web Audio detection
    device.hasWebAudio = !!(globalThis.AudioContext || globalThis.webkitAudioContext);

    try {
        device.localStorage = !!globalThis.localStorage;
    } catch (e) {
        // the above generates an exception when cookies are blocked
        device.localStorage = false;
    }

    try {
        // some browser (e.g. Safari) implements WebGL1 and WebGL2 contexts only
        // https://bugzilla.mozilla.org/show_bug.cgi?id=801176
        device.OffscreenCanvas =
            (typeof globalThis.OffscreenCanvas !== "undefined") &&
            ((new OffscreenCanvas(0, 0).getContext( "2d" )) !== null);
    } catch (e) {
        device.OffscreenCanvas = false;
    }

    if (typeof globalThis.addEventListener === "function") {
        // set pause/stop action on losing focus
        globalThis.addEventListener("blur", function () {
            if (device.stopOnBlur) {
                state.stop(true);
            }
            if (device.pauseOnBlur) {
                state.pause(true);
            }
        }, false);
        // set restart/resume action on gaining focus
        globalThis.addEventListener("focus", function () {
            if (device.stopOnBlur) {
                state.restart(true);
            }
            if (device.resumeOnFocus) {
                state.resume(true);
            }
            // force focus if autofocus is on
            if (device.autoFocus) {
                device.focus();
            }
        }, false);
    }

    if (typeof globalThis.document !== "undefined") {
        // Set the name of the hidden property and the change event for visibility
        var hidden, visibilityChange;
        if (typeof globalThis.document.hidden !== "undefined") {
            // Opera 12.10 and Firefox 18 and later support
            hidden = "hidden";
            visibilityChange = "visibilitychange";
        } else if (typeof globalThis.document.mozHidden !== "undefined") {
            hidden = "mozHidden";
            visibilityChange = "mozvisibilitychange";
        } else if (typeof globalThis.document.msHidden !== "undefined") {
            hidden = "msHidden";
            visibilityChange = "msvisibilitychange";
        } else if (typeof globalThis.document.webkitHidden !== "undefined") {
            hidden = "webkitHidden";
            visibilityChange = "webkitvisibilitychange";
        }

        // register on the event if supported
        if (typeof (visibilityChange) === "string") {
            // add the corresponding event listener
            globalThis.document.addEventListener(visibilityChange,
                function () {
                    if (globalThis.document[hidden]) {
                        if (device.stopOnBlur) {
                            state.stop(true);
                        }
                        if (device.pauseOnBlur) {
                            state.pause(true);
                        }
                    } else {
                        if (device.stopOnBlur) {
                            state.restart(true);
                        }
                        if (device.resumeOnFocus) {
                            state.resume(true);
                        }
                    }
                }, false
            );
        }
    }

    // Mobile browser hacks
    if (device.isMobile) {
        // Prevent the webview from moving on a swipe
        device.enableSwipe(false);
    }

}

// Initialize me.timer on Boot event
on(BOOT, () => {
    _checkCapabilities();
});


// public export
/**
 * The device capabilities and specific events
 *
 * @namespace
 */
let device = {

    /**
     * the `ua` read-only property returns the user agent string for the current browser.
     * @type {string}
     * @readonly
     * @name ua
     */
    ua : typeof globalThis.navigator !== "undefined" ? globalThis.navigator.userAgent : "",

    /**
     * Browser Local Storage capabilities <br>
     * (this flag will be set to false if cookies are blocked)
     * @type {boolean}
     * @readonly
     * @name localStorage
     */
    localStorage : false,

    /**
     * Browser accelerometer capabilities
     * @type {boolean}
     * @readonly
     * @name hasAccelerometer
     */
    hasAccelerometer : false,

    /**
     * Browser device orientation
     * @type {boolean}
     * @readonly
     * @name hasDeviceOrientation
     */
    hasDeviceOrientation : false,

    /**
     * Supports the ScreenOrientation API
     * @see https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation/onchange
     * @type {boolean}
     * @readonly
     * @name ScreenOrientation
     */
    ScreenOrientation : false,

    /**
     * Browser full screen support
     * @type {boolean}
     * @readonly
     * @name hasFullscreenSupport
     */
    hasFullscreenSupport : false,

    /**
     * Browser pointerlock api support
     * @type {boolean}
     * @readonly
     * @name hasPointerLockSupport
     */
    hasPointerLockSupport : false,

    /**
     * Device WebAudio Support
     * @type {boolean}
     * @readonly
     * @name hasWebAudio
     */
    hasWebAudio : false,

    /**
     * Browser Base64 decoding capability
     * @type {boolean}
     * @readonly
     * @name nativeBase64
     */
    nativeBase64 : (typeof(globalThis.atob) === "function"),

    /**
     * Return the maximum number of simultaneous touch contact points are supported by the current device.
     * @type {number}
     * @readonly
     * @name maxTouchPoints
     * @example
     * if (me.device.maxTouchPoints > 1) {
     *     // device supports multi-touch
     * }
     */
    maxTouchPoints : 1,

    /**
     * Touch capabilities
     * @type {boolean}
     * @readonly
     * @name touch
     */
    touch : false,

    /**
     * W3C standard wheel events
     * @type {boolean}
     * @readonly
     * @name wheel
     */
    wheel : false,

    /**
     * equals to true if a mobile device <br>
     * (Android | iPhone | iPad | iPod | BlackBerry | Windows Phone | Kindle)
     * @type {boolean}
     * @readonly
     * @name isMobile
     */
    isMobile : false,

    /**
     * equals to true if the device is an iOS platform.
     * @type {boolean}
     * @readonly
     * @name iOS
     */
    iOS : false,

    /**
     * equals to true if the device is an Android platform.
     * @type {boolean}
     * @readonly
     * @name android
     */
    android : false,

    /**
     * equals to true if the device is an Android 2.x platform.
     * @type {boolean}
     * @readonly
     * @name android2
     */
    android2 : false,

    /**
     * equals to true if the device is a Linux platform.
     * @type {boolean}
     * @readonly
     * @name linux
     */
    linux : false,

    /**
     * equals to true if the game is running under Ejecta.
     * @type {boolean}
     * @readonly
     * @see http://impactjs.com/ejecta
     * @name ejecta
     */
    ejecta : false,

    /**
     * equals to true if the  is running under Wechat.
     * @type {boolean}
     * @readonly
     * @name isWeixin
     */
    isWeixin : false,

    /**
     * equals to true if running under node.js
     * @type {boolean}
     * @readonly
     * @name nodeJS
     */
    nodeJS : (typeof globalThis.process !== "undefined") && (typeof globalThis.process.release !== "undefined") && (globalThis.process.release.name === "node"),

    /**
     * equals to true if the device is running on ChromeOS.
     * @type {boolean}
     * @readonly
     * @name chromeOS
     */
    chromeOS : false,

    /**
     * equals to true if the device is a Windows Phone platform.
     * @type {boolean}
     * @readonly
     * @name wp
     */
    wp : false,

    /**
     * equals to true if the device is a BlackBerry platform.
     * @type {boolean}
     * @readonly
     * @name BlackBerry
     */
    BlackBerry : false,

    /**
     * equals to true if the device is a Kindle platform.
     * @type {boolean}
     * @readonly
     * @name Kindle
     */
    Kindle : false,

    /**
     * contains the g-force acceleration along the x-axis.
     * @public
     * @type {number}
     * @readonly
     * @name accelerationX
     * @see device.watchAccelerometer
     */
    accelerationX : 0,

    /**
     * contains the g-force acceleration along the y-axis.
     * @public
     * @type {number}
     * @readonly
     * @name accelerationY
     * @see device.watchAccelerometer
     */
    accelerationY : 0,

    /**
     * contains the g-force acceleration along the z-axis.
     * @public
     * @type {number}
     * @readonly
     * @name accelerationZ
     * @see device.watchAccelerometer
     */
    accelerationZ : 0,

    /**
     * Device orientation Gamma property. Gives angle on tilting a portrait held phone left or right
     * @public
     * @type {number}
     * @readonly
     * @name gamma
     * @see device.watchDeviceOrientation
     */
    gamma : 0,

    /**
     * Device orientation Beta property. Gives angle on tilting a portrait held phone forward or backward
     * @public
     * @type {number}
     * @readonly
     * @name beta
     * @see device.watchDeviceOrientation
     */
    beta: 0,

    /**
     * Device orientation Alpha property. Gives angle based on the rotation of the phone around its z axis.
     * The z-axis is perpendicular to the phone, facing out from the center of the screen.
     * @public
     * @type {number}
     * @readonly
     * @name alpha
     * @see device.watchDeviceOrientation
     */
    alpha : 0,

    /**
     * a string representing the preferred language of the user, usually the language of the browser UI.
     * (will default to "en" if the information is not available)
     * @public
     * @type {string}
     * @readonly
     * @see http://www.w3schools.com/tags/ref_language_codes.asp
     * @name language
     */
    language : typeof globalThis.navigator !== "undefined" ? globalThis.navigator.language || globalThis.navigator.browserLanguage || globalThis.navigator.userLanguage || "en" : "en",

    /**
     * Specify whether to pause the game when losing focus
     * @type {boolean}
     * @default true
     */
    pauseOnBlur : true,

    /**
     * Specify whether to unpause the game when gaining focus
     * @type {boolean}
     * @default true
     */
    resumeOnFocus : true,

    /**
     * Specify whether to automatically bring the window to the front
     * @type {boolean}
     * @default true
     */
    autoFocus : true,

    /**
     * Specify whether to stop the game when losing focus or not.
     * The engine restarts on focus if this is enabled.
     * @type {boolean}
     * @default false
     */
    stopOnBlur : false,

    /**
     * equals to true if the device browser supports OffScreenCanvas.
     * @type {boolean}
     * @readonly
     * @name OffScreenCanvas
     */
    OffscreenCanvas : false,


   /**
    * specify a function to execute when the Device is fully loaded and ready
    * @function device.onReady
    * @param {Function} fn the function to be executed
    * @example
    * // small game skeleton
    * var game = {
    *    // called by the me.device.onReady function
    *    onload : function () {
    *       // init video
    *       if (!me.video.init('screen', 640, 480, true)) {
    *          alert("Sorry but your browser does not support html 5 canvas.");
    *          return;
    *       }
    *
    *       // initialize the "audio"
    *       me.audio.init("mp3,ogg");
    *
    *       // set callback for ressources loaded event
    *       me.loader.onload = this.loaded.bind(this);
    *
    *       // set all ressources to be loaded
    *       me.loader.preload(game.assets);
    *
    *       // load everything & display a loading screen
    *       me.state.change(me.state.LOADING);
    *    },
    *
    *    // callback when everything is loaded
    *    loaded : function () {
    *       // define stuff
    *       // ....
    *
    *       // change to the menu screen
    *       me.state.change(me.state.PLAY);
    *    }
    * }, // game
    *
    * // "bootstrap"
    * me.device.onReady(function () {
    *    game.onload();
    * });
    */
    onReady(fn) {
        DOMContentLoaded(fn);
    },

    /**
     * enable/disable swipe on WebView.
     * @function device.enableSwipe
     * @param {boolean} [enable=true] enable or disable swipe.
     */
    enableSwipe(enable) {
        var moveEvent = device.PointerEvent ? "pointermove" : (device.TouchEvent ? "touchmove" : "mousemove");
        if (enable !== false) {
            if (swipeEnabled === false) {
                globalThis.document.removeEventListener(moveEvent, _disableSwipeFn);
                swipeEnabled = true;
            }
        } else if (swipeEnabled === true) {
            globalThis.document.addEventListener(moveEvent, _disableSwipeFn, { passive: false });
            swipeEnabled = false;
        }
    },

    /**
     * Triggers a fullscreen request. Requires fullscreen support from the browser/device.
     * @function device.requestFullscreen
     * @param {object} [element=default canvas object] the element to be set in full-screen mode.
     * @example
     * // add a keyboard shortcut to toggle Fullscreen mode on/off
     * me.input.bindKey(me.input.KEY.F, "toggleFullscreen");
     * me.event.on(me.event.KEYDOWN, function (action, keyCode, edge) {
     *    // toggle fullscreen on/off
     *    if (action === "toggleFullscreen") {
     *       if (!me.device.isFullscreen) {
     *          me.device.requestFullscreen();
     *       } else {
     *          me.device.exitFullscreen();
     *       }
     *    }
     * });
     */
    requestFullscreen(element) {
        if (this.hasFullscreenSupport) {
            element = element || getParent();
            element.requestFullscreen = prefixed("requestFullscreen", element) ||
                                        element.mozRequestFullScreen;

            element.requestFullscreen();
        }
    },

    /**
     * Exit fullscreen mode. Requires fullscreen support from the browser/device.
     * @function device.exitFullscreen
     */
    exitFullscreen() {
        if (this.hasFullscreenSupport) {
            document.exitFullscreen();
        }
    },

    /**
     * Return a string representing the orientation of the device screen.
     * It can be "any", "natural", "landscape", "portrait", "portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"
     * @function device.getScreenOrientation
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation
     * @returns {string} the screen orientation
     */
    getScreenOrientation() {
        var PORTRAIT = "portrait";
        var LANDSCAPE = "landscape";

        var screen = globalThis.screen;

        // first try using "standard" values
        if (this.ScreenOrientation === true) {
            var orientation = prefixed("orientation", screen);
            if (typeof orientation !== "undefined" && typeof orientation.type === "string") {
                // Screen Orientation API specification
                return orientation.type;
            } else if (typeof orientation === "string") {
                // moz/ms-orientation are strings
                return orientation;
            }
        }

        // check using the deprecated API
        if (typeof globalThis.orientation === "number") {
            return (Math.abs(globalThis.orientation) === 90) ? LANDSCAPE : PORTRAIT;
        }

        // fallback to window size check
        return (globalThis.outerWidth > globalThis.outerHeight) ? LANDSCAPE : PORTRAIT;
    },

    /**
     * locks the device screen into the specified orientation.<br>
     * This method only works for installed Web apps or for Web pages in full-screen mode.
     * @function device.lockOrientation
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation
     * @param {string|string[]} orientation The orientation into which to lock the screen.
     * @returns {boolean} true if the orientation was unsuccessfully locked
     */
    lockOrientation(orientation) {
        var screen = globalThis.screen;
        if (typeof screen !== "undefined") {
            var _lockOrientation = prefixed("lockOrientation", screen);
            if (typeof _lockOrientation !== "undefined") {
                return _lockOrientation(orientation);
            }
        }
        return false;
    },

    /**
     * unlocks the device screen into the specified orientation.<br>
     * This method only works for installed Web apps or for Web pages in full-screen mode.
     * @function device.unlockOrientation
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation
     * @returns {boolean} true if the orientation was unsuccessfully unlocked
     */
    unlockOrientation() {
        var screen = globalThis.screen;
        if (typeof screen !== "undefined") {
            var _unlockOrientation = prefixed("unlockOrientation", screen);
            if (typeof _unlockOrientation !== "undefined") {
                return _unlockOrientation();
            }
        }
        return false;
    },

    /**
     * return true if the device screen orientation is in Portrait mode
     * @function device.isPortrait
     * @returns {boolean}
     */
    isPortrait() {
        return this.getScreenOrientation().includes("portrait");
    },

    /**
     * return true if the device screen orientation is in Portrait mode
     * @function device.isLandscape
     * @returns {boolean}
     */
    isLandscape() {
        return this.getScreenOrientation().includes("landscape");
    },

    /**
     * return the device storage
     * @function device.getStorage
     * @see save
     * @param {string} [type="local"]
     * @returns {object} a reference to the device storage
     */
    getStorage(type = "local") {
        switch (type) {
            case "local" :
                return save;

            default :
                throw new Error("storage type " + type + " not supported");
        }
    },

    /**
     * return the parent DOM element for the given parent name or HTMLElement object
     * @function device.getParentElement
     * @param {string|HTMLElement} element the parent element name or a HTMLElement object
     * @returns {HTMLElement} the parent Element
     */
    getParentElement(element) {
        var target = this.getElement(element);

        if (target.parentNode !== null) {
            target = target.parentNode;
        }

        return target;
    },

    /**
     * return the DOM element for the given element name or HTMLElement object
     * @function device.getElement
     * @param {string|HTMLElement} element the parent element name or a HTMLElement object
     * @returns {HTMLElement} the corresponding DOM Element or null if not existing
     */
    getElement(element) {
        var target = null;

        if (element !== "undefined") {
            if (typeof element === "string") {
                target = document.getElementById(element);
            } else if (typeof element === "object" && element.nodeType === Node.ELEMENT_NODE) {
                target = element;
            }
        }

        // fallback, if invalid target or non HTMLElement object
        if (!target)  {
            //default to document.body
            target = document.body;
        }

        return target;
    },

    /**
     * returns the size of the given HTMLElement and its position relative to the viewport
     * <br><img src="images/element-box-diagram.png"/>
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect
     * @function device.getElementBounds
     * @param {string|HTMLElement} element an HTMLElement object
     * @returns {DOMRect} the size and position of the element relatively to the viewport
     */
    getElementBounds(element) {
        if (typeof element === "object" && element !== document.body && typeof element.getBoundingClientRect !== "undefined") {
            return element.getBoundingClientRect();
        } else {
            _domRect.width = _domRect.right = globalThis.innerWidth;
            _domRect.height = _domRect.bottom = globalThis.innerHeight;
            return _domRect;
        }    },

    /**
     * returns the size of the given HTMLElement Parent and its position relative to the viewport
     * <br><img src="images/element-box-diagram.png"/>
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect
     * @function device.getParentBounds
     * @param {string|HTMLElement} element an HTMLElement object
     * @returns {DOMRect} the size and position of the given element parent relative to the viewport
     */
    getParentBounds(element) {
        return this.getElementBounds(this.getParentElement(element));
    },

    /**
     * returns true if the device supports WebGL
     * @function device.isWebGLSupported
     * @param {object} [options] context creation options
     * @param {boolean} [options.failIfMajorPerformanceCaveat=true] If true, the renderer will switch to CANVAS mode if the performances of a WebGL context would be dramatically lower than that of a native application making equivalent OpenGL calls.
     * @returns {boolean} true if WebGL is supported
     */
    isWebGLSupported(options) {
        var _supported = false;
        try {
            var canvas = document.createElement("canvas");
            var ctxOptions = {
                stencil: true,
                failIfMajorPerformanceCaveat : options.failIfMajorPerformanceCaveat
            };
            _supported = !! (globalThis.WebGLRenderingContext && (canvas.getContext("webgl", ctxOptions) || canvas.getContext("experimental-webgl", ctxOptions)));
        } catch (e) {
            _supported = false;
        }

        return _supported;
    },

    /**
     * return the highest precision format supported by this device for GL Shaders
     * @function device.getMaxShaderPrecision
     * @param {WebGLRenderingContext} gl
     * @returns {boolean} "lowp", "mediump", or "highp"
     */
    getMaxShaderPrecision(gl) {
        if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
            gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0) {
                return "highp";
        }
        if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
            gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0) {
                return "mediump";
        }
        return "lowp";
    },

    /**
     * Makes a request to bring this device window to the front.
     * @function device.focus
     * @example
     *  if (clicked) {
     *    me.device.focus();
     *  }
     */
    focus() {
        if (typeof (globalThis.focus) === "function") {
            globalThis.focus();
        }
    },


    /**
     * event management (Accelerometer)
     * http://www.mobilexweb.com/samples/ball.html
     * http://www.mobilexweb.com/blog/safari-ios-accelerometer-websockets-html5
     * @ignore
     */
    onDeviceMotion(e) {
        // Accelerometer information
        this.accelerationX = e.accelerationIncludingGravity.x;
        this.accelerationY = e.accelerationIncludingGravity.y;
        this.accelerationZ = e.accelerationIncludingGravity.z;
    },

    /**
     * event management (Accelerometer)
     * @ignore
     */
    onDeviceRotate(e) {
        this.gamma = e.gamma;
        this.beta = e.beta;
        this.alpha = e.alpha;
    },

    /**
     * Enable monitor of the device accelerator to detect the amount of physical force of acceleration the device is receiving.
     * (one some device a first user gesture will be required before calling this function)
     * @function device.watchAccelerometer
     * @see device.accelerationX
     * @see device.accelerationY
     * @see device.accelerationZ
     * @returns {boolean} false if not supported or permission not granted by the user
     * @example
     * // try to enable device accelerometer event on user gesture
     * me.input.registerPointerEvent("pointerleave", me.game.viewport, function() {
     *     if (me.device.watchAccelerometer() === true) {
     *         // Success
     *         me.input.releasePointerEvent("pointerleave", me.game.viewport);
     *     } else {
     *         // ... fail at enabling the device accelerometer event
     *     }
     * });
     */
    watchAccelerometer() {
        if (this.hasAccelerometer && !accelInitialized) {
            if (DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === "granted") {
                            // add a listener for the devicemotion event
                            globalThis.addEventListener("devicemotion", this.onDeviceMotion, false);
                            accelInitialized = true;
                        }
                    }).catch(console.error);
            } else {
                // add a listener for the devicemotion event
                globalThis.addEventListener("devicemotion", this.onDeviceMotion, false);
                accelInitialized = true;
            }
        }
        return accelInitialized;
    },

    /**
     * unwatch Accelerometor event
     * @function device.unwatchAccelerometer
     */
    unwatchAccelerometer() {
        if (accelInitialized) {
            // remove the listener for the devicemotion event
            globalThis.removeEventListener("devicemotion", this.onDeviceMotion, false);
            accelInitialized = false;
        }
    },

    /**
     * Enable monitor of the device orientation to detect the current orientation of the device as compared to the Earth coordinate frame.
     * (one some device a first user gesture will be required before calling this function)
     * @function device.watchDeviceOrientation
     * @see device.alpha
     * @see device.beta
     * @see device.gamma
     * @returns {boolean} false if not supported or permission not granted by the user
     * @example
     * // try to enable device orientation event on user gesture
     * me.input.registerPointerEvent("pointerleave", me.game.viewport, function() {
     *     if (me.device.watchDeviceOrientation() === true) {
     *         // Success
     *         me.input.releasePointerEvent("pointerleave", me.game.viewport);
     *     } else {
     *         // ... fail at enabling the device orientation event
     *     }
     * });
     */
    watchDeviceOrientation() {
        if (this.hasDeviceOrientation && !deviceOrientationInitialized) {
            if (typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === "granted") {
                            globalThis.addEventListener("deviceorientation", this.onDeviceRotate, false);
                            deviceOrientationInitialized = true;
                        }
                    }).catch(console.error);
            } else {
                globalThis.addEventListener("deviceorientation", this.onDeviceRotate, false);
                deviceOrientationInitialized = true;
            }
        }
        return deviceOrientationInitialized;
    },

    /**
     * unwatch Device orientation event
     * @function device.unwatchDeviceOrientation
     */
    unwatchDeviceOrientation() {
        if (deviceOrientationInitialized) {
            globalThis.removeEventListener("deviceorientation", this.onDeviceRotate, false);
            deviceOrientationInitialized = false;
        }
    },

    /**
     * the vibrate method pulses the vibration hardware on the device, <br>
     * If the device doesn't support vibration, this method has no effect. <br>
     * If a vibration pattern is already in progress when this method is called,
     * the previous pattern is halted and the new one begins instead.
     * @function device.vibrate
     * @param {number|number[]} pattern pattern of vibration and pause intervals
     * @example
     * // vibrate for 1000 ms
     * me.device.vibrate(1000);
     * // or alternatively
     * me.device.vibrate([1000]);
     * // vibrate for 50 ms, be still for 100 ms, and then vibrate for 150 ms:
     * me.device.vibrate([50, 100, 150]);
     * // cancel any existing vibrations
     * me.device.vibrate(0);
     */
    vibrate(pattern) {
        if (typeof globalThis.navigator !== "undefined" && typeof globalThis.navigator.vibrate === "function") {
            globalThis.navigator.vibrate(pattern);
        }
    }

};

/**
 * Ratio of the resolution in physical pixels to the resolution in CSS pixels for the current display device.
 * @name device.devicePixelRatio
 * @public
 * @member {number}
 * @readonly
 * @returns {number}
 */
Object.defineProperty(device, "devicePixelRatio", {
    /**
     * @ignore
     */
    get: function () {
        return (globalThis.devicePixelRatio || 1);
    }
});

/**
 * Returns true if the browser/device is in full screen mode.
 * @name device.isFullscreen
 * @public
 * @member {boolean}
 * @readonly
 * @returns {boolean}
 */
Object.defineProperty(device, "isFullscreen", {
    /**
     * @ignore
     */
    get: function () {
        if (this.hasFullscreenSupport) {
            return !!(prefixed("fullscreenElement", document) ||
                document.mozFullScreenElement);
        } else {
            return false;
        }
    }
});

/**
 * Returns true if the browser/device has audio capabilities.
 * @name device.sound
 * @public
 * @member {boolean}
 * @readonly
 * @returns {boolean}
 */
Object.defineProperty(device, "sound", {
    /**
     * @ignore
     */
    get: function () {
        return hasAudio();
    }
});

/**
 * Hash map of GLSL data types to WebGL Uniform methods
 * @ignore
 */
const fnHash = {
    "bool"      : "1i",
    "int"       : "1i",
    "float"     : "1f",
    "vec2"      : "2fv",
    "vec3"      : "3fv",
    "vec4"      : "4fv",
    "bvec2"     : "2iv",
    "bvec3"     : "3iv",
    "bvec4"     : "4iv",
    "ivec2"     : "2iv",
    "ivec3"     : "3iv",
    "ivec4"     : "4iv",
    "mat2"      : "Matrix2fv",
    "mat3"      : "Matrix3fv",
    "mat4"      : "Matrix4fv",
    "sampler2D" : "1i"
};

/**
 * @ignore
 */
function extractUniforms(gl, shader) {
    var uniforms = {},
        uniRx = /uniform\s+(\w+)\s+(\w+)/g,
        uniformsData = {},
        descriptor = {},
        locations = {},
        match;

    // Detect all uniform names and types
    [ shader.vertex, shader.fragment ].forEach(function (shader) {
        while ((match = uniRx.exec(shader))) {
            uniformsData[match[2]] = match[1];
        }
    });

    // Get uniform references
    Object.keys(uniformsData).forEach(function (name) {
        var type = uniformsData[name];
        locations[name] = gl.getUniformLocation(shader.program, name);

        descriptor[name] = {
            "get" : (function (name) {
                /*
                 * A getter for the uniform location
                 */
                return function () {
                    return locations[name];
                };
            })(name),
            "set" : (function (name, type, fn) {
                if (type.indexOf("mat") === 0) {
                    /*
                     * A generic setter for uniform matrices
                     */
                    return function (val) {
                        gl[fn](locations[name], false, val);
                    };
                }
                else {
                    /*
                     * A generic setter for uniform vectors
                     */
                    return function (val) {
                        var fnv = fn;
                        if (val.length && fn.slice(-1) !== "v") {
                            fnv += "v";
                        }
                        gl[fnv](locations[name], val);
                    };
                }
            })(name, type, "uniform" + fnHash[type])
        };
    });
    Object.defineProperties(uniforms, descriptor);

    return uniforms;
}

/**
 * @ignore
 */
function extractAttributes(gl, shader) {
    var attributes = {},
        attrRx = /attribute\s+\w+\s+(\w+)/g,
        match,
        i = 0;

    // Detect all attribute names
    while ((match = attrRx.exec(shader.vertex))) {
        attributes[match[1]] = i++;
    }

    return attributes;
}

/**
 * @ignore
 */
function compileShader(gl, type, source) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
    }

    return shader;
}
/**
 * Compile GLSL into a shader object
 * @ignore
 */
function compileProgram(gl, vertex, fragment, attributes) {
    var vertShader = compileShader(gl, gl.VERTEX_SHADER, vertex);
    var fragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragment);

    var program = gl.createProgram();

    gl.attachShader(program, vertShader);
    gl.attachShader(program, fragShader);


    // force vertex attributes to use location 0 as starting location to prevent
    // browser to do complicated emulation when running on desktop OpenGL (e.g. on macOS)
    for (var location in attributes) {
        gl.bindAttribLocation(program, attributes[location], location);
    }

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var error_msg =
            "Error initializing Shader " + this + "\n" +
            "gl.VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n" +
            "gl.getError()" + gl.getError() + "\n" +
            "gl.getProgramInfoLog()" + gl.getProgramInfoLog(program);
        // house cleaning
        gl.deleteProgram(program);
        program = null;
        // throw the exception
        throw new Error(error_msg);
    }

    gl.useProgram(program);

    // clean-up
    gl.deleteShader(vertShader);
    gl.deleteShader(fragShader);

    return program;
}

/**
 * set precision for the fiven shader source
 * won't do anything if the precision is already specified
 * @ignore
 */
function setPrecision(src, precision) {
    if (src.substring(0, 9) !== "precision") {
        return "precision " + precision + " float;" + src;
    }
    return src;
}

/**
 * clean the given source from space, comments, etc...
 * @ignore
 */
function minify(src) {
    // remove comments
    src = src.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "$1");
    // Remove leading and trailing whitespace from lines
    src = src.replace(/(\\n\s+)|(\s+\\n)/g, "");
    // Remove line breaks
    src = src.replace(/(\\r|\\n)+/g, "");
    // Remove unnecessary whitespace
    src = src.replace(/\s*([;,[\](){}\\\/\-+*|^&!=<>?~%])\s*/g, "$1");

    return src;
}

/**
 * @classdesc
 * a base GL Shader object
 */
class GLShader {
    /**
     * @param {WebGLRenderingContext} gl the current WebGL rendering context
     * @param {string} vertex a string containing the GLSL source code to set
     * @param {string} fragment a string containing the GLSL source code to set
     * @param {string} [precision=auto detected] float precision ('lowp', 'mediump' or 'highp').
     * @see https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders
     * @example
     * // create a basic shader
     * var myShader = new me.GLShader(
     *    // WebGL rendering context
     *    gl,
     *    // vertex shader
     *    [
     *        "void main() {",
     *        "    gl_Position = doMathToMakeClipspaceCoordinates;",
     *        "}"
     *    ].join("\n"),
     *    // fragment shader
     *    [
     *        "void main() {",
     *        "    gl_FragColor = doMathToMakeAColor;",
     *        "}"
     *    ].join("\n")
     *  )
     * // use the shader
     * myShader.bind();
     */
    constructor(gl, vertex, fragment, precision) {

        /**
         * the active gl rendering context
         * @public
         * @type {WebGLRenderingContext}
         * @name gl
         * @memberof GLShader
         */
        this.gl = gl;

        /**
         * the vertex shader source code
         * @public
         * @type {string}
         * @name vertex
         * @memberof GLShader
         */
        this.vertex = setPrecision(minify(vertex), precision || device.getMaxShaderPrecision(this.gl));

        /**
         * the fragment shader source code
         * @public
         * @type {string}
         * @name vertex
         * @memberof GLShader
         */
        this.fragment = setPrecision(minify(fragment), precision || device.getMaxShaderPrecision(this.gl));

        /**
         * the location attributes of the shader
         * @public
         * @type {GLint[]}
         * @name attributes
         * @memberof GLShader
         */
        this.attributes = extractAttributes(this.gl, this);


        /**
         * a reference to the shader program (once compiled)
         * @public
         * @type {WebGLProgram}
         * @name program
         * @memberof GLShader
         */
        this.program = compileProgram(this.gl, this.vertex, this.fragment, this.attributes);

        /**
         * the uniforms of the shader
         * @public
         * @type {object}
         * @name uniforms
         * @memberof GLShader
         */
        this.uniforms = extractUniforms(this.gl, this);

        // destroy the shader on context lost (will be recreated on context restore)
        on(ONCONTEXT_LOST, this.destroy, this);
    }

    /**
     * Installs this shader program as part of current rendering state
     * @name bind
     * @memberof GLShader
     */
    bind() {
        this.gl.useProgram(this.program);
    }

    /**
     * returns the location of an attribute variable in this shader program
     * @name getAttribLocation
     * @memberof GLShader
     * @param {string} name the name of the attribute variable whose location to get.
     * @returns {GLint} number indicating the location of the variable name if found. Returns -1 otherwise
     */
    getAttribLocation(name) {
        var attr = this.attributes[name];
        if (typeof attr !== "undefined") {
            return attr;
        } else {
            return -1;
        }
    }

    /**
     * Set the uniform to the given value
     * @name setUniform
     * @memberof GLShader
     * @param {string} name the uniform name
     * @param {object|Float32Array} value the value to assign to that uniform
     * @example
     * myShader.setUniform("uProjectionMatrix", this.projectionMatrix);
     */
    setUniform(name, value) {
        var uniforms = this.uniforms;
        if (typeof uniforms[name] !== "undefined") {
            if (typeof value === "object" && typeof value.toArray === "function") {
                uniforms[name] = value.toArray();
            } else {
                uniforms[name] = value;
            }
        } else {
            throw new Error("undefined (" + name + ") uniform for shader " + this);
        }
    }

    /**
     * activate the given vertex attribute for this shader
     * @name setVertexAttributes
     * @memberof GLShader
     * @param {WebGLRenderingContext} gl the current WebGL rendering context
     * @param {object[]} attributes an array of vertex attributes
     * @param {number} vertexByteSize the size of a single vertex in bytes
     */
    setVertexAttributes(gl, attributes, vertexByteSize) {
        // set the vertex attributes
        for (var index = 0; index < attributes.length; ++index) {
            var element = attributes[index];
            var location = this.getAttribLocation(element.name);

            if (location !== -1) {
                gl.enableVertexAttribArray(location);
                gl.vertexAttribPointer(location, element.size, element.type, element.normalized, vertexByteSize, element.offset);
            } else {
                gl.disableVertexAttribArray(index);
            }
        }
    }

    /**
     * destroy this shader objects resources (program, attributes, uniforms)
     * @name destroy
     * @memberof GLShader
     */
    destroy() {
        this.uniforms = null;
        this.attributes = null;

        this.gl.deleteProgram(this.program);

        this.vertex = null;
        this.fragment = null;
    }
}

/**
 * @classdesc
 * a Vertex Buffer object
 * @class VertexArrayBuffer
 * @ignore
 */

class VertexArrayBuffer {

    constructor(vertex_size, vertex_per_quad) {
        // the size of one vertex in float
        this.vertexSize = vertex_size;
        // size of a quad in vertex
        this.quadSize = vertex_per_quad;
        // the maximum number of vertices the vertex array buffer can hold
        this.maxVertex = 256;
        // the current number of vertices added to the vertex array buffer
        this.vertexCount = 0;

        // the actual vertex data buffer
        this.buffer = new ArrayBuffer(this.maxVertex * this.vertexSize * this.quadSize);
        // Float32 and Uint32 view of the vertex data array buffer
        this.bufferF32 = new Float32Array(this.buffer);
        this.bufferU32 = new Uint32Array(this.buffer);
    }

    /**
     * clear the vertex array buffer
     * @ignore
     */
    clear() {
        this.vertexCount = 0;
    }


    /**
     * return true if full
     * @ignore
     */
    isFull(vertex = this.quadSize) {
         return (this.vertexCount + vertex >= this.maxVertex);
    }

    /**
     * resize the vertex buffer, retaining its original contents
     * @ignore
     */
    resize() {
        // double the vertex size
        this.maxVertex <<= 1;
        // save a reference to the previous data
        var data = this.bufferF32;

        // recreate ArrayBuffer and views
        this.buffer = new ArrayBuffer(this.maxVertex * this.vertexSize * this.quadSize);
        this.bufferF32 = new Float32Array(this.buffer);
        this.bufferU32 = new Uint32Array(this.buffer);

        // copy previous data
        this.bufferF32.set(data);

        return this;
    }

    /**
     * push a new vertex to the buffer
     * @ignore
     */
    push(x, y, u, v, tint) {
        var offset = this.vertexCount * this.vertexSize;

        if (this.vertexCount >= this.maxVertex) {
            this.resize();
        }

        this.bufferF32[offset + 0] = x;
        this.bufferF32[offset + 1] = y;

        if (typeof u !== "undefined") {
            this.bufferF32[offset + 2] = u;
            this.bufferF32[offset + 3] = v;
        }

        if (typeof tint !== "undefined") {
            this.bufferU32[offset + 4] = tint;
        }

        this.vertexCount++;

        return this;
    }

    /**
     * return a reference to the data in Float32 format
     * @ignore
     */
    toFloat32(begin, end) {
        if (typeof end !== "undefined") {
            return this.bufferF32.subarray(begin, end);
        } else {
            return this.bufferF32;
        }
    }

    /**
     * return a reference to the data in Uint32 format
     * @ignore
     */
    toUint32(begin, end) {
        if (typeof end !== "undefined") {
            return this.bufferU32.subarray(begin, end);
        } else {
            return this.bufferU32;
        }
    }

    /**
     * return the size of the vertex in vertex
     * @ignore
     */
    length() {
        return this.vertexCount;
    }

    /**
     * return true if empty
     * @ignore
     */
    isEmpty() {
        return this.vertexCount === 0;
    }

}

var primitiveVertex = "// Current vertex point\nattribute vec2 aVertex;\n\n// Projection matrix\nuniform mat4 uProjectionMatrix;\n\n// Vertex color\nuniform vec4 uColor;\n\n// Fragment color\nvarying vec4 vColor;\n\nvoid main(void) {\n    // Transform the vertex position by the projection matrix\n    gl_Position = uProjectionMatrix * vec4(aVertex, 0.0, 1.0);\n    // Pass the remaining attributes to the fragment shader\n    vColor = vec4(uColor.rgb * uColor.a, uColor.a);\n}\n";

var primitiveFragment = "varying vec4 vColor;\n\nvoid main(void) {\n    gl_FragColor = vColor;\n}\n";

var quadVertex = "attribute vec2 aVertex;\nattribute vec2 aRegion;\nattribute vec4 aColor;\n\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vRegion;\nvarying vec4 vColor;\n\nvoid main(void) {\n    // Transform the vertex position by the projection matrix\n     gl_Position = uProjectionMatrix * vec4(aVertex, 0.0, 1.0);\n    // Pass the remaining attributes to the fragment shader\n    vColor = vec4(aColor.bgr * aColor.a, aColor.a);\n    vRegion = aRegion;\n}\n";

var quadFragment = "uniform sampler2D uSampler;\nvarying vec4 vColor;\nvarying vec2 vRegion;\n\nvoid main(void) {\n    gl_FragColor = texture2D(uSampler, vRegion) * vColor;\n}\n";

// a pool of resuable vectors
var V_ARRAY = [
    new Vector2d(),
    new Vector2d(),
    new Vector2d(),
    new Vector2d()
];

/**
 * @classdesc
 * A WebGL Compositor object. This class handles all of the WebGL state<br>
 * Pushes texture regions or shape geometry into WebGL buffers, automatically flushes to GPU
 */
class WebGLCompositor {
    /**
     * @param {WebGLRenderer} renderer the current WebGL renderer session
     */
    constructor (renderer) {
        this.init(renderer);
    }

    /**
     * Initialize the compositor
     * @ignore
     */
    init (renderer) {
        // local reference
        var gl = renderer.gl;

        // list of active texture units
        this.currentTextureUnit = -1;
        this.boundTextures = [];

        // the associated renderer
        this.renderer = renderer;

        // WebGL context
        this.gl = renderer.gl;

        // Global fill color
        this.color = renderer.currentColor;

        // Global transformation matrix
        this.viewMatrix = renderer.currentTransform;

        /**
         * a reference to the active WebGL shader
         * @name activeShader
         * @memberof WebGLCompositor
         * @type {GLShader}
         */
        this.activeShader = null;

        /**
         * primitive type to render (gl.POINTS, gl.LINE_STRIP, gl.LINE_LOOP, gl.LINES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN, gl.TRIANGLES)
         * @name mode
         * @see WebGLCompositor
         * @memberof WebGLCompositor
         * @default gl.TRIANGLES
         */
        this.mode = gl.TRIANGLES;

        /**
         * an array of vertex attribute properties
         * @name attributes
         * @see WebGLCompositor.addAttribute
         * @memberof WebGLCompositor
         */
        this.attributes = [];

        /**
         * the size of a single vertex in bytes
         * (will automatically be calculated as attributes definitions are added)
         * @name vertexByteSize
         * @see WebGLCompositor.addAttribute
         * @memberof WebGLCompositor
         */
        this.vertexByteSize = 0;

        /**
         * the size of a single vertex in floats
         * (will automatically be calculated as attributes definitions are added)
         * @name vertexSize
         * @see WebGLCompositor.addAttribute
         * @memberof WebGLCompositor
         */
        this.vertexSize = 0;

        // Load and create shader programs
        this.primitiveShader = new GLShader(this.gl, primitiveVertex, primitiveFragment);
        this.quadShader = new GLShader(this.gl, quadVertex, quadFragment);

        /// define all vertex attributes
        this.addAttribute("aVertex", 2, gl.FLOAT, false, 0 * Float32Array.BYTES_PER_ELEMENT); // 0
        this.addAttribute("aRegion", 2, gl.FLOAT, false, 2 * Float32Array.BYTES_PER_ELEMENT); // 1
        this.addAttribute("aColor",  4, gl.UNSIGNED_BYTE, true, 4 * Float32Array.BYTES_PER_ELEMENT); // 2

        this.vertexBuffer = new VertexArrayBuffer(this.vertexSize, 6); // 6 vertices per quad

        // vertex buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, this.vertexBuffer.buffer, gl.STREAM_DRAW);

        // register to the CANVAS resize channel
        on(CANVAS_ONRESIZE, (width, height) => {
            this.flush();
            this.setViewport(0, 0, width, height);
        });
    }

    /**
     * Reset compositor internal state
     * @ignore
     */
    reset() {
        // WebGL context
        this.gl = this.renderer.gl;

        this.flush();

        // initial viewport size
        this.setViewport(
            0, 0,
            this.renderer.getScreenCanvas().width,
            this.renderer.getScreenCanvas().height
        );

        // Initialize clear color
        this.clearColor(0.0, 0.0, 0.0, 0.0);

        // delete all related bound texture
        for (var i = 0; i < this.renderer.maxTextures; i++) {
            var texture2D = this.getTexture2D(i);
            if (typeof texture2D !== "undefined") {
                this.deleteTexture2D(texture2D);
            }
        }
        this.currentTextureUnit = -1;

        // set the quad shader as the default program
        this.useShader(this.quadShader);
    }

    /**
     * add vertex attribute property definition to the compositor
     * @name addAttribute
     * @memberof WebGLCompositor
     * @param {string} name name of the attribute in the vertex shader
     * @param {number} size number of components per vertex attribute. Must be 1, 2, 3, or 4.
     * @param {GLenum} type data type of each component in the array
     * @param {boolean} normalized whether integer data values should be normalized into a certain range when being cast to a float
     * @param {number} offset offset in bytes of the first component in the vertex attribute array
     */
    addAttribute(name, size, type, normalized, offset) {
        this.attributes.push({
            name: name,
            size: size,
            type: type,
            normalized: normalized,
            offset: offset
        });

        switch (type) {
            case this.gl.BYTE:
                this.vertexByteSize += size * Int8Array.BYTES_PER_ELEMENT;
                break;
            case this.gl.UNSIGNED_BYTE:
                this.vertexByteSize += size * Uint8Array.BYTES_PER_ELEMENT;
                break;
            case this.gl.SHORT:
                this.vertexByteSize += size * Int16Array.BYTES_PER_ELEMENT;
                break;
            case this.gl.UNSIGNED_SHORT:
                this.vertexByteSize += size * Uint16Array.BYTES_PER_ELEMENT;
                break;
            case this.gl.INT:
                this.vertexByteSize += size * Int32Array.BYTES_PER_ELEMENT;
                break;
            case this.gl.UNSIGNED_INT:
                this.vertexByteSize += size * Uint32Array.BYTES_PER_ELEMENT;
                break;
            case this.gl.FLOAT:
                this.vertexByteSize += size * Float32Array.BYTES_PER_ELEMENT;
                break;
            default:
                throw new Error("Invalid GL Attribute type");
        }
        this.vertexSize = this.vertexByteSize / Float32Array.BYTES_PER_ELEMENT;
    }

    /**
     * Sets the viewport
     * @name setViewport
     * @memberof WebGLCompositor
     * @param {number} x x position of viewport
     * @param {number} y y position of viewport
     * @param {number} w width of viewport
     * @param {number} h height of viewport
     */
    setViewport(x, y, w, h) {
        this.gl.viewport(x, y, w, h);
    }

    /**
     * Create a WebGL texture from an image
     * @name createTexture2D
     * @memberof WebGLCompositor
     * @param {number} unit Destination texture unit
     * @param {Image|HTMLCanvasElement|ImageData|Uint8Array[]|Float32Array[]} image Source image
     * @param {number} filter gl.LINEAR or gl.NEAREST
     * @param {string} [repeat="no-repeat"] Image repeat behavior (see {@link ImageLayer#repeat})
     * @param {number} [w] Source image width (Only use with UInt8Array[] or Float32Array[] source image)
     * @param {number} [h] Source image height (Only use with UInt8Array[] or Float32Array[] source image)
     * @param {number} [b] Source image border (Only use with UInt8Array[] or Float32Array[] source image)
     * @param {boolean} [premultipliedAlpha=true] Multiplies the alpha channel into the other color channels
     * @param {boolean} [mipmap=true] Whether mipmap levels should be generated for this texture
     * @returns {WebGLTexture} a WebGL texture
     */
    createTexture2D(unit, image, filter, repeat = "no-repeat", w, h, b, premultipliedAlpha = true, mipmap = true) {
        var gl = this.gl;
        var isPOT = isPowerOfTwo(w || image.width) && isPowerOfTwo(h || image.height);
        var texture = gl.createTexture();
        var rs = (repeat.search(/^repeat(-x)?$/) === 0) && (isPOT || this.renderer.WebGLVersion > 1) ? gl.REPEAT : gl.CLAMP_TO_EDGE;
        var rt = (repeat.search(/^repeat(-y)?$/) === 0) && (isPOT || this.renderer.WebGLVersion > 1) ? gl.REPEAT : gl.CLAMP_TO_EDGE;

        this.bindTexture2D(texture, unit);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, rs);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, rt);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
        if (w || h || b) {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, b, gl.RGBA, gl.UNSIGNED_BYTE, image);
        }
        else {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        }

        // generate the sprite mimap (used when scaling) if a PowerOfTwo texture
        if (isPOT && mipmap !== false) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }

        return texture;
    }

    /**
     * delete the given WebGL texture
     * @name bindTexture2D
     * @memberof WebGLCompositor
     * @param {WebGLTexture} [texture] a WebGL texture to delete
     * @param {number} [unit] Texture unit to delete
     */
    deleteTexture2D(texture) {
        this.gl.deleteTexture(texture);
        this.unbindTexture2D(texture);
    }

    /**
     * returns the WebGL texture associated to the given texture unit
     * @name bindTexture2D
     * @memberof WebGLCompositor
     * @param {number} unit Texture unit to which a texture is bound
     * @returns {WebGLTexture} texture a WebGL texture
     */
    getTexture2D(unit) {
        return this.boundTextures[unit];
    }

    /**
     * assign the given WebGL texture to the current batch
     * @name bindTexture2D
     * @memberof WebGLCompositor
     * @param {WebGLTexture} texture a WebGL texture
     * @param {number} unit Texture unit to which the given texture is bound
     */
    bindTexture2D(texture, unit) {
        var gl = this.gl;

        if (texture !== this.boundTextures[unit]) {
            this.flush();
            if (this.currentTextureUnit !== unit) {
                this.currentTextureUnit = unit;
                gl.activeTexture(gl.TEXTURE0 + unit);
            }

            gl.bindTexture(gl.TEXTURE_2D, texture);
            this.boundTextures[unit] = texture;

        } else if (this.currentTextureUnit !== unit) {
            this.flush();
            this.currentTextureUnit = unit;
            gl.activeTexture(gl.TEXTURE0 + unit);
        }
    }

    /**
     * unbind the given WebGL texture, forcing it to be reuploaded
     * @name unbindTexture2D
     * @memberof WebGLCompositor
     * @param {WebGLTexture} [texture] a WebGL texture
     * @param {number} [unit] a WebGL texture
     * @returns {number} unit the unit number that was associated with the given texture
     */
    unbindTexture2D(texture, unit) {
        if (typeof unit === "undefined") {
            unit = this.boundTextures.indexOf(texture);
        }
        if (unit !== -1) {
            delete this.boundTextures[unit];
            if (unit === this.currentTextureUnit) {
                this.currentTextureUnit = -1;
            }
        }
        return unit;
    }

    /**
     * @ignore
     */
    uploadTexture(texture, w, h, b, force = false) {
        var unit = this.renderer.cache.getUnit(texture);
        var texture2D = this.boundTextures[unit];

        if (typeof texture2D === "undefined" || force) {
            this.createTexture2D(
                unit,
                texture.getTexture(),
                this.renderer.settings.antiAlias ? this.gl.LINEAR : this.gl.NEAREST,
                texture.repeat,
                w,
                h,
                b,
                texture.premultipliedAlpha
            );
        } else {
            this.bindTexture2D(texture2D, unit);
        }

        return this.currentTextureUnit;
    }

    /**
     * set/change the current projection matrix
     * @name setProjection
     * @memberof WebGLCompositor
     * @param {Matrix3d} matrix
     */
    setProjection(matrix) {
        this.activeShader.setUniform("uProjectionMatrix", matrix);
    }

    /**
     * Select the shader to use for compositing
     * @name useShader
     * @see GLShader
     * @memberof WebGLCompositor
     * @param {GLShader} shader a reference to a GLShader instance
     */
    useShader(shader) {
        if (this.activeShader !== shader) {
            this.flush();
            this.activeShader = shader;
            this.activeShader.bind();
            this.activeShader.setUniform("uProjectionMatrix", this.renderer.projectionMatrix);
            this.activeShader.setVertexAttributes(this.gl, this.attributes, this.vertexByteSize);
        }
    }

    /**
     * Add a textured quad
     * @name addQuad
     * @memberof WebGLCompositor
     * @param {TextureAtlas} texture Source texture atlas
     * @param {number} x Destination x-coordinate
     * @param {number} y Destination y-coordinate
     * @param {number} w Destination width
     * @param {number} h Destination height
     * @param {number} u0 Texture UV (u0) value.
     * @param {number} v0 Texture UV (v0) value.
     * @param {number} u1 Texture UV (u1) value.
     * @param {number} v1 Texture UV (v1) value.
     * @param {number} tint tint color to be applied to the texture in UINT32 (argb) format
     */
    addQuad(texture, x, y, w, h, u0, v0, u1, v1, tint) {

        if (this.color.alpha < 1 / 255) {
            // Fast path: don't send fully transparent quads
            return;
        }

        this.useShader(this.quadShader);

        if (this.vertexBuffer.isFull(6)) {
            // is the vertex buffer full if we add 6 more vertices
            this.flush();
        }

        // upload and activate the texture if necessary
        var unit = this.uploadTexture(texture);
        // set fragement sampler accordingly
        this.quadShader.setUniform("uSampler", unit);

        // Transform vertices
        var m = this.viewMatrix,
            vec0 = V_ARRAY[0].set(x, y),
            vec1 = V_ARRAY[1].set(x + w, y),
            vec2 = V_ARRAY[2].set(x, y + h),
            vec3 = V_ARRAY[3].set(x + w, y + h);

        if (!m.isIdentity()) {
            m.apply(vec0);
            m.apply(vec1);
            m.apply(vec2);
            m.apply(vec3);
        }

        this.vertexBuffer.push(vec0.x, vec0.y, u0, v0, tint);
        this.vertexBuffer.push(vec1.x, vec1.y, u1, v0, tint);
        this.vertexBuffer.push(vec2.x, vec2.y, u0, v1, tint);
        this.vertexBuffer.push(vec2.x, vec2.y, u0, v1, tint);
        this.vertexBuffer.push(vec1.x, vec1.y, u1, v0, tint);
        this.vertexBuffer.push(vec3.x, vec3.y, u1, v1, tint);
    }

    /**
     * Flush batched texture operations to the GPU
     * @param {number} [mode=gl.TRIANGLES] the GL drawing mode
     * @memberof WebGLCompositor
     */
    flush(mode = this.mode) {
        var vertex = this.vertexBuffer;
        var vertexCount = vertex.vertexCount;

        if (vertexCount > 0) {
            var gl = this.gl;
            var vertexSize = vertex.vertexSize;

            // Copy data into stream buffer
            if (this.renderer.WebGLVersion > 1) {
                gl.bufferData(gl.ARRAY_BUFFER, vertex.toFloat32(), gl.STREAM_DRAW, 0, vertexCount * vertexSize);
            } else {
                gl.bufferData(gl.ARRAY_BUFFER, vertex.toFloat32(0, vertexCount * vertexSize), gl.STREAM_DRAW);
            }

            gl.drawArrays(mode, 0, vertexCount);

            // clear the vertex buffer
            vertex.clear();
        }
    }

    /**
     * Draw an array of vertices
     * @name drawVertices
     * @memberof WebGLCompositor
     * @param {GLenum} mode primitive type to render (gl.POINTS, gl.LINE_STRIP, gl.LINE_LOOP, gl.LINES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN, gl.TRIANGLES)
     * @param {Vector2d[]} verts vertices
     * @param {number} [vertexCount=verts.length] amount of points defined in the points array
     */
    drawVertices(mode, verts, vertexCount = verts.length) {
        // use the primitive shader
        this.useShader(this.primitiveShader);
        // Set the line color
        this.primitiveShader.setUniform("uColor", this.color);

        var m = this.viewMatrix;
        var vertex = this.vertexBuffer;
        var m_isIdentity = m.isIdentity();

        for (var i = 0; i < vertexCount; i++) {
            if (!m_isIdentity) {
                m.apply(verts[i]);
            }
            vertex.push(verts[i].x, verts[i].y);
        }

        // flush
        this.flush(mode);
    }

    /**
     * Specify the color values used when clearing color buffers. The values are clamped between 0 and 1.
     * @name clearColor
     * @memberof WebGLCompositor
     * @param {number} [r=0] - the red color value used when the color buffers are cleared
     * @param {number} [g=0] - the green color value used when the color buffers are cleared
     * @param {number} [b=0] - the blue color value used when the color buffers are cleared
     * @param {number} [a=0] - the alpha color value used when the color buffers are cleared
     */
    clearColor(r, g, b, a) {
        this.gl.clearColor(r, g, b, a);
    }

    /**
     * Clear the frame buffer
     * @name clear
     * @memberof WebGLCompositor
     */
    clear() {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    }
}

/**
 * @classdesc
 * a WebGL renderer object
 * @augments Renderer
 */
class WebGLRenderer extends Renderer {
    /**
     * @param {object} options The renderer parameters
     * @param {number} options.width The width of the canvas without scaling
     * @param {number} options.height The height of the canvas without scaling
     * @param {HTMLCanvasElement} [options.canvas] The html canvas to draw to on screen
     * @param {boolean} [options.doubleBuffering=false] Whether to enable double buffering
     * @param {boolean} [options.antiAlias=false] Whether to enable anti-aliasing
     * @param {boolean} [options.failIfMajorPerformanceCaveat=true] If true, the renderer will switch to CANVAS mode if the performances of a WebGL context would be dramatically lower than that of a native application making equivalent OpenGL calls.
     * @param {boolean} [options.transparent=false] Whether to enable transparency on the canvas (performance hit when enabled)
     * @param {boolean} [options.subPixel=false] Whether to enable subpixel renderering (performance hit when enabled)
     * @param {boolean} [options.preferWebGL1=false] if true the renderer will only use WebGL 1
     * @param {string} [options.powerPreference="default"] a hint to the user agent indicating what configuration of GPU is suitable for the WebGL context ("default", "high-performance", "low-power"). To be noted that Safari and Chrome (since version 80) both default to "low-power" to save battery life and improve the user experience on these dual-GPU machines.
     * @param {number} [options.zoomX=width] The actual width of the canvas with scaling applied
     * @param {number} [options.zoomY=height] The actual height of the canvas with scaling applied
     * @param {WebGLCompositor} [options.compositor] A class that implements the compositor API
     */
    constructor(options) {

        // parent contructor
        super(options);

        /**
         * The WebGL version used by this renderer (1 or 2)
         * @name WebGLVersion
         * @memberof WebGLRenderer#
         * @type {number}
         * @default 1
         * @readonly
         */
        this.WebGLVersion = 1;

        /**
         * The vendor string of the underlying graphics driver.
         * @name GPUVendor
         * @memberof WebGLRenderer#
         * @type {string}
         * @default null
         * @readonly
         */
        this.GPUVendor = null;

        /**
         * The renderer string of the underlying graphics driver.
         * @name GPURenderer
         * @memberof WebGLRenderer#
         * @type {string}
         * @default null
         * @readonly
         */
        this.GPURenderer = null;

        /**
         * The WebGL context
         * @name gl
         * @memberof WebGLRenderer
         * @type {WebGLRenderingContext}
         */
        this.context = this.gl = this.getContextGL(this.getScreenCanvas(), options.transparent);

        /**
         * Maximum number of texture unit supported under the current context
         * @name maxTextures
         * @memberof WebGLRenderer#
         * @type {number}
         * @readonly
         */
        this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);

        /**
         * @ignore
         */
        this._colorStack = [];

        /**
         * @ignore
         */
        this._matrixStack = [];

        /**
         * @ignore
         */
        this._scissorStack = [];

        /**
         * @ignore
         */
        this._blendStack = [];

        /**
         * The current transformation matrix used for transformations on the overall scene
         * @name currentTransform
         * @type {Matrix2d}
         * @memberof WebGLRenderer#
         */
        this.currentTransform = new Matrix2d();

        /**
         * The current compositor used by the renderer
         * @name currentCompositor
         * @type {WebGLCompositor}
         * @memberof WebGLRenderer#
         */
        this.currentCompositor = null;

        /**
         * The list of active compositors
         * @name compositors
         * @type {Map<WebGLCompositor>}
         * @memberof WebGLRenderer#
         */
        this.compositors = new Map();

        // Create a default compositor
        var compositor = new (this.settings.compositor || WebGLCompositor)(this);
        this.compositors.set("default", compositor);
        this.setCompositor(compositor);


        // default WebGL state(s)
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.disable(this.gl.SCISSOR_TEST);
        this.gl.enable(this.gl.BLEND);

        // set default mode
        this.setBlendMode(this.settings.blendMode);

        // get GPU vendor and renderer
        var debugInfo = this.gl.getExtension("WEBGL_debug_renderer_info");
        if (debugInfo !== null) {
            this.GPUVendor = this.gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
            this.GPURenderer = this.gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
        }

        // Create a texture cache
        this.cache = new TextureCache(this.maxTextures);

        // to simulate context lost and restore in WebGL:
        // var ctx = me.video.renderer.context.getExtension('WEBGL_lose_context');
        // ctx.loseContext()
        this.getScreenCanvas().addEventListener("webglcontextlost", (e) => {
            e.preventDefault();
            this.isContextValid = false;
            emit(ONCONTEXT_LOST, this);
        }, false );
        // ctx.restoreContext()
        this.getScreenCanvas().addEventListener("webglcontextrestored", () => {
            this.reset();
            this.isContextValid = true;
            emit(ONCONTEXT_RESTORED, this);
        }, false );
    }

    /**
     * Reset context state
     * @name reset
     * @memberof WebGLRenderer
     */
    reset() {
        super.reset();

        this.compositors.forEach((compositor) => {
            if (this.isContextValid === false) {
                // on context lost/restore
                compositor.init(this);
            } else {
                compositor.reset();
            }
        });

        this.gl.disable(this.gl.SCISSOR_TEST);
        if (typeof this.fontContext2D !== "undefined" ) {
            this.createFontTexture(this.cache);
        }

    }

    /**
     * set the active compositor for this renderer
     * @name setCompositor
     * @param {WebGLCompositor|string} compositor a compositor name or instance
     * @memberof WebGLRenderer
     */
    setCompositor(compositor = "default") {

        if (typeof compositor === "string") {
            compositor = this.compositors.get(compositor);
        }

        if (typeof compositor === "undefined") {
            throw new Error("Invalid WebGL Compositor");
        }

        if (this.currentCompositor !== compositor) {
            if (this.currentCompositor !== null) {
                // flush the current compositor
                this.currentCompositor.flush();
            }
            // set given one as current
            this.currentCompositor = compositor;
        }
    }

    /**
     * Reset the gl transform to identity
     * @name resetTransform
     * @memberof WebGLRenderer
     */
    resetTransform() {
        this.currentTransform.identity();
    }

    /**
     * @ignore
     */
    createFontTexture(cache) {
        if (typeof this.fontTexture === "undefined") {
            var canvas = this.backBufferCanvas;
            var width = canvas.width;
            var height = canvas.height;

            if (this.WebGLVersion === 1) {
                if (!isPowerOfTwo(width)) {
                    width = nextPowerOfTwo(canvas.width);
                }
                if (!isPowerOfTwo(height)) {
                    height = nextPowerOfTwo(canvas.height);
                }
            }

            var image = createCanvas(width, height, true);

            /**
             * @ignore
             */
            this.fontContext2D = this.getContext2d(image);

            /**
             * @ignore
             */
            this.fontTexture = new TextureAtlas(createAtlas(canvas.width, canvas.height, "fontTexture"), image, cache);
            this.currentCompositor.uploadTexture(this.fontTexture, 0, 0, 0);

        } else {
           // fontTexture was already created, just add it back into the cache
           cache.set(this.fontContext2D.canvas, this.fontTexture);
       }
    }

    /**
     * Create a pattern with the specified repetition
     * @name createPattern
     * @memberof WebGLRenderer
     * @param {Image} image Source image
     * @param {string} repeat Define how the pattern should be repeated
     * @returns {TextureAtlas}
     * @see ImageLayer#repeat
     * @example
     * var tileable   = renderer.createPattern(image, "repeat");
     * var horizontal = renderer.createPattern(image, "repeat-x");
     * var vertical   = renderer.createPattern(image, "repeat-y");
     * var basic      = renderer.createPattern(image, "no-repeat");
     */
    createPattern(image, repeat) {

        if (renderer.WebGLVersion === 1 && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height))) {
            var src = typeof image.src !== "undefined" ? image.src : image;
            throw new Error(
                "[WebGL Renderer] " + src + " is not a POT texture " +
                "(" + image.width + "x" + image.height + ")"
            );
        }

        var texture = new TextureAtlas(createAtlas(image.width, image.height, "pattern", repeat), image);

        // FIXME: Remove old cache entry and texture when changing the repeat mode
        this.currentCompositor.uploadTexture(texture);

        return texture;
    }

    /**
     * Flush the compositor to the frame buffer
     * @name flush
     * @memberof WebGLRenderer
     */
    flush() {
        this.currentCompositor.flush();
    }

    /**
     * set/change the current projection matrix (WebGL only)
     * @name setProjection
     * @memberof WebGLRenderer
     * @param {Matrix3d} matrix
     */
    setProjection(matrix) {
        super.setProjection(matrix);
        this.currentCompositor.setProjection(matrix);
    }

    /**
     * Clears the gl context with the given color.
     * @name clearColor
     * @memberof WebGLRenderer
     * @param {Color|string} [color="#000000"] CSS color.
     * @param {boolean} [opaque=false] Allow transparency [default] or clear the surface completely [true]
     */
    clearColor(color = "#000000", opaque = false) {
        var glArray;

        if (color instanceof Color) {
            glArray = color.toArray();
        } else {
            var _color = pool.pull("me.Color");
            // reuse temporary the renderer default color object
            glArray = _color.parseCSS(color).toArray();
            pool.push(_color);
        }
        // clear gl context with the specified color
        this.currentCompositor.clearColor(glArray[0], glArray[1], glArray[2], (opaque === true) ? 1.0 : glArray[3]);
        this.currentCompositor.clear();

        // restore default clear Color black
        this.currentCompositor.clearColor(0.0, 0.0, 0.0, 0.0);

    }

    /**
     * Erase the pixels in the given rectangular area by setting them to transparent black (rgba(0,0,0,0)).
     * @name clearRect
     * @memberof WebGLRenderer
     * @param {number} x x axis of the coordinate for the rectangle starting point.
     * @param {number} y y axis of the coordinate for the rectangle starting point.
     * @param {number} width The rectangle's width.
     * @param {number} height The rectangle's height.
     */
    clearRect(x, y, width, height) {
        this.save();
        this.clipRect(x, y, width, height);
        this.clearColor();
        this.restore();
    }

    /**
     * @ignore
     */
    drawFont(bounds) {
        var fontContext = this.getFontContext();

        // Force-upload the new texture
        this.currentCompositor.uploadTexture(this.fontTexture, 0, 0, 0, true);

        // Add the new quad
        var uvs = this.fontTexture.getUVs(bounds.left + "," + bounds.top + "," + bounds.width + "," + bounds.height);
        this.currentCompositor.addQuad(
            this.fontTexture,
            bounds.left,
            bounds.top,
            bounds.width,
            bounds.height,
            uvs[0],
            uvs[1],
            uvs[2],
            uvs[3],
            this.currentTint.toUint32()
        );

        // Clear font context2D
        fontContext.clearRect(
            bounds.left,
            bounds.top,
            bounds.width,
            bounds.height
        );
    }

    /**
     * Draw an image to the gl context
     * @name drawImage
     * @memberof WebGLRenderer
     * @param {Image} image An element to draw into the context. The specification permits any canvas image source (CanvasImageSource), specifically, a CSSImageValue, an HTMLImageElement, an SVGImageElement, an HTMLVideoElement, an HTMLCanvasElement, an ImageBitmap, or an OffscreenCanvas.
     * @param {number} sx The X coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
     * @param {number} sy The Y coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
     * @param {number} sw The width of the sub-rectangle of the source image to draw into the destination context. If not specified, the entire rectangle from the coordinates specified by sx and sy to the bottom-right corner of the image is used.
     * @param {number} sh The height of the sub-rectangle of the source image to draw into the destination context.
     * @param {number} dx The X coordinate in the destination canvas at which to place the top-left corner of the source image.
     * @param {number} dy The Y coordinate in the destination canvas at which to place the top-left corner of the source image.
     * @param {number} dw The width to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in width when drawn.
     * @param {number} dh The height to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in height when drawn.
     * @example
     * // Position the image on the canvas:
     * renderer.drawImage(image, dx, dy);
     * // Position the image on the canvas, and specify width and height of the image:
     * renderer.drawImage(image, dx, dy, dWidth, dHeight);
     * // Clip the image and position the clipped part on the canvas:
     * renderer.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
     */
    drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
        if (typeof sw === "undefined") {
            sw = dw = image.width;
            sh = dh = image.height;
            dx = sx;
            dy = sy;
            sx = 0;
            sy = 0;
        }
        else if (typeof dx === "undefined") {
            dx = sx;
            dy = sy;
            dw = sw;
            dh = sh;
            sw = image.width;
            sh = image.height;
            sx = 0;
            sy = 0;
        }

        if (this.settings.subPixel === false) {
            // clamp to pixel grid
            dx |= 0;
            dy |= 0;
        }

        var texture = this.cache.get(image);
        var uvs = texture.getUVs(sx + "," + sy + "," + sw + "," + sh);
        this.currentCompositor.addQuad(texture, dx, dy, dw, dh, uvs[0], uvs[1], uvs[2], uvs[3], this.currentTint.toUint32());
    }

    /**
     * Draw a pattern within the given rectangle.
     * @name drawPattern
     * @memberof WebGLRenderer
     * @param {TextureAtlas} pattern Pattern object
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @see WebGLRenderer#createPattern
     */
    drawPattern(pattern, x, y, width, height) {
        var uvs = pattern.getUVs("0,0," + width + "," + height);
        this.currentCompositor.addQuad(pattern, x, y, width, height, uvs[0], uvs[1], uvs[2], uvs[3], this.currentTint.toUint32());
    }


    /**
     * return a reference to the screen canvas corresponding WebGL Context
     * @name getScreenContext
     * @memberof WebGLRenderer
     * @returns {WebGLRenderingContext}
     */
    getScreenContext() {
        return this.gl;
    }

    /**
     * Returns the WebGL Context object of the given Canvas
     * @name getContextGL
     * @memberof WebGLRenderer
     * @param {HTMLCanvasElement} canvas
     * @param {boolean} [transparent=true] use false to disable transparency
     * @returns {WebGLRenderingContext}
     */
    getContextGL(canvas, transparent) {
        if (typeof canvas === "undefined" || canvas === null) {
            throw new Error(
                "You must pass a canvas element in order to create " +
                "a GL context"
            );
        }

        if (typeof transparent !== "boolean") {
            transparent = true;
        }

        var attr = {
            alpha : transparent,
            antialias : this.settings.antiAlias,
            depth : false,
            stencil: true,
            preserveDrawingBuffer : false,
            premultipliedAlpha: transparent,
            powerPreference: this.settings.powerPreference,
            failIfMajorPerformanceCaveat : this.settings.failIfMajorPerformanceCaveat
        };

        var gl;

        // attempt to create a WebGL2 context if requested
        if (this.settings.preferWebGL1 === false) {
            gl = canvas.getContext("webgl2", attr);
            if (gl) {
                this.WebGLVersion = 2;
            }
        }

        // fallback to WebGL1
        if (!gl) {
            this.WebGLVersion = 1;
            gl = canvas.getContext("webgl", attr) || canvas.getContext("experimental-webgl", attr);
        }

        if (!gl) {
            throw new Error(
                "A WebGL context could not be created."
            );
        }

        return gl;
    }

    /**
     * Returns the WebGLContext instance for the renderer
     * return a reference to the system 2d Context
     * @name getContext
     * @memberof WebGLRenderer
     * @returns {WebGLRenderingContext}
     */
    getContext() {
        return this.gl;
    }

    /**
     * set a blend mode for the given context. <br>
     * Supported blend mode between Canvas and WebGL remderer : <br>
     * - "normal" : this is the default mode and draws new content on top of the existing content <br>
     * <img src="images/normal-blendmode.png" width="510"/> <br>
     * - "multiply" : the pixels of the top layer are multiplied with the corresponding pixel of the bottom layer. A darker picture is the result. <br>
     * <img src="images/multiply-blendmode.png" width="510"/> <br>
     * - "additive or lighter" : where both content overlap the color is determined by adding color values. <br>
     * <img src="images/lighter-blendmode.png" width="510"/> <br>
     * - "screen" : The pixels are inverted, multiplied, and inverted again. A lighter picture is the result (opposite of multiply) <br>
     * <img src="images/screen-blendmode.png" width="510"/> <br>
     * @name setBlendMode
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
     * @memberof WebGLRenderer
     * @param {string} [mode="normal"] blend mode : "normal", "multiply", "lighter", "additive", "screen"
     * @param {WebGLRenderingContext} [gl]
     */
    setBlendMode(mode = "normal", gl = this.gl) {

        if (this.currentBlendMode !== mode) {
            this.flush();
            gl.enable(gl.BLEND);
            this.currentBlendMode = mode;

            switch (mode) {
                case "screen" :
                    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
                    break;

                case "lighter" :
                case "additive" :
                    gl.blendFunc(gl.ONE, gl.ONE);
                    break;

                case "multiply" :
                    gl.blendFunc(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                    break;

                default :
                    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    this.currentBlendMode = "normal";
                    break;
            }
        }
    }

    /**
     * return a reference to the font 2d Context
     * @ignore
     */
    getFontContext() {
        if (typeof this.fontContext2D === "undefined" ) {
            // warn the end user about performance impact
            console.warn("[WebGL Renderer] WARNING : Using Standard me.Text with WebGL will severly impact performances !");
            // create the font texture if not done yet
            this.createFontTexture(this.cache);
        }
        return this.fontContext2D;
    }

    /**
     * restores the canvas context
     * @name restore
     * @memberof WebGLRenderer
     */
    restore() {
        // do nothing if there is no saved states
        if (this._matrixStack.length !== 0) {
            var color = this._colorStack.pop();
            var matrix = this._matrixStack.pop();

            // restore the previous context
            this.currentColor.copy(color);
            this.currentTransform.copy(matrix);

            this.setBlendMode(this._blendStack.pop());

            // recycle objects
            pool.push(color);
            pool.push(matrix);
        }

        if (this._scissorStack.length !== 0) {
            // FIXME : prevent `scissor` object realloc and GC
            this.currentScissor.set(this._scissorStack.pop());
        } else {
            // turn off scissor test
            this.gl.disable(this.gl.SCISSOR_TEST);
            this.currentScissor[0] = 0;
            this.currentScissor[1] = 0;
            this.currentScissor[2] = this.backBufferCanvas.width;
            this.currentScissor[3] = this.backBufferCanvas.height;
        }
    }

    /**
     * saves the canvas context
     * @name save
     * @memberof WebGLRenderer
     */
    save() {
        this._colorStack.push(this.currentColor.clone());
        this._matrixStack.push(this.currentTransform.clone());

        if (this.gl.isEnabled(this.gl.SCISSOR_TEST)) {
            // FIXME avoid slice and object realloc
            this._scissorStack.push(this.currentScissor.slice());
        }

        this._blendStack.push(this.getBlendMode());
    }

    /**
     * rotates the uniform matrix
     * @name rotate
     * @memberof WebGLRenderer
     * @param {number} angle in radians
     */
    rotate(angle) {
        this.currentTransform.rotate(angle);
    }

    /**
     * scales the uniform matrix
     * @name scale
     * @memberof WebGLRenderer
     * @param {number} x
     * @param {number} y
     */
    scale(x, y) {
        this.currentTransform.scale(x, y);
    }

    /**
     * not used by this renderer?
     * @ignore
     */
    setAntiAlias(context, enable) {
        super.setAntiAlias(context, enable);
        // TODO: perhaps handle GLNEAREST or other options with texture binding
    }

    /**
     * Set the global alpha
     * @name setGlobalAlpha
     * @memberof WebGLRenderer
     * @param {number} alpha 0.0 to 1.0 values accepted.
     */
    setGlobalAlpha(alpha) {
        this.currentColor.alpha = alpha;
    }

    /**
     * Return the global alpha
     * @name getGlobalAlpha
     * @memberof WebGLRenderer
     * @returns {number} global alpha value
     */
    getGlobalAlpha() {
        return this.currentColor.alpha;
    }

    /**
     * Set the current fill & stroke style color.
     * By default, or upon reset, the value is set to #000000.
     * @name setColor
     * @memberof WebGLRenderer
     * @param {Color|string} color css color string.
     */
    setColor(color) {
        var alpha = this.currentColor.alpha;
        this.currentColor.copy(color);
        this.currentColor.alpha *= alpha;
    }

    /**
     * Set the line width
     * @name setLineWidth
     * @memberof WebGLRenderer
     * @param {number} width Line width
     */
    setLineWidth(width) {
        this.getScreenContext().lineWidth(width);
    }

    /**
     * Stroke an arc at the specified coordinates with given radius, start and end points
     * @name strokeArc
     * @memberof WebGLRenderer
     * @param {number} x arc center point x-axis
     * @param {number} y arc center point y-axis
     * @param {number} radius
     * @param {number} start start angle in radians
     * @param {number} end end angle in radians
     * @param {boolean} [antiClockwise=false] draw arc anti-clockwise
     * @param {boolean} [fill=false]
     */
    strokeArc(x, y, radius, start, end, antiClockwise = false, fill = false) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        this.path2D.beginPath();
        this.path2D.arc(x, y, radius, start, end, antiClockwise);
        if (fill === false) {
            this.currentCompositor.drawVertices(this.gl.LINE_STRIP, this.path2D.points);
        } else {
            this.path2D.closePath();
            this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
        }
    }

    /**
     * Fill an arc at the specified coordinates with given radius, start and end points
     * @name fillArc
     * @memberof WebGLRenderer
     * @param {number} x arc center point x-axis
     * @param {number} y arc center point y-axis
     * @param {number} radius
     * @param {number} start start angle in radians
     * @param {number} end end angle in radians
     * @param {boolean} [antiClockwise=false] draw arc anti-clockwise
     */
    fillArc(x, y, radius, start, end, antiClockwise = false) {
        this.strokeArc(x, y, radius, start, end, antiClockwise, true);
    }

    /**
     * Stroke an ellipse at the specified coordinates with given radius
     * @name strokeEllipse
     * @memberof WebGLRenderer
     * @param {number} x ellipse center point x-axis
     * @param {number} y ellipse center point y-axis
     * @param {number} w horizontal radius of the ellipse
     * @param {number} h vertical radius of the ellipse
     * @param {boolean} [fill=false] also fill the shape with the current color if true
     */
    strokeEllipse(x, y, w, h, fill = false) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        this.path2D.beginPath();
        this.path2D.ellipse(x, y, w, h, 0, 0, 360);
        this.path2D.closePath();
        if (fill === false) {
            this.currentCompositor.drawVertices(this.gl.LINE_LOOP, this.path2D.points);
        } else {
            this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
        }
    }

    /**
     * Fill an ellipse at the specified coordinates with given radius
     * @name fillEllipse
     * @memberof WebGLRenderer
     * @param {number} x ellipse center point x-axis
     * @param {number} y ellipse center point y-axis
     * @param {number} w horizontal radius of the ellipse
     * @param {number} h vertical radius of the ellipse
     */
    fillEllipse(x, y, w, h) {
        this.strokeEllipse(x, y, w, h, false);
    }

    /**
     * Stroke a line of the given two points
     * @name strokeLine
     * @memberof WebGLRenderer
     * @param {number} startX the start x coordinate
     * @param {number} startY the start y coordinate
     * @param {number} endX the end x coordinate
     * @param {number} endY the end y coordinate
     */
    strokeLine(startX, startY, endX, endY) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        this.path2D.beginPath();
        this.path2D.moveTo(startX, startY);
        this.path2D.lineTo(endX, endY);
        this.currentCompositor.drawVertices(this.gl.LINE_STRIP, this.path2D.points);
    }


    /**
     * Fill a line of the given two points
     * @name fillLine
     * @memberof WebGLRenderer
     * @param {number} startX the start x coordinate
     * @param {number} startY the start y coordinate
     * @param {number} endX the end x coordinate
     * @param {number} endY the end y coordinate
     */
    fillLine(startX, startY, endX, endY) {
        this.strokeLine(startX, startY, endX, endY);
    }

    /**
     * Stroke a me.Polygon on the screen with a specified color
     * @name strokePolygon
     * @memberof WebGLRenderer
     * @param {Polygon} poly the shape to draw
     * @param {boolean} [fill=false] also fill the shape with the current color if true
     */
    strokePolygon(poly, fill = false) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        this.translate(poly.pos.x, poly.pos.y);
        this.path2D.beginPath();
        this.path2D.moveTo(poly.points[0].x, poly.points[0].y);
        var point;
        for (var i = 1; i < poly.points.length; i++) {
            point = poly.points[i];
            this.path2D.lineTo(point.x, point.y);
        }
        this.path2D.lineTo(poly.points[0].x, poly.points[0].y);
        this.path2D.closePath();
        if (fill === false) {
            this.currentCompositor.drawVertices(this.gl.LINE_LOOP, this.path2D.points);
        } else {
            // draw all triangles
            this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
        }
        this.translate(-poly.pos.x, -poly.pos.y);
    }

    /**
     * Fill a me.Polygon on the screen
     * @name fillPolygon
     * @memberof WebGLRenderer
     * @param {Polygon} poly the shape to draw
     */
    fillPolygon(poly) {
        this.strokePolygon(poly, true);
    }

    /**
     * Draw a stroke rectangle at the specified coordinates
     * @name strokeRect
     * @memberof WebGLRenderer
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {boolean} [fill=false] also fill the shape with the current color if true
     */
    strokeRect(x, y, width, height, fill = false) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        this.path2D.beginPath();
        this.path2D.rect(x, y, width, height);
        if (fill === false) {
            this.currentCompositor.drawVertices(this.gl.LINE_LOOP, this.path2D.points);
        } else {
            this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
        }
    }

    /**
     * Draw a filled rectangle at the specified coordinates
     * @name fillRect
     * @memberof WebGLRenderer
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */
    fillRect(x, y, width, height) {
        this.strokeRect(x, y, width, height, true);
    }

    /**
     * Stroke a rounded rectangle at the specified coordinates
     * @name strokeRoundRect
     * @memberof WebGLRenderer
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} radius
     * @param {boolean} [fill=false] also fill the shape with the current color if true
     */
    strokeRoundRect(x, y, width, height, radius, fill = false) {
        if (this.getGlobalAlpha() < 1 / 255) {
            // Fast path: don't draw fully transparent
            return;
        }
        this.path2D.beginPath();
        this.path2D.roundRect(x, y, width, height, radius);
        if (fill === false) {
            this.currentCompositor.drawVertices(this.gl.LINE_LOOP, this.path2D.points);
        } else {
            this.path2D.closePath();
            this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
        }
    }

    /**
     * Draw a rounded filled rectangle at the specified coordinates
     * @name fillRoundRect
     * @memberof WebGLRenderer
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} radius
     */
    fillRoundRect(x, y, width, height, radius) {
        this.strokeRoundRect(x, y, width, height, radius, true);
    }

    /**
     * Reset (overrides) the renderer transformation matrix to the
     * identity one, and then apply the given transformation matrix.
     * @name setTransform
     * @memberof WebGLRenderer
     * @param {Matrix2d} mat2d Matrix to transform by
     */
    setTransform(mat2d) {
        this.resetTransform();
        this.transform(mat2d);
    }

    /**
     * Multiply given matrix into the renderer tranformation matrix
     * @name transform
     * @memberof WebGLRenderer
     * @param {Matrix2d} mat2d Matrix to transform by
     */
    transform(mat2d) {
        var currentTransform = this.currentTransform;
        currentTransform.multiply(mat2d);
        if (this.settings.subPixel === false) {
            // snap position values to pixel grid
            var a = currentTransform.toArray();
            a[6] |= 0;
            a[7] |= 0;
        }
    }

    /**
     * Translates the uniform matrix by the given coordinates
     * @name translate
     * @memberof WebGLRenderer
     * @param {number} x
     * @param {number} y
     */
    translate(x, y) {
        var currentTransform = this.currentTransform;
        currentTransform.translate(x, y);
        if (this.settings.subPixel === false) {
            // snap position values to pixel grid
            var a = currentTransform.toArray();
            a[6] |= 0;
            a[7] |= 0;
        }
    }

    /**
     * clip the given region from the original canvas. Once a region is clipped,
     * all future drawing will be limited to the clipped region.
     * You can however save the current region using the save(),
     * and restore it (with the restore() method) any time in the future.
     * (<u>this is an experimental feature !</u>)
     * @name clipRect
     * @memberof WebGLRenderer
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */
    clipRect(x, y, width, height) {
        var canvas = this.backBufferCanvas;
        var gl = this.gl;
        // if requested box is different from the current canvas size
        if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height) {
            var currentScissor = this.currentScissor;
            if (gl.isEnabled(gl.SCISSOR_TEST)) {
                // if same as the current scissor box do nothing
                if (currentScissor[0] === x && currentScissor[1] === y &&
                    currentScissor[2] === width && currentScissor[3] === height) {
                        return;
                }
            }
            // flush the compositor
            this.flush();
            // turn on scissor test
            gl.enable(this.gl.SCISSOR_TEST);
            // set the scissor rectangle (note : coordinates are left/bottom)
            gl.scissor(
                // scissor does not account for currentTransform, so manually adjust
                x + this.currentTransform.tx,
                canvas.height -height -y -this.currentTransform.ty,
                width,
                height
            );
            // save the new currentScissor box
            currentScissor[0] = x;
            currentScissor[1] = y;
            currentScissor[2] = width;
            currentScissor[3] = height;
        } else {
            // turn off scissor test
            gl.disable(gl.SCISSOR_TEST);
        }
    }

    /**
     * A mask limits rendering elements to the shape and position of the given mask object.
     * So, if the renderable is larger than the mask, only the intersecting part of the renderable will be visible.
     * Mask are not preserved through renderer context save and restore.
     * @name setMask
     * @memberof WebGLRenderer
     * @param {Rect|RoundRect|Polygon|Line|Ellipse} [mask] a shape defining the mask to be applied
     * @param {boolean} [invert=false] either the given shape should define what is visible (default) or the opposite
     */
    setMask(mask, invert = false) {
        var gl = this.gl;

        // flush the compositor
        this.flush();

        if (this.maskLevel === 0) {
            // Enable and setup GL state to write to stencil buffer
            gl.enable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);


        }

        this.maskLevel++;

        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, this.maskLevel, 1);
        gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);


        // fill the given mask shape
        this.fill(mask);

        // flush the compositor
        this.flush();

        gl.colorMask(true, true, true, true);

        // Use stencil buffer to affect next rendering object
        if (invert === true) {
            gl.stencilFunc(gl.EQUAL, this.maskLevel + 1, 1);
        } else {
            gl.stencilFunc(gl.NOTEQUAL, this.maskLevel + 1, 1);
        }
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    }

    /**
     * disable (remove) the rendering mask set through setMask.
     * @name clearMask
     * @see WebGLRenderer#setMask
     * @memberof WebGLRenderer
     */
    clearMask() {
        if (this.maskLevel > 0) {
            // flush the compositor
            this.flush();
            this.maskLevel = 0;
            this.gl.disable(this.gl.STENCIL_TEST);
        }
    }
}

/**
 * video functions
 * @namespace video
 */

var designRatio = 1;
var designWidth = 0;
var designHeight = 0;

// default video settings
var settings = {
    parent : undefined,
    renderer : 2, // AUTO
    doubleBuffering : false,
    autoScale : false,
    scale : 1.0,
    scaleMethod : "fit",
    transparent : false,
    blendMode : "normal",
    antiAlias : false,
    failIfMajorPerformanceCaveat : true,
    subPixel : false,
    preferWebGL1 : false,
    powerPreference : "default",
    verbose : false,
    consoleHeader : true
};

/**
 * Auto-detect the best renderer to use
 * @ignore
 */
function autoDetectRenderer(options) {
    try {
        if (device.isWebGLSupported(options)) {
            return new WebGLRenderer(options);
        }
    } catch (e) {
        console.log("Error creating WebGL renderer :" + e.message);
    }
    return new CanvasRenderer(options);
}
/**
 * callback for window resize event
 * @ignore
 */
function onresize() {
    var settings = renderer.settings;
    var scaleX = 1, scaleY = 1;

    if (settings.autoScale) {

        // set max the canvas max size if CSS values are defined
        var canvasMaxWidth = Infinity;
        var canvasMaxHeight = Infinity;

        if (globalThis.getComputedStyle) {
            var style = globalThis.getComputedStyle(renderer.getScreenCanvas(), null);
            canvasMaxWidth = parseInt(style.maxWidth, 10) || Infinity;
            canvasMaxHeight = parseInt(style.maxHeight, 10) || Infinity;
        }

        // get the maximum canvas size within the parent div containing the canvas container
        var nodeBounds = device.getParentBounds(getParent());

        var _max_width = Math.min(canvasMaxWidth, nodeBounds.width);
        var _max_height = Math.min(canvasMaxHeight, nodeBounds.height);

        // calculate final canvas width & height
        var screenRatio = _max_width / _max_height;

        if ((settings.scaleMethod === "fill-min" && screenRatio > designRatio) ||
            (settings.scaleMethod === "fill-max" && screenRatio < designRatio) ||
            (settings.scaleMethod === "flex-width")
        ) {
            // resize the display canvas to fill the parent container
            var sWidth = Math.min(canvasMaxWidth, designHeight * screenRatio);
            scaleX = scaleY = _max_width / sWidth;
            renderer.resize(Math.floor(sWidth), designHeight);
        }
        else if ((settings.scaleMethod === "fill-min" && screenRatio < designRatio) ||
                 (settings.scaleMethod === "fill-max" && screenRatio > designRatio) ||
                 (settings.scaleMethod === "flex-height")
        ) {
            // resize the display canvas to fill the parent container
            var sHeight = Math.min(canvasMaxHeight, designWidth * (_max_height / _max_width));
            scaleX = scaleY = _max_height / sHeight;
            renderer.resize(designWidth, Math.floor(sHeight));
        }
        else if (settings.scaleMethod === "flex") {
            // resize the display canvas to fill the parent container
            renderer.resize(Math.floor(_max_width), Math.floor(_max_height));
        }
        else if (settings.scaleMethod === "stretch") {
            // scale the display canvas to fit with the parent container
            scaleX = _max_width / designWidth;
            scaleY = _max_height / designHeight;
        }
        else {
            // scale the display canvas to fit the parent container
            // make sure we maintain the original aspect ratio
            if (screenRatio < designRatio) {
                scaleX = scaleY = _max_width / designWidth;
            }
            else {
                scaleX = scaleY = _max_height / designHeight;
            }
        }

        // adjust scaling ratio based on the new scaling ratio
        scale(scaleX, scaleY);
    }
}
/**
 * Select the HTML5 Canvas renderer
 * @name CANVAS
 * @memberof video
 * @constant
 */
const CANVAS = 0;

/**
 * Select the WebGL renderer
 * @name WEBGL
 * @memberof video
 * @constant
 */
const WEBGL = 1;

/**
 * Auto-select the renderer (Attempt WebGL first, with fallback to Canvas)
 * @name AUTO
 * @memberof video
 * @constant
 */
const AUTO = 2;

/**
 * the parent container of the main canvas element
 * @ignore
 * @type {HTMLElement}
 * @readonly
 * @name parent
 * @memberof video
 */
let parent = null;

/**
 * the scaling ratio to be applied to the display canvas
 * @name scaleRatio
 * @type {Vector2d}
 * @default <1,1>
 * @memberof video
 */
let scaleRatio = new Vector2d(1, 1);

 /**
  * A reference to the active Canvas or WebGL active renderer renderer
  * @name renderer
  * @type {CanvasRenderer|WebGLRenderer}
  * @memberof video
  */
let renderer = null;

/**
 * Initialize the "video" system (create a canvas based on the given arguments, and the related renderer). <br>
 * melonJS support various scaling mode, that can be enabled <u>once the scale option is set to <b>`auto`</b></u> : <br>
 *  - <i><b>`fit`</b></i> : Letterboxed; content is scaled to design aspect ratio <br>
 * <center><img src="images/scale-fit.png"/></center><br>
 *  - <i><b>`fill-min`</b></i> : Canvas is resized to fit minimum design resolution; content is scaled to design aspect ratio <br>
 * <center><img src="images/scale-fill-min.png"/></center><br>
 *  - <i><b>`fill-max`</b></i> : Canvas is resized to fit maximum design resolution; content is scaled to design aspect ratio <br>
 * <center><img src="images/scale-fill-max.png"/></center><br>
 *  - <i><b>`flex`</b><</i> : Canvas width & height is resized to fit; content is scaled to design aspect ratio <br>
 * <center><img src="images/scale-flex.png"/></center><br>
 *  - <i><b>`flex-width`</b></i> : Canvas width is resized to fit; content is scaled to design aspect ratio <br>
 * <center><img src="images/scale-flex-width.png"/></center><br>
 *  - <i><b>`flex-height`</b></i> : Canvas height is resized to fit; content is scaled to design aspect ratio <br>
 * <center><img src="images/scale-flex-height.png"/></center><br>
 *  - <i><b>`stretch`</b></i> : Canvas is resized to fit; content is scaled to screen aspect ratio
 * <center><img src="images/scale-stretch.png"/></center><br>
 * @function video.init
 * @param {number} width The width of the canvas viewport
 * @param {number} height The height of the canvas viewport
 * @param {object} [options] The optional video/renderer parameters.<br> (see Renderer(s) documentation for further specific options)
 * @param {string|HTMLElement} [options.parent=document.body] the DOM parent element to hold the canvas in the HTML file
 * @param {number} [options.renderer=video.AUTO] renderer to use (me.video.CANVAS, me.video.WEBGL, me.video.AUTO)
 * @param {boolean} [options.doubleBuffering=false] enable/disable double buffering
 * @param {number|string} [options.scale=1.0] enable scaling of the canvas ('auto' for automatic scaling)
 * @param {string} [options.scaleMethod="fit"] screen scaling modes ('fit','fill-min','fill-max','flex','flex-width','flex-height','stretch')
 * @param {boolean} [options.preferWebGL1=false] if true the renderer will only use WebGL 1
 * @param {string} [options.powerPreference="default"] a hint to the user agent indicating what configuration of GPU is suitable for the WebGL context ("default", "high-performance", "low-power"). To be noted that Safari and Chrome (since version 80) both default to "low-power" to save battery life and improve the user experience on these dual-GPU machines.
 * @param {boolean} [options.transparent=false] whether to allow transparent pixels in the front buffer (screen).
 * @param {boolean} [options.antiAlias=false] whether to enable or not video scaling interpolation
 * @param {boolean} [options.consoleHeader=true] whether to display melonJS version and basic device information in the console
 * @returns {boolean} false if initialization failed (canvas not supported)
 * @example
 * // init the video with a 640x480 canvas
 * me.video.init(640, 480, {
 *     parent : "screen",
 *     renderer : me.video.AUTO,
 *     scale : "auto",
 *     scaleMethod : "fit",
 *     doubleBuffering : true
 * });
 */
function init(width, height, options) {

    // ensure melonjs has been properly initialized
    if (!initialized) {
        throw new Error("me.video.init() called before engine initialization.");
    }

    // revert to default options if not defined
    settings = Object.assign(settings, options || {});

    // sanitize potential given parameters
    settings.width = width;
    settings.height = height;
    settings.doubleBuffering = !!(settings.doubleBuffering);
    settings.transparent = !!(settings.transparent);
    settings.antiAlias = !!(settings.antiAlias);
    settings.failIfMajorPerformanceCaveat = !!(settings.failIfMajorPerformanceCaveat);
    settings.subPixel = !!(settings.subPixel);
    settings.verbose = !!(settings.verbose);
    if (settings.scaleMethod.search(/^(fill-(min|max)|fit|flex(-(width|height))?|stretch)$/) !== -1) {
        settings.autoScale = (settings.scale === "auto") || true;
    } else {
        // default scaling method
        settings.scaleMethod = "fit";
        settings.autoScale = (settings.scale === "auto") || false;
    }

    // display melonJS version
    if (settings.consoleHeader !== false) {
        // output video information in the console
        console.log("melonJS 2 (v" + version + ") | http://melonjs.org" );
    }

    // override renderer settings if &webgl is defined in the URL
    var uriFragment = utils.getUriFragment();
    if (uriFragment.webgl === true || uriFragment.webgl1 === true || uriFragment.webgl2 === true) {
        settings.renderer = WEBGL;
        if (uriFragment.webgl1 === true) {
            settings.preferWebGL1 = true;
        }
    }

    // normalize scale
    settings.scale = (settings.autoScale) ? 1.0 : (+settings.scale || 1.0);
    scaleRatio.set(settings.scale, settings.scale);

    // force double buffering if scaling is required
    if (settings.autoScale || (settings.scale !== 1.0)) {
        settings.doubleBuffering = true;
    }

    // hold the requested video size ratio
    designRatio = width / height;
    designWidth = width;
    designHeight = height;

    // default scaled size value
    settings.zoomX = width * scaleRatio.x;
    settings.zoomY = height * scaleRatio.y;

    //add a channel for the onresize/onorientationchange event
    globalThis.addEventListener(
        "resize",
        utils.function.throttle(
            function (e) {
                emit(WINDOW_ONRESIZE, e);
            }, 100
        ), false
    );

    // Screen Orientation API
    globalThis.addEventListener(
        "orientationchange",
        function (e) {
            emit(WINDOW_ONORIENTATION_CHANGE, e);
        },
        false
    );
    // pre-fixed implementation on mozzila
    globalThis.addEventListener(
        "onmozorientationchange",
        function (e) {
            emit(WINDOW_ONORIENTATION_CHANGE, e);
        },
        false
    );

    if (device.ScreenOrientation === true) {
        globalThis.screen.orientation.onchange = function (e) {
            emit(WINDOW_ONORIENTATION_CHANGE, e);
        };
    }

    // Automatically update relative canvas position on scroll
    globalThis.addEventListener("scroll", utils.function.throttle(
        function (e) {
            emit(WINDOW_ONSCROLL, e);
        }, 100
    ), false);

    // register to the channel
    on(WINDOW_ONRESIZE, onresize, this);
    on(WINDOW_ONORIENTATION_CHANGE, onresize, this);

    try {
        switch (settings.renderer) {
            case AUTO:
            case WEBGL:
                renderer = autoDetectRenderer(settings);
                break;
            default:
                renderer = new CanvasRenderer(settings);
                break;
        }
    } catch (e) {
        console(e.message);
        // me.video.init() returns false if failing at creating/using a HTML5 canvas
        return false;
    }

    // add our canvas (default to document.body if settings.parent is undefined)
    parent = device.getElement(typeof settings.parent !== "undefined" ? settings.parent : document.body);
    parent.appendChild(renderer.getScreenCanvas());

    // trigger an initial resize();
    onresize();

    // add an observer to detect when the dom tree is modified
    if ("MutationObserver" in globalThis) {
        // Create an observer instance linked to the callback function
        var observer = new MutationObserver(onresize.bind(this));

        // Start observing the target node for configured mutations
        observer.observe(parent, {
            attributes: false, childList: true, subtree: true
        });
    }

    if (settings.consoleHeader !== false) {
        var renderType = (renderer instanceof CanvasRenderer) ? "CANVAS" : "WebGL" + renderer.WebGLVersion;
        var audioType = device.hasWebAudio ? "Web Audio" : "HTML5 Audio";
        var gpu_renderer = (typeof renderer.GPURenderer === "string") ? " (" + renderer.GPURenderer + ")" : "";
        // output video information in the console
        console.log(
            renderType + " renderer" + gpu_renderer + " | " +
            audioType + " | " +
            "pixel ratio " + device.devicePixelRatio + " | " +
            (device.nodeJS ? "node.js" : device.isMobile ? "mobile" : "desktop") + " | " +
            device.getScreenOrientation() + " | " +
            device.language
        );
        console.log( "resolution: " + "requested " + width + "x" + height +
            ", got " + renderer.getWidth() + "x" + renderer.getHeight()
        );
    }

    // notify the video has been initialized
    emit(VIDEO_INIT);

    return true;
}
/**
 * Create and return a new Canvas element
 * @function video.createCanvas
 * @param {number} width width
 * @param {number} height height
 * @param {boolean} [offscreenCanvas=false] will return an OffscreenCanvas if supported
 * @returns {HTMLCanvasElement|OffscreenCanvas}
 */
function createCanvas(width, height, offscreenCanvas = false) {
    var _canvas;

    if (width === 0 || height === 0) {
        throw new Error("width or height was zero, Canvas could not be initialized !");
    }

    if (device.OffscreenCanvas === true && offscreenCanvas === true) {
        _canvas = new OffscreenCanvas(0, 0);
        // stubbing style for compatibility,
        // as OffscreenCanvas is detached from the DOM
        if (typeof _canvas.style === "undefined") {
            _canvas.style = {};
        }
    } else {
        // "else" create a "standard" canvas
        _canvas = document.createElement("canvas");
    }
    _canvas.width = width;
    _canvas.height = height;

    return _canvas;
}
/**
 * return a reference to the parent DOM element holding the main canvas
 * @function video.getParent
 * @returns {HTMLElement}
 */
function getParent() {
    return parent;
}
/**
 * scale the "displayed" canvas by the given scalar.
 * this will modify the size of canvas element directly.
 * Only use this if you are not using the automatic scaling feature.
 * @function video.scale
 * @see video.init
 * @param {number} x x scaling multiplier
 * @param {number} y y scaling multiplier
 */
function scale(x, y) {
    var canvas = renderer.getScreenCanvas();
    var context = renderer.getScreenContext();
    var settings = renderer.settings;
    var pixelRatio = device.devicePixelRatio;

    var w = settings.zoomX = canvas.width * x * pixelRatio;
    var h = settings.zoomY = canvas.height * y * pixelRatio;

    // update the global scale variable
    scaleRatio.set(x * pixelRatio, y * pixelRatio);

    // adjust CSS style based on device pixel ratio
    canvas.style.width = (w / pixelRatio) + "px";
    canvas.style.height = (h / pixelRatio) + "px";

    // if anti-alias and blend mode were resetted (e.g. Canvas mode)
    renderer.setAntiAlias(context, settings.antiAlias);
    renderer.setBlendMode(settings.blendMode, context);

    // force repaint
    repaint();
}

var video = /*#__PURE__*/Object.freeze({
	__proto__: null,
	CANVAS: CANVAS,
	WEBGL: WEBGL,
	AUTO: AUTO,
	get parent () { return parent; },
	scaleRatio: scaleRatio,
	get renderer () { return renderer; },
	init: init,
	createCanvas: createCanvas,
	getParent: getParent,
	scale: scale
});

/**
 * a collection of utility functions
 * @namespace utils
 */

// guid default value
var GUID_base  = "";
var GUID_index = 0;

var utils = {

    agent : agentUtils,
    array : arrayUtils,
    file : fileUtils,
    string : stringUtils,
    function : fnUtils,

    /**
     * Get image pixels
     * @public
     * @memberof utils
     * @name getPixels
     * @param {HTMLImageElement|HTMLCanvasElement} image Image to read
     * @returns {ImageData} ImageData object
     */
    getPixels : function (image) {
        if (image instanceof HTMLImageElement) {
            var _context = CanvasRenderer.getContext2d(
                createCanvas(image.width, image.height)
            );
            _context.drawImage(image, 0, 0);
            return _context.getImageData(0, 0, image.width, image.height);
        }
        else {
            // canvas !
            return image.getContext("2d").getImageData(0, 0, image.width, image.height);
        }
    },

    /**
     * Compare two version strings
     * @public
     * @memberof utils
     * @name checkVersion
     * @param {string} first First version string to compare
     * @param {string} [second=version] Second version string to compare
     * @returns {number} comparison result <br>&lt; 0 : first &lt; second<br>
     * 0 : first == second<br>
     * &gt; 0 : first &gt; second
     * @example
     * if (me.utils.checkVersion("7.0.0") > 0) {
     *     console.error(
     *         "melonJS is too old. Expected: 7.0.0, Got: 6.3.0"
     *     );
     * }
     */
    checkVersion : function (first, second = version) {
        var a = first.split(".");
        var b = second.split(".");
        var len = Math.min(a.length, b.length);
        var result = 0;

        for (var i = 0; i < len; i++) {
            if ((result = +a[i] - +b[i])) {
                break;
            }
        }

        return result ? result : a.length - b.length;
    },

    /**
     * parse the fragment (hash) from a URL and returns them into
     * @public
     * @memberof utils
     * @name getUriFragment
     * @param {string} [url=document.location] an optional params string or URL containing fragment (hash) params to be parsed
     * @returns {object} an object representing the deserialized params string.
     * @property {boolean} [hitbox=false] draw the hitbox in the debug panel (if enabled)
     * @property {boolean} [velocity=false] draw the entities velocity in the debug panel (if enabled)
     * @property {boolean} [quadtree=false] draw the quadtree in the debug panel (if enabled)
     * @property {boolean} [webgl=false] force the renderer to WebGL
     * @property {boolean} [debug=false] display the debug panel (if preloaded)
     * @property {string} [debugToggleKey="s"] show/hide the debug panel (if preloaded)
     * @example
     * // http://www.example.com/index.html#debug&hitbox=true&mytag=value
     * var UriFragment = me.utils.getUriFragment();
     * console.log(UriFragment["mytag"]); //> "value"
     */
    getUriFragment : function (url) {
        var hash = {};

        if (typeof url === "undefined") {
            if (typeof globalThis.document !== "undefined") {
                var location = globalThis.document.location;

                if (location && location.hash) {
                    url = location.hash;
                } else {
                    // No "document.location" exist for Wechat mini game platform.
                    return hash;
                }
            } else {
                // "document" undefined on node.js
                return hash;
            }
        } else {
            // never cache if a url is passed as parameter
            var index = url.indexOf("#");
            if (index !== -1) {
                url = url.slice(index, url.length);
            } else {
                return hash;
            }
        }

        // parse the url
        url.slice(1).split("&").filter(function (value) {
            return (value !== "");
        }).forEach(function (value) {
            var kv = value.split("=");
            var k = kv.shift();
            var v = kv.join("=");
            hash[k] = v || true;
        });

        return hash;
    },

    /**
     * reset the GUID Base Name
     * the idea here being to have a unique ID
     * per level / object
     * @ignore
     */
    resetGUID : function (base, index = 0) {
        // also ensure it's only 8bit ASCII characters
        GUID_base  = toHex$1(base.toString().toUpperCase());
        GUID_index = index;
    },

    /**
     * create and return a very simple GUID
     * Game Unique ID
     * @ignore
     */
    createGUID : function (index = 1) {
        // to cover the case of undefined id for groups
        GUID_index += index;
        return GUID_base + "-" + (index || GUID_index);
    }
};

/**
 * @classdesc
 * a Timer class to manage timing related function (FPS, Game Tick, Time...)
  * @see {@link timer} the default global timer instance
 */
class Timer {

    constructor() {
        /**
         * Last game tick value.<br/>
         * Use this value to scale velocities during frame drops due to slow
         * hardware or when setting an FPS limit. (See {@link timer.maxfps})
         * This feature is disabled by default. Enable me.timer.interpolation to
         * use it.
         * @public
         * @see timer.interpolation
         * @type {number}
         * @name tick
         * @memberof timer
         */
        this.tick = 1.0;

        /**
         * Last measured fps rate.<br/>
         * This feature is disabled by default, unless the debugPanel is enabled/visible
         * @public
         * @type {number}
         * @name fps
         * @memberof timer
         */
        this.fps = 0;

        /**
         * Set the maximum target display frame per second
         * @public
         * @see timer.tick
         * @type {number}
         * @name maxfps
         * @default 60
         * @memberof timer
         */
        this.maxfps = 60;

        /**
         * Enable/disable frame interpolation
         * @see timer.tick
         * @type {boolean}
         * @default false
         * @name interpolation
         * @memberof timer
         */
        this.interpolation = false;

        //hold element to display fps
        this.framecount = 0;
        this.framedelta = 0;

        /* fps count stuff */
        this.last = 0;
        this.now = 0;
        this.delta = 0;
        // for timeout/interval update
        this.step =0;
        this.minstep = 0;

        // list of defined timer function
        this.timers = [];
        this.timerId = 0;

        // Initialize mtimer on Boot event
        on(BOOT, () => {
            // reset variables to initial state
            this.reset();
            this.now = this.last = 0;
            // register to the game before update event
            on(GAME_BEFORE_UPDATE, this.update.bind(this));
        });

        // reset timer
        on(STATE_RESUME, () => {
            this.reset();
        });
        on(STATE_RESTART, () => {
            this.reset();
        });
        on(STATE_CHANGE, () => {
            this.reset();
        });
    }


    /**
     * reset time (e.g. usefull in case of pause)
     * @name reset
     * @memberof timer
     * @ignore
     */
    reset() {
        // set to "now"
        this.last = this.now = globalThis.performance.now();
        this.delta = 0;
        // reset delta counting variables
        this.framedelta = 0;
        this.framecount = 0;
        this.step = Math.ceil(1000 / this.maxfps); // ROUND IT ?
        // define some step with some margin
        this.minstep = (1000 / this.maxfps) * 1.25; // IS IT NECESSARY?\
    }

    /**
     * Calls a function once after a specified delay. See me.timer.setInterval to repeativly call a function.
     * @name setTimeout
     * @memberof timer
     * @param {Function} fn the function you want to execute after delay milliseconds.
     * @param {number} delay the number of milliseconds (thousandths of a second) that the function call should be delayed by.
     * @param {boolean} [pauseable=true] respects the pause state of the engine.
     * @param {...*} args optional parameters which are passed through to the function specified by fn once the timer expires.
     * @returns {number} The numerical ID of the timer, which can be used later with me.timer.clearTimeout().
     * @example
     * // set a timer to call "myFunction" after 1000ms
     * me.timer.setTimeout(myFunction, 1000);
     * // set a timer to call "myFunction" after 1000ms (respecting the pause state) and passing param1 and param2
     * me.timer.setTimeout(myFunction, 1000, true, param1, param2);
     */
    setTimeout(fn, delay, pauseable, ...args) {
        this.timers.push({
            fn : fn,
            delay : delay,
            elapsed : 0,
            repeat : false,
            timerId : ++this.timerId,
            pauseable : pauseable === true || true,
            args : args
        });
        return this.timerId;
    }

    /**
     * Calls a function continously at the specified interval.  See setTimeout to call function a single time.
     * @name setInterval
     * @memberof timer
     * @param {Function} fn the function to execute
     * @param {number} delay the number of milliseconds (thousandths of a second) on how often to execute the function
     * @param {boolean} [pauseable=true] respects the pause state of the engine.
     * @param {...*} args optional parameters which are passed through to the function specified by fn once the timer expires.
     * @returns {number} The numerical ID of the timer, which can be used later with me.timer.clearInterval().
     * @example
     * // set a timer to call "myFunction" every 1000ms
     * me.timer.setInterval(myFunction, 1000);
     * // set a timer to call "myFunction" every 1000ms (respecting the pause state) and passing param1 and param2
     * me.timer.setInterval(myFunction, 1000, true, param1, param2);
     */
    setInterval(fn, delay, pauseable, ...args) {
        this.timers.push({
            fn : fn,
            delay : delay,
            elapsed : 0,
            repeat : true,
            timerId : ++this.timerId,
            pauseable : pauseable === true || true,
            args : args
        });
        return this.timerId;
    }

    /**
     * Clears the delay set by me.timer.setTimeout().
     * @name clearTimeout
     * @memberof timer
     * @param {number} timeoutID ID of the timeout to be cleared
     */
    clearTimeout(timeoutID) {
        utils.function.defer(this.clearTimer.bind(this), this, timeoutID);
    }

    /**
     * Clears the Interval set by me.timer.setInterval().
     * @name clearInterval
     * @memberof timer
     * @param {number} intervalID ID of the interval to be cleared
     */
    clearInterval(intervalID) {
        utils.function.defer(this.clearTimer.bind(this), this, intervalID);
    }

    /**
     * Return the current timestamp in milliseconds <br>
     * since the game has started or since linux epoch (based on browser support for High Resolution Timer)
     * @name getTime
     * @memberof timer
     * @returns {number}
     */
    getTime() {
        return this.now;
    }

    /**
     * Return elapsed time in milliseconds since the last update
     * @name getDelta
     * @memberof timer
     * @returns {number}
     */
    getDelta() {
        return this.delta;
    }

    /**
     * compute the actual frame time and fps rate
     * @name computeFPS
     * @ignore
     * @memberof timer
     */
    countFPS() {
        this.framecount++;
        this.framedelta += this.delta;
        if (this.framecount % 10 === 0) {
            this.fps = clamp(Math.round((1000 * this.framecount) / this.framedelta), 0, this.maxfps);
            this.framedelta = 0;
            this.framecount = 0;
        }
    }

    /**
     * update
     * @ignore
     */
    update(time) {
        this.last = this.now;
        this.now = time;
        this.delta = (this.now - this.last);

        // fix for negative timestamp returned by wechat or chrome on startup
        if (this.delta < 0) {
            this.delta = 0;
        }

        // get the game tick
        this.tick = (this.delta > this.minstep && this.interpolation) ? this.delta / this.step : 1;

        this.updateTimers();
    }

    /**
     * clear Timers
     * @ignore
     */
    clearTimer(timerId) {
        for (var i = 0, len = this.timers.length; i < len; i++) {
            if (this.timers[i].timerId === timerId) {
                this.timers.splice(i, 1);
                break;
            }
        }
    }


    /**
     * update timers
     * @ignore
     */
    updateTimers() {
        for (var i = 0, len = this.timers.length; i < len; i++) {
            var _timer = this.timers[i];
            if (!(_timer.pauseable && state.isPaused())) {
                _timer.elapsed += this.delta;
            }
            if (_timer.elapsed >= _timer.delay) {
                _timer.fn.apply(null, _timer.args);
                if (_timer.repeat === true) {
                    _timer.elapsed -= _timer.delay;
                } else {
                    this.clearTimeout(_timer.timerId);
                }
            }
        }
    }
}
/**
 * the default global Timer instance
 * @namespace timer
 * @see Timer
 * @example
 * // set a timer to call "myFunction" after 1000ms
 * timer.setTimeout(myFunction, 1000);
 * // set a timer to call "myFunction" after 1000ms (respecting the pause state) and passing param1 and param2
 * timer.setTimeout(myFunction, 1000, true, param1, param2);
 * // set a timer to call "myFunction" every 1000ms
 * timer.setInterval(myFunction, 1000);
 * // set a timer to call "myFunction" every 1000ms (respecting the pause state) and passing param1 and param2
 * timer.setInterval(myFunction, 1000, true, param1, param2);
 */
const timer = new Timer();

var lastTime = 0;
var vendors = ["ms", "moz", "webkit", "o"];
var x;

// standardized functions
// https://developer.mozilla.org/fr/docs/Web/API/Window/requestAnimationFrame
var requestAnimationFrame = globalThis.requestAnimationFrame;
var cancelAnimationFrame = globalThis.cancelAnimationFrame;

// get prefixed rAF and cAF is standard one not supported
for (x = 0; x < vendors.length && !requestAnimationFrame; ++x) {
    requestAnimationFrame = globalThis[vendors[x] + "RequestAnimationFrame"];
}
for (x = 0; x < vendors.length && !cancelAnimationFrame; ++x) {
    cancelAnimationFrame = globalThis[vendors[x] + "CancelAnimationFrame"] ||
                           globalThis[vendors[x] + "CancelRequestAnimationFrame"];
}

if (!requestAnimationFrame || !cancelAnimationFrame) {
    requestAnimationFrame = function (callback) {
        var currTime = globalThis.performance.now();
        var timeToCall = Math.max(0, (1000 / timer.maxfps) - (currTime - lastTime));
        var id = globalThis.setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };

    cancelAnimationFrame = function (id) {
        globalThis.clearTimeout(id);
    };

    // put back in global namespace
    globalThis.requestAnimationFrame = requestAnimationFrame;
    globalThis.cancelAnimationFrame = cancelAnimationFrame;
}

/*
 * based on https://www.npmjs.com/package/canvas-roundrect-polyfill
 * @version 0.0.1
 */
(() => {

  /** @ignore */
  function roundRect(x, y, w, h, radii) {

    if (!([x, y, w, h].every((input) => Number.isFinite(input)))) {

      return;

    }

    radii = parseRadiiArgument(radii);

    let upperLeft, upperRight, lowerRight, lowerLeft;

    if (radii.length === 4) {

      upperLeft = toCornerPoint(radii[0]);
      upperRight = toCornerPoint(radii[1]);
      lowerRight = toCornerPoint(radii[2]);
      lowerLeft = toCornerPoint(radii[3]);

    } else if (radii.length === 3) {

      upperLeft = toCornerPoint(radii[0]);
      upperRight = toCornerPoint(radii[1]);
      lowerLeft = toCornerPoint(radii[1]);
      lowerRight = toCornerPoint(radii[2]);

    } else if (radii.length === 2) {

      upperLeft = toCornerPoint(radii[0]);
      lowerRight = toCornerPoint(radii[0]);
      upperRight = toCornerPoint(radii[1]);
      lowerLeft = toCornerPoint(radii[1]);

    } else if (radii.length === 1) {

      upperLeft = toCornerPoint(radii[0]);
      upperRight = toCornerPoint(radii[0]);
      lowerRight = toCornerPoint(radii[0]);
      lowerLeft = toCornerPoint(radii[0]);

    } else {

      throw new Error(radii.length + " is not a valid size for radii sequence.");

    }

    const corners = [upperLeft, upperRight, lowerRight, lowerLeft];
    const negativeCorner = corners.find(({x, y}) => x < 0 || y < 0);
    //const negativeValue = negativeCorner?.x < 0 ? negativeCorner.x : negativeCorner?.y

    if (corners.some(({x, y}) => !Number.isFinite(x) || !Number.isFinite(y))) {

      return;

    }

    if (negativeCorner) {

      throw new Error("Radius value " + negativeCorner + " is negative.");

    }

    fixOverlappingCorners(corners);

    if (w < 0 && h < 0) {

      this.moveTo(x - upperLeft.x, y);
      this.ellipse(x + w + upperRight.x, y - upperRight.y, upperRight.x, upperRight.y, 0, -Math.PI * 1.5, -Math.PI);
      this.ellipse(x + w + lowerRight.x, y + h + lowerRight.y, lowerRight.x, lowerRight.y, 0, -Math.PI, -Math.PI / 2);
      this.ellipse(x - lowerLeft.x, y + h + lowerLeft.y, lowerLeft.x, lowerLeft.y, 0, -Math.PI / 2, 0);
      this.ellipse(x - upperLeft.x, y - upperLeft.y, upperLeft.x, upperLeft.y, 0, 0, -Math.PI / 2);

    } else if (w < 0) {

      this.moveTo(x - upperLeft.x, y);
      this.ellipse(x + w + upperRight.x, y + upperRight.y, upperRight.x, upperRight.y, 0, -Math.PI / 2, -Math.PI, 1);
      this.ellipse(x + w + lowerRight.x, y + h - lowerRight.y, lowerRight.x, lowerRight.y, 0, -Math.PI, -Math.PI * 1.5, 1);
      this.ellipse(x - lowerLeft.x, y + h - lowerLeft.y, lowerLeft.x, lowerLeft.y, 0, Math.PI / 2, 0, 1);
      this.ellipse(x - upperLeft.x, y + upperLeft.y, upperLeft.x, upperLeft.y, 0, 0, -Math.PI / 2, 1);

    } else if (h < 0) {

      this.moveTo(x + upperLeft.x, y);
      this.ellipse(x + w - upperRight.x, y - upperRight.y, upperRight.x, upperRight.y, 0, Math.PI / 2, 0, 1);
      this.ellipse(x + w - lowerRight.x, y + h + lowerRight.y, lowerRight.x, lowerRight.y, 0, 0, -Math.PI / 2, 1);
      this.ellipse(x + lowerLeft.x, y + h + lowerLeft.y, lowerLeft.x, lowerLeft.y, 0, -Math.PI / 2, -Math.PI, 1);
      this.ellipse(x + upperLeft.x, y - upperLeft.y, upperLeft.x, upperLeft.y, 0, -Math.PI, -Math.PI * 1.5, 1);

    } else {

      this.moveTo(x + upperLeft.x, y);
      this.ellipse(x + w - upperRight.x, y + upperRight.y, upperRight.x, upperRight.y, 0, -Math.PI / 2, 0);
      this.ellipse(x + w - lowerRight.x, y + h - lowerRight.y, lowerRight.x, lowerRight.y, 0, 0, Math.PI / 2);
      this.ellipse(x + lowerLeft.x, y + h - lowerLeft.y, lowerLeft.x, lowerLeft.y, 0, Math.PI / 2, Math.PI);
      this.ellipse(x + upperLeft.x, y + upperLeft.y, upperLeft.x, upperLeft.y, 0, Math.PI, Math.PI * 1.5);

    }

    this.closePath();
    this.moveTo(x, y);

    /** @ignore */
    function toDOMPointInit(value) {

      const {x, y, z, w} = value;
      return {x, y, z, w};

    }

    /** @ignore */
    function parseRadiiArgument(value) {

      // https://webidl.spec.whatwg.org/#es-union
      // with 'optional (unrestricted double or DOMPointInit
      //   or sequence<(unrestricted double or DOMPointInit)>) radii = 0'
      const type = typeof value;

      if (type === "undefined" || value === null) {

        return [0];

      }
      if (type === "function") {

        return [NaN];

      }
      if (type === "object") {

        if (typeof value[Symbol.iterator] === "function") {

          return [...value].map((elem) => {
            // https://webidl.spec.whatwg.org/#es-union
            // with '(unrestricted double or DOMPointInit)'
            const elemType = typeof elem;
            if (elemType === "undefined" || elem === null) {
              return 0;
            }
            if (elemType === "function") {
              return NaN;
            }
            if (elemType === "object") {
              return toDOMPointInit(elem);
            }
            return toUnrestrictedNumber(elem);
          });

        }

        return [toDOMPointInit(value)];

      }

      return [toUnrestrictedNumber(value)];

    }

    /** @ignore */
    function toUnrestrictedNumber(value) {

      return +value;

    }

    /** @ignore */
    function toCornerPoint(value) {

      const asNumber = toUnrestrictedNumber(value);
      if (Number.isFinite(asNumber)) {

        return {
          x: asNumber,
          y: asNumber
        };

      }
      if (Object(value) === value) {

        return {
          x: toUnrestrictedNumber(value.x || 0),
          y: toUnrestrictedNumber(value.y || 0)
        };

      }

      return {
        x: NaN,
        y: NaN
      };

    }

    /** @ignore */
    function fixOverlappingCorners(corners) {
      const [upperLeft, upperRight, lowerRight, lowerLeft] = corners;
      const factors = [
        Math.abs(w) / (upperLeft.x + upperRight.x),
        Math.abs(h) / (upperRight.y + lowerRight.y),
        Math.abs(w) / (lowerRight.x + lowerLeft.x),
        Math.abs(h) / (upperLeft.y + lowerLeft.y)
      ];
      const minFactor = Math.min(...factors);
      if (minFactor <= 1) {
        corners.forEach((radii) => {
            radii.x *= minFactor;
            radii.y *= minFactor;
        });
      }
    }
  }

  if (globalThis.CanvasRenderingContext2D) {
    if (typeof globalThis.Path2D.prototype.roundRect === "undefined") {
        globalThis.Path2D.prototype.roundRect = roundRect;
    }
  }
  if (globalThis.CanvasRenderingContext2D) {
    if (typeof globalThis.CanvasRenderingContext2D.prototype.roundRect === "undefined") {
        globalThis.CanvasRenderingContext2D.prototype.roundRect = roundRect;
    }
  }
  if (globalThis.OffscreenCanvasRenderingContext2D) {
    if (typeof globalThis.OffscreenCanvasRenderingContext2D.prototype.roundRect === "undefined") {
        globalThis.OffscreenCanvasRenderingContext2D.prototype.roundRect = roundRect;
    }
  }

})();

/**
 * This namespace is a container for all registered plugins.
 * @see plugin.register
 * @namespace plugins
 */
var plugins = {};


class BasePlugin {

    constructor() {
        /**
         * define the minimum required version of melonJS<br>
         * this can be overridden by the plugin
         * @public
         * @type {string}
         * @default "12.0.0"
         * @name plugin.Base#version
         */
        this.version = "12.0.0";
    }
}

/**
 * @namespace plugin
 */
var plugin = {

    /**
     * a base Object for plugin <br>
     * plugin must be installed using the register function
     * @see plugin
     * @class
     * @name Base
     * @memberof plugin
     */
    Base : BasePlugin,

    /**
     * patch a melonJS function
     * @name patch
     * @memberof plugin
     * @public
     * @param {object} proto target object
     * @param {string} name target function
     * @param {Function} fn replacement function
     * @example
     * // redefine the me.game.update function with a new one
     * me.plugin.patch(me.game, "update", function () {
     *   // display something in the console
     *   console.log("duh");
     *   // call the original me.game.update function
     *   this._patched();
     * });
     */
    patch : function (proto, name, fn) {
        // use the object prototype if possible
        if (typeof proto.prototype !== "undefined") {
            proto = proto.prototype;
        }
        // reuse the logic behind object extends
        if (typeof(proto[name]) === "function") {
            // save the original function
            var _parent = proto[name];
            // override the function with the new one
            Object.defineProperty(proto, name, {
                "configurable" : true,
                "value" : (function (name, fn) {
                    return function () {
                        this._patched = _parent;
                        var ret = fn.apply(this, arguments);
                        this._patched = null;
                        return ret;
                    };
                })(name, fn)
            });
        }
        else {
            throw new Error(name + " is not an existing function");
        }
    },

    /**
     * Register a plugin.
     * @name register
     * @memberof plugin
     * @see Base
     * @public
     * @param {plugin.Base} pluginObj Plugin object to instantiate and register
     * @param {string} name
     * @param {object} [...arguments] all extra parameters will be passed to the plugin constructor
     * @example
     * // register a new plugin
     * me.plugin.register(TestPlugin, "testPlugin");
     * // the plugin then also become available
     * // under then me.plugins namespace
     * me.plugins.testPlugin.myfunction ();
     */
    register : function (pluginObj, name) {
        // ensure me.plugins[name] is not already "used"
        if (plugins[name]) {
            throw new Error("plugin " + name + " already registered");
        }

        // get extra arguments
        var _args = [];
        if (arguments.length > 2) {
            // store extra arguments if any
            _args = Array.prototype.slice.call(arguments, 1);
        }

        // try to instantiate the plugin
        _args[0] = pluginObj;
        var instance = new (pluginObj.bind.apply(pluginObj, _args))();

        // inheritance check
        if (typeof instance === "undefined" || !(instance instanceof plugin.Base)) {
            throw new Error("Plugin should extend the me.plugin.Base Class !");
        }

        // compatibility testing
        if (utils.checkVersion(instance.version) > 0) {
            throw new Error("Plugin version mismatch, expected: " + instance.version + ", got: " + version);
        }

        // create a reference to the new plugin
        plugins[name] = instance;
    }
};

/*
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 */

/* eslint-disable quotes, keyword-spacing, comma-spacing, no-return-assign */

/**
 * Easing Function :<br>
 * <p>
 * Easing.Linear.None<br>
 * Easing.Quadratic.In<br>
 * Easing.Quadratic.Out<br>
 * Easing.Quadratic.InOut<br>
 * Easing.Cubic.In<br>
 * Easing.Cubic.Out<br>
 * Easing.Cubic.InOut<br>
 * Easing.Quartic.In<br>
 * Easing.Quartic.Out<br>
 * Easing.Quartic.InOut<br>
 * Easing.Quintic.In<br>
 * Easing.Quintic.Out<br>
 * Easing.Quintic.InOut<br>
 * Easing.Sinusoidal.In<br>
 * Easing.Sinusoidal.Out<br>
 * Easing.Sinusoidal.InOut<br>
 * Easing.Exponential.In<br>
 * Easing.Exponential.Out<br>
 * Easing.Exponential.InOut<br>
 * Easing.Circular.In<br>
 * Easing.Circular.Out<br>
 * Easing.Circular.InOut<br>
 * Easing.Elastic.In<br>
 * Easing.Elastic.Out<br>
 * Easing.Elastic.InOut<br>
 * Easing.Back.In<br>
 * Easing.Back.Out<br>
 * Easing.Back.InOut<br>
 * Easing.Bounce.In<br>
 * Easing.Bounce.Out<br>
 * Easing.Bounce.InOut
 * </p>
 * @public
 * @constant
 * @enum {Function}
 * @name Easing
 * @memberof Tween
 */
let Easing = {

    Linear: {
        /** @ignore */
        None: function ( k ) {

            return k;

        }

    },

    Quadratic: {
        /** @ignore */
        In: function ( k ) {

            return k * k;

        },
        /** @ignore */
        Out: function ( k ) {

            return k * ( 2 - k );

        },
        /** @ignore */
        InOut: function ( k ) {

            if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
            return - 0.5 * ( --k * ( k - 2 ) - 1 );

        }

    },

    Cubic: {
        /** @ignore */
        In: function ( k ) {

            return k * k * k;

        },
        /** @ignore */
        Out: function ( k ) {

            return --k * k * k + 1;

        },
        /** @ignore */
        InOut: function ( k ) {

            if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
            return 0.5 * ( ( k -= 2 ) * k * k + 2 );

        }

    },

    Quartic: {
        /** @ignore */
        In: function ( k ) {

            return k * k * k * k;

        },
        /** @ignore */
        Out: function ( k ) {

            return 1 - ( --k * k * k * k );

        },
        /** @ignore */
        InOut: function ( k ) {

            if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
            return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );

        }

    },

    Quintic: {
        /** @ignore */
        In: function ( k ) {

            return k * k * k * k * k;

        },
        /** @ignore */
        Out: function ( k ) {

            return --k * k * k * k * k + 1;

        },
        /** @ignore */
        InOut: function ( k ) {

            if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
            return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

        }

    },

    Sinusoidal: {
        /** @ignore */
        In: function ( k ) {

            return 1 - Math.cos( k * Math.PI / 2 );

        },
        /** @ignore */
        Out: function ( k ) {

            return Math.sin( k * Math.PI / 2 );

        },
        /** @ignore */
        InOut: function ( k ) {

            return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

        }

    },

    Exponential: {
        /** @ignore */
        In: function ( k ) {

            return k === 0 ? 0 : Math.pow( 1024, k - 1 );

        },
        /** @ignore */
        Out: function ( k ) {

            return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );

        },
        /** @ignore */
        InOut: function ( k ) {

            if ( k === 0 ) return 0;
            if ( k === 1 ) return 1;
            if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
            return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );

        }

    },

    Circular: {
        /** @ignore */
        In: function ( k ) {

            return 1 - Math.sqrt( 1 - k * k );

        },
        /** @ignore */
        Out: function ( k ) {

            return Math.sqrt( 1 - ( --k * k ) );

        },
        /** @ignore */
        InOut: function ( k ) {

            if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
            return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);

        }

    },

    Elastic: {
        /** @ignore */
        In: function ( k ) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
        },
        /** @ignore */
        Out: function ( k ) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;

        },
        /** @ignore */
        InOut: function ( k ) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            k *= 2;
            if (k < 1) {
                return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
            }
            return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
        }

    },

    Back: {
        /** @ignore */
        In: function ( k ) {

            var s = 1.70158;
            return k * k * ( ( s + 1 ) * k - s );

        },
        /** @ignore */
        Out: function ( k ) {

            var s = 1.70158;
            return --k * k * ( ( s + 1 ) * k + s ) + 1;

        },
        /** @ignore */
        InOut: function ( k ) {

            var s = 1.70158 * 1.525;
            if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
            return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

        }

    },

    Bounce: {
        /** @ignore */
        In: function ( k ) {

            return 1 - Easing.Bounce.Out( 1 - k );

        },
        /** @ignore */
        Out: function ( k ) {

            if ( k < ( 1 / 2.75 ) ) {

                return 7.5625 * k * k;

            } else if ( k < ( 2 / 2.75 ) ) {

                return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

            } else if ( k < ( 2.5 / 2.75 ) ) {

                return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

            } else {

                return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

            }

        },
        /** @ignore */
        InOut: function ( k ) {

            if ( k < 0.5 ) return Easing.Bounce.In( k * 2 ) * 0.5;
            return Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;

        }

    }

};

/*
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 */

/**
 * Interpolation Function :<br>
 * <p>
 * Interpolation.Linear<br>
 * Interpolation.Bezier<br>
 * Interpolation.CatmullRom
 * </p>
 * @public
 * @constant
 * @enum {Function}
 * @name Interpolation
 * @memberof Tween
 */
let Interpolation = {
    /** @ignore */
    Linear: function ( v, k ) {

        var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = Interpolation.Utils.Linear;

        if ( k < 0 ) return fn( v[ 0 ], v[ 1 ], f );
        if ( k > 1 ) return fn( v[ m ], v[ m - 1 ], m - f );

        return fn( v[ i ], v[ i + 1 > m ? m : i + 1 ], f - i );

    },
    /** @ignore */
    Bezier: function ( v, k ) {

        var b = 0, n = v.length - 1, pw = Math.pow, bn = Interpolation.Utils.Bernstein, i;

        for ( i = 0; i <= n; i++ ) {
            b += pw( 1 - k, n - i ) * pw( k, i ) * v[ i ] * bn( n, i );
        }

        return b;

    },
    /** @ignore */
    CatmullRom: function ( v, k ) {

        var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = Interpolation.Utils.CatmullRom;

        if ( v[ 0 ] === v[ m ] ) {

            if ( k < 0 ) i = Math.floor( f = m * ( 1 + k ) );

            return fn( v[ ( i - 1 + m ) % m ], v[ i ], v[ ( i + 1 ) % m ], v[ ( i + 2 ) % m ], f - i );

        } else {

            if ( k < 0 ) return v[ 0 ] - ( fn( v[ 0 ], v[ 0 ], v[ 1 ], v[ 1 ], -f ) - v[ 0 ] );
            if ( k > 1 ) return v[ m ] - ( fn( v[ m ], v[ m ], v[ m - 1 ], v[ m - 1 ], f - m ) - v[ m ] );

            return fn( v[ i ? i - 1 : 0 ], v[ i ], v[ m < i + 1 ? m : i + 1 ], v[ m < i + 2 ? m : i + 2 ], f - i );

        }

    },

    Utils: {
        /** @ignore */
        Linear: function ( p0, p1, t ) {

            return ( p1 - p0 ) * t + p0;

        },
        /** @ignore */
        Bernstein: function ( n, i ) {

            var fc = Interpolation.Utils.Factorial;
            return fc( n ) / fc( i ) / fc( n - i );

        },
        /* @ignore */
        Factorial: ( function () {

            var a = [ 1 ];

            return function ( n ) {

                var s = 1, i;
                if ( a[ n ] ) return a[ n ];
                for ( i = n; i > 1; i-- ) s *= i;
                a[ n ] = s;
                return s;

            };

        } )(),
        /** @ignore */
        CatmullRom: function ( p0, p1, p2, p3, t ) {

            var v0 = ( p2 - p0 ) * 0.5, v1 = ( p3 - p1 ) * 0.5, t2 = t * t, t3 = t * t2;
            return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
        }
    }

};

/*
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 */

/**
 * @classdesc
 * Javascript Tweening Engine<p>
 * Super simple, fast and easy to use tweening engine which incorporates optimised Robert Penner's equation<p>
 * <a href="https://github.com/sole/Tween.js">https://github.com/sole/Tween.js</a><p>
 * author sole / http://soledadpenades.com<br>
 * author mr.doob / http://mrdoob.com<br>
 * author Robert Eisele / http://www.xarg.org<br>
 * author Philippe / http://philippe.elsass.me<br>
 * author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html<br>
 * author Paul Lewis / http://www.aerotwist.com/<br>
 * author lechecacharro<br>
 * author Josh Faul / http://jocafa.com/
 */
class Tween {

    /**
     * @param {object} object object on which to apply the tween
     * @example
     * // add a tween to change the object pos.x and pos.y variable to 200 in 3 seconds
     * tween = new me.Tween(myObject.pos).to({
     *       x: 200,
     *       y: 200,
     *    }, {
     *       duration: 3000,
     *       easing: me.Tween.Easing.Bounce.Out,
     *       autoStart : true
     * }).onComplete(myFunc);
     */
    constructor ( object ) {
        this.setProperties(object);
    }

    /**
     * reset the tween object to default value
     * @ignore
     */
    onResetEvent( object ) {
        this.setProperties(object);
    }

    /**
     * @ignore
     */
    setProperties(object) {
        this._object = object;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1000;
        this._repeat = 0;
        this._yoyo = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = null;
        this._easingFunction = Easing.Linear.None;
        this._interpolationFunction = Interpolation.Linear;
        this._chainedTweens = [];
        this._onStartCallback = null;
        this._onStartCallbackFired = false;
        this._onUpdateCallback = null;
        this._onCompleteCallback = null;
        // tweens are synchronized with the game update loop
        this._tweenTimeTracker = lastUpdate;

        // reset flags to default value
        this.isPersistent = false;
        // this is not really supported
        this.updateWhenPaused = false;
        // comply with the container contract
        this.isRenderable = false;

        // Set all starting values present on the target object
        for ( var field in object ) {
            if (typeof object !== "object") {
                this._valuesStart[ field ] = parseFloat(object[field]);
            }
        }
    }

    /**
     * @ignore
     */
    _resumeCallback(elapsed) {
        if (this._startTime) {
            this._startTime += elapsed;
        }
    }



    /**
     * subscribe to the resume event when added
     * @ignore
     */
    onActivateEvent() {
        on(STATE_RESUME, this._resumeCallback, this);
    }

    /**
     * Unsubscribe when tween is removed
     * @ignore
     */
    onDeactivateEvent() {
        off(STATE_RESUME, this._resumeCallback);
    }

    /**
     * object properties to be updated and duration
     * @name to
     * @memberof Tween
     * @public
     * @param {object} properties hash of properties
     * @param {object|number} [options] object of tween properties, or a duration if a numeric value is passed
     * @param {number} [options.duration] tween duration
     * @param {Tween.Easing} [options.easing] easing function
     * @param {number} [options.delay] delay amount expressed in milliseconds
     * @param {boolean} [options.yoyo] allows the tween to bounce back to their original value when finished. To be used together with repeat to create endless loops.
     * @param {number} [options.repeat] amount of times the tween should be repeated
     * @param {Tween.Interpolation} [options.interpolation] interpolation function
     * @param {boolean} [options.autoStart] allow this tween to start automatically. Otherwise call me.Tween.start().
     * @returns {Tween} this instance for object chaining
     */
    to( properties, options ) {

        this._valuesEnd = properties;

        if (typeof options !== "undefined") {
            if (typeof options === "number") {
                // for backward compatiblity
                this._duration = options;
            } else if (typeof options === "object") {
                if (options.duration) { this._duration = options.duration; }
                if (options.yoyo) { this.yoyo(options.yoyo); }
                if (options.easing) { this.easing(options.easing); }
                if (options.repeat) { this.repeat(options.repeat); }
                if (options.delay) { this.delay(options.delay); }
                if (options.interpolation) { this.interpolation(options.interpolation); }

                if (options.autoStart) {
                    this.start();
                }
            }
        }

        return this;
    }

    /**
     * start the tween
     * @name start
     * @memberof Tween
     * @public
     * @param {number} [time] the current time when the tween was started
     * @returns {Tween} this instance for object chaining
     */
    start( time = timer.getTime() ) {

        this._onStartCallbackFired = false;

        // add the tween to the object pool on start
        world.addChild(this);

        this._startTime =  time + this._delayTime;

        for ( var property in this._valuesEnd ) {

            // check if an Array was provided as property value
            if ( this._valuesEnd[ property ] instanceof Array ) {

                if ( this._valuesEnd[ property ].length === 0 ) {

                    continue;

                }

                // create a local copy of the Array with the start value at the front
                this._valuesEnd[ property ] = [ this._object[ property ] ].concat( this._valuesEnd[ property ] );

            }

            this._valuesStart[ property ] = this._object[ property ];

            if ( ( this._valuesStart[ property ] instanceof Array ) === false ) {
                this._valuesStart[ property ] *= 1.0; // Ensures we're using numbers, not strings
            }

            this._valuesStartRepeat[ property ] = this._valuesStart[ property ] || 0;

        }

        return this;
    }

    /**
     * stop the tween
     * @name stop
     * @memberof Tween
     * @public
     * @returns {Tween} this instance for object chaining
     */
    stop() {
        // remove the tween from the world container
        world.removeChildNow(this);
        return this;
    }

    /**
     * delay the tween
     * @name delay
     * @memberof Tween
     * @public
     * @param {number} amount delay amount expressed in milliseconds
     * @returns {Tween} this instance for object chaining
     */
    delay( amount ) {

        this._delayTime = amount;
        return this;

    }

    /**
     * Repeat the tween
     * @name repeat
     * @memberof Tween
     * @public
     * @param {number} times amount of times the tween should be repeated
     * @returns {Tween} this instance for object chaining
     */
    repeat( times ) {

        this._repeat = times;
        return this;

    }

    /**
     * Allows the tween to bounce back to their original value when finished.
     * To be used together with repeat to create endless loops.
     * @name yoyo
     * @memberof Tween
     * @public
     * @see Tween#repeat
     * @param {boolean} yoyo
     * @returns {Tween} this instance for object chaining
     */
    yoyo( yoyo ) {

        this._yoyo = yoyo;
        return this;

    }

    /**
     * set the easing function
     * @name easing
     * @memberof Tween
     * @public
     * @param {Tween.Easing} easing easing function
     * @returns {Tween} this instance for object chaining
     */
    easing( easing ) {
        if (typeof easing !== "function") {
            throw new Error("invalid easing function for me.Tween.easing()");
        }
        this._easingFunction = easing;
        return this;
    }

    /**
     * set the interpolation function
     * @name interpolation
     * @memberof Tween
     * @public
     * @param {Tween.Interpolation} interpolation interpolation function
     * @returns {Tween} this instance for object chaining
     */
    interpolation( interpolation ) {
        this._interpolationFunction = interpolation;
        return this;
    }

    /**
     * chain the tween
     * @name chain
     * @memberof Tween
     * @public
     * @param {...Tween} chainedTween Tween(s) to be chained
     * @returns {Tween} this instance for object chaining
     */
    chain() {
        this._chainedTweens = arguments;
        return this;
    }

    /**
     * onStart callback
     * @name onStart
     * @memberof Tween
     * @public
     * @param {Function} onStartCallback callback
     * @returns {Tween} this instance for object chaining
     */
    onStart( onStartCallback ) {
        this._onStartCallback = onStartCallback;
        return this;
    }

    /**
     * onUpdate callback
     * @name onUpdate
     * @memberof Tween
     * @public
     * @param {Function} onUpdateCallback callback
     * @returns {Tween} this instance for object chaining
     */
    onUpdate( onUpdateCallback ) {
        this._onUpdateCallback = onUpdateCallback;
        return this;
    }

    /**
     * onComplete callback
     * @name onComplete
     * @memberof Tween
     * @public
     * @param {Function} onCompleteCallback callback
     * @returns {Tween} this instance for object chaining
     */
    onComplete( onCompleteCallback ) {
        this._onCompleteCallback = onCompleteCallback;
        return this;
    };

    /** @ignore */
    update( dt ) {

        // the original Tween implementation expect
        // a timestamp and not a time delta
        this._tweenTimeTracker = (lastUpdate > this._tweenTimeTracker) ? lastUpdate : this._tweenTimeTracker + dt;
        var time = this._tweenTimeTracker;

        var property;

        if ( time < this._startTime ) {

            return true;

        }

        if ( this._onStartCallbackFired === false ) {

            if ( this._onStartCallback !== null ) {

                this._onStartCallback.call( this._object );

            }

            this._onStartCallbackFired = true;

        }

        var elapsed = ( time - this._startTime ) / this._duration;
        elapsed = elapsed > 1 ? 1 : elapsed;

        var value = this._easingFunction( elapsed );

        for ( property in this._valuesEnd ) {

            var start = this._valuesStart[ property ] || 0;
            var end = this._valuesEnd[ property ];

            if ( end instanceof Array ) {

                this._object[ property ] = this._interpolationFunction( end, value );

            } else {

                // Parses relative end values with start as base (e.g.: +10, -3)
                if ( typeof(end) === "string" ) {
                    end = start + parseFloat(end);
                }

                // protect against non numeric properties.
                if ( typeof(end) === "number" ) {
                    this._object[ property ] = start + ( end - start ) * value;
                }

            }

        }

        if ( this._onUpdateCallback !== null ) {

            this._onUpdateCallback.call( this._object, value );

        }

        if ( elapsed === 1 ) {

            if ( this._repeat > 0 ) {

                if ( isFinite( this._repeat ) ) {
                    this._repeat--;
                }

                // reassign starting values, restart by making startTime = now
                for ( property in this._valuesStartRepeat ) {

                    if ( typeof( this._valuesEnd[ property ] ) === "string" ) {
                        this._valuesStartRepeat[ property ] = this._valuesStartRepeat[ property ] + parseFloat(this._valuesEnd[ property ]);
                    }

                    if (this._yoyo) {
                        var tmp = this._valuesStartRepeat[ property ];
                        this._valuesStartRepeat[ property ] = this._valuesEnd[ property ];
                        this._valuesEnd[ property ] = tmp;
                    }
                    this._valuesStart[ property ] = this._valuesStartRepeat[ property ];

                }

                if (this._yoyo) {
                    this._reversed = !this._reversed;
                }

                this._startTime = time + this._delayTime;

                return true;

            } else {
                // remove the tween from the world container
                world.removeChildNow(this);

                if ( this._onCompleteCallback !== null ) {

                    this._onCompleteCallback.call( this._object );

                }

                for ( var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i ++ ) {

                    this._chainedTweens[ i ].start( time );

                }

                return false;

            }

        }
        return true;
    }

    // export easing function as static class property
    static get Easing() { return Easing; }
    static get Interpolation() { return Interpolation; }
}

// default video settings
var defaultAttributes = {
    offscreenCanvas : false,
    willReadFrequently : false
};

/**
 * Creates a Canvas Texture of the given size
 */
class CanvasTexture {
    /**
     * @param {number} width the desired width of the canvas
     * @param {number} height the desired height of the canvas
     * @param {object} attributes The attributes to create both the canvas and 2d context
     * @param {boolean} [attributes.offscreenCanvas=false] will create an offscreenCanvas if true instead of a standard canvas
     * @param {boolean} [attributes.willReadFrequently=false] Indicates whether or not a lot of read-back operations are planned
     */
    constructor(width, height, attributes = defaultAttributes) {

        // clean up the given attributes
        attributes = Object.assign(defaultAttributes, attributes || {});

        /**
         * the canvas created for this CanvasTexture
         * @type {HTMLCanvasElement|OffscreenCanvas}
         */
        this.canvas = createCanvas(width, height, attributes.offscreenCanvas);

        /**
         * the rendering context of this CanvasTexture
         * @type {CanvasRenderingContext2D}
         */
        this.context = this.canvas.getContext("2d", { willReadFrequently: attributes.willReadFrequently });
    }

    /**
     * @ignore
     */
    onResetEvent(width, height) {
        this.clear();
        this.resize(width, height);
    }

    /**
     * Clears the content of the canvas texture
     */
    clear() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Resizes the canvas texture to the given width and height.
     * @param {number} width the desired width
     * @param {number} height the desired height
     */
    resize(width, height) {
        this.canvas.width = Math.round(width);
        this.canvas.height = Math.round(height);
    }

    /**
     * @ignore
     */
    destroy() {
        this.context = undefined;
        this.canvas = undefined;
    }

    /**
     * The width of this canvas texture in pixels
     * @public
     * @type {number}
     */
    get width() {
        return this.canvas.width;
    }

    set width(val) {
        this.canvas.width = Math.round(val);
    }

    /**
     * The height of this canvas texture in pixels
     * @public
     * @type {number}
     */
    get height() {
        return this.canvas.height;
    }

    set height(val) {
        this.canvas.height = Math.round(val);
    }
}

/**
 * apply the current text style to the given context
 * @ignore
 */
function setContextStyle(context, style, stroke = false) {
    context.font = style.font;
    context.fillStyle = style.fillStyle.toRGBA();
    if (stroke === true) {
        context.strokeStyle = style.strokeStyle.toRGBA();
        context.lineWidth = style.lineWidth;
    }
    context.textAlign = style.textAlign;
    context.textBaseline = style.textBaseline;
}

/**
 * @classdesc
 * a Text Metrics object that contains helper for text manipulation
 * @augments Bounds
 */
class TextMetrics extends Bounds {

    /**
     * @param {Text|BitmapText} ancestor the parent object that contains this TextMetrics object
     */
    constructor(ancestor) {

        // parent constructor
        super();

        /**
         * a reference to the parent object that contains this TextMetrics object
         * @public
         * @type {Renderable}
         * @default undefined
         */
        this.ancestor = ancestor;

        this.setMinMax(0, 0, 0, 0);
    }

    /**
     * Returns the height of a segment of inline text in CSS pixels.
     * @returns {number} the height of a segment of inline text in CSS pixels.
     */
    lineHeight() {
        if (this.ancestor instanceof Text) {
            return this.ancestor.fontSize * this.ancestor.lineHeight;
        } else { // it's a BitmapText
            return this.ancestor.fontData.capHeight * this.ancestor.lineHeight * this.ancestor.fontScale.y;
        }
    }

    /**
     * Returns the width of the given segment of inline text in CSS pixels.
     * @param {string} text the text to be measured
     * @param {CanvasRenderingContext2D} [context] reference to an active 2d context for canvas rendering
     * @returns {number} the width of the given segment of inline text in CSS pixels.
     */
    lineWidth(text, context) {
        if (this.ancestor instanceof Text) {
            return context.measureText(text).width;
        } else { // it's a BitmapText
            var characters = text.split("");
            var width = 0;
            var lastGlyph = null;
            for (var i = 0; i < characters.length; i++) {
                var ch = characters[i].charCodeAt(0);
                var glyph = this.ancestor.fontData.glyphs[ch];
                var kerning = (lastGlyph && lastGlyph.kerning) ? lastGlyph.getKerning(ch) : 0;
                width += (glyph.xadvance + kerning) * this.ancestor.fontScale.x;
                lastGlyph = glyph;
            }
            return width;
        }
    }

    /**
     * measure the given text size in CSS pixels
     * @param {string} text the text to be measured
     * @param {CanvasRenderingContext2D} [context] reference to an active 2d context for canvas rendering
     * @returns {TextMetrics} this
     */
    measureText(text, context) {
        var strings;

        if (!Array.isArray(text)) {
            strings = ("" + text).split("\n");
        } else {
            strings = text;
        }

        if (typeof context !== "undefined") {
            // save the previous context
            context.save();

            // apply the style font
            setContextStyle(context, this.ancestor);
        }

        // compute the bounding box size
        this.width = this.height = 0;

        for (var i = 0; i < strings.length; i++) {
            this.width = Math.max(this.lineWidth(strings[i].trimRight(), context), this.width);
            this.height += this.lineHeight();
        }
        this.width = Math.ceil(this.width);
        this.height = Math.ceil(this.height);

        // compute the bounding box position
        this.x = Math.floor((this.ancestor.textAlign === "right" ? this.ancestor.pos.x - this.width : (
            this.ancestor.textAlign === "center" ? this.ancestor.pos.x - (this.width / 2) : this.ancestor.pos.x
        )));
        this.y = Math.floor((this.ancestor.textBaseline.search(/^(top|hanging)$/) === 0) ? this.ancestor.pos.y : (
            this.ancestor.textBaseline === "middle" ? this.ancestor.pos.y - (this.lineHeight() / 2) : this.ancestor.pos.y - this.lineHeight()
        ));

        if (typeof context !== "undefined") {
            // restore the context
            context.restore();
        }

        return this;
    }

    /**
     * wrap the given text based on the given width
     * @param {string|string[]} text the text to be wrapped
     * @param {number} width maximum width of one segment of text in css pixel
     * @param {CanvasRenderingContext2D} [context] reference to an active 2d context for canvas rendering
     * @returns {string[]} an array of string representing wrapped text
     */
    wordWrap(text, width, context) {
        var words;
        var currentLine = "";
        var output = [];

        if (Array.isArray(text)) {
            // join into a single string
            text = text.join(" ");
        }
        // word splitting to be improved as it replaces \n by space if present
        words = text.replace(/[\r\n]+/g, " ").split(" ");

        if (typeof context !== "undefined") {
            // save the previous context
            context.save();

            // apply the style font
            setContextStyle(context, this.ancestor);
        }

        for (let i = 0; i < words.length; i++) {
            var word = words[i];
            var lineWidth = this.lineWidth(currentLine + word + " ", context);
            if (lineWidth < width) {
                // add the word to the current line
                currentLine += word + " ";
            } else {
                output.push(currentLine + "\n");
                currentLine = word + " ";
            }
        }
        // last line
        output.push(currentLine);

        if (typeof context !== "undefined") {
            // restore the context
            context.restore();
        }

        return output;
    }
}

/*
* ASCII Table
* http://www.asciitable.com/
* [ !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz]
*
* -> first char " " 32d (0x20);
*/


const runits = ["ex", "em", "pt", "px"];
const toPX = [12, 24, 0.75, 1];

// return a valid 2d context for Text rendering/styling
var getContext2d = function (renderer$1, text) {
    if (text.offScreenCanvas === true) {
        return text.canvasTexture.context;
    } else {
        if (typeof renderer$1 === "undefined") {
            renderer$1 = renderer;
        }
        return renderer$1.getFontContext();
    }
};

/**
 * @classdesc
 * a generic system font object.
 * @augments Renderable
 */
class Text extends Renderable {
    /**
     * @param {number} x position of the text object
     * @param {number} y position of the text object
     * @param {object} settings the text configuration
     * @param {string} settings.font a CSS family font name
     * @param {number|string} settings.size size, or size + suffix (px, em, pt)
     * @param {Color|string} [settings.fillStyle="#000000"] a CSS color value
     * @param {Color|string} [settings.strokeStyle="#000000"] a CSS color value
     * @param {number} [settings.lineWidth=1] line width, in pixels, when drawing stroke
     * @param {string} [settings.textAlign="left"] horizontal text alignment
     * @param {string} [settings.textBaseline="top"] the text baseline
     * @param {number} [settings.lineHeight=1.0] line spacing height
     * @param {Vector2d} [settings.anchorPoint={x:0.0, y:0.0}] anchor point to draw the text at
     * @param {boolean} [settings.offScreenCanvas=false] whether to draw the font to an individual "cache" texture first
     * @param {number} [settings.wordWrapWidth] the maximum length in CSS pixel for a single segment of text
     * @param {(string|string[])} [settings.text=""] a string, or an array of strings
     * @example
     * var font = new me.Text(0, 0, {font: "Arial", size: 8, fillStyle: this.color});
     */
    constructor(x, y, settings) {
        // call the parent constructor
        super(x, y, settings.width || 0, settings.height || 0);
        this.onResetEvent(x, y, settings);
    }

    /** @ignore */
    onResetEvent(x, y, settings) {

        /**
         * defines the color used to draw the font.<br>
         * @public
         * @member {Color}
         * @name Text#fillStyle
         * @default black
         */
        if (typeof settings.fillStyle !== "undefined") {
            if (settings.fillStyle instanceof Color) {
                this.fillStyle = settings.fillStyle;
            } else {
                // string (#RGB, #ARGB, #RRGGBB, #AARRGGBB)
                this.fillStyle = pool.pull("Color").parseCSS(settings.fillStyle);
            }
        } else {
            this.fillStyle = pool.pull("Color", 0, 0, 0);
        }

        /**
         * defines the color used to draw the font stroke.<br>
         * @public
         * @member {Color}
         * @name strokeStyle
         * @default black
         */
         if (typeof settings.strokeStyle !== "undefined") {
             if (settings.strokeStyle instanceof Color) {
                 this.strokeStyle = settings.strokeStyle;
             } else {
                 // string (#RGB, #ARGB, #RRGGBB, #AARRGGBB)
                 this.strokeStyle = pool.pull("Color").parseCSS(settings.strokeStyle);
             }
         } else {
             this.strokeStyle = pool.pull("Color", 0, 0, 0);
         }

        /**
         * sets the current line width, in pixels, when drawing stroke
         * @public
         * @type {number}
         * @default 1
         */
        this.lineWidth = settings.lineWidth || 1;

        /**
         * Set the default text alignment (or justification),<br>
         * possible values are "left", "right", and "center".<br>
         * @public
         * @type {string}
         * @default "left"
         */
        this.textAlign = settings.textAlign || "left";

        /**
         * Set the text baseline (e.g. the Y-coordinate for the draw operation), <br>
         * possible values are "top", "hanging, "middle, "alphabetic, "ideographic, "bottom"<br>
         * @public
         * @type {string}
         * @default "top"
         */
        this.textBaseline = settings.textBaseline || "top";

        /**
         * Set the line spacing height (when displaying multi-line strings). <br>
         * Current font height will be multiplied with this value to set the line height.
         * @public
         * @type {number}
         * @default 1.0
         */
        this.lineHeight = settings.lineHeight || 1.0;

        /**
         * whether to draw the font to a indidividual offscreen canvas texture first <br>
         * Note: this will improve performances when using WebGL, but will impact
         * memory consumption as every text element will have its own canvas texture
         * @public
         * @type {boolean}
         * @default false
         */
        this.offScreenCanvas = false;

        /**
         * the maximum length in CSS pixel for a single segment of text.
         * (use -1 to disable word wrapping)
         * @public
         * @type {number}
         * @default -1
         */
        this.wordWrapWidth = settings.wordWrapWidth || -1;

        /**
         * the text to be displayed
         * @private
         */
        this._text = [];

        /**
         * the font size (in px)
         * @public
         * @type {number}
         * @default 10
         */
        this.fontSize = 10;

        // anchor point
        if (typeof settings.anchorPoint !== "undefined") {
            this.anchorPoint.setV(settings.anchorPoint);
        } else {
            this.anchorPoint.set(0, 0);
        }

        // if floating was specified through settings
        if (typeof settings.floating !== "undefined") {
            this.floating = !!settings.floating;
        }

        // font name and type
        this.setFont(settings.font, settings.size);

        // aditional
        if (settings.bold === true) {
            this.bold();
        }
        if (settings.italic === true) {
            this.italic();
        }

        if (settings.offScreenCanvas === true) {
            this.offScreenCanvas = true;
            this.canvasTexture = pool.pull("CanvasTexture", 2, 2, { offscreenCanvas: true });
        }

        // instance to text metrics functions
        this.metrics = new TextMetrics(this);

        // set the text
        this.setText(settings.text);
    }

    /** @ignore */
    onDeactivateEvent() {
        // free the canvas and potential corresponding texture when deactivated
        if (this.offScreenCanvas === true) {
            renderer.currentCompositor.deleteTexture2D(renderer.currentCompositor.getTexture2D(this.glTextureUnit));
            renderer.cache.delete(this.canvasTexture.canvas);
            pool.push(this.canvasTexture);
            this.canvasTexture = undefined;
            this.glTextureUnit = undefined;
        }
    }

    /**
     * make the font bold
     * @returns {Text} this object for chaining
     */
    bold() {
        this.font = "bold " + this.font;
        this.isDirty = true;
        return this;
    }

    /**
     * make the font italic
     * @returns {Text} this object for chaining
     */
    italic() {
        this.font = "italic " + this.font;
        this.isDirty = true;
        return this;
    }

    /**
     * set the font family and size
     * @param {string} font a CSS font name
     * @param {number|string} [size=10] size in px, or size + suffix (px, em, pt)
     * @returns {Text} this object for chaining
     * @example
     * font.setFont("Arial", 20);
     * font.setFont("Arial", "1.5em");
     */
    setFont(font, size = 10) {
        // font name and type
        var font_names = font.split(",").map(function (value) {
            value = value.trim();
            return (
                !/(^".*"$)|(^'.*'$)/.test(value)
            ) ? "\"" + value + "\"" : value;
        });

        // font size
        if (typeof size === "number") {
            this.fontSize = size;
            size += "px";
        } else /* string */ {
            // extract the units and convert if necessary
            var CSSval = size.match(/([-+]?[\d.]*)(.*)/);
            this.fontSize = parseFloat(CSSval[1]);
            if (CSSval[2]) {
                this.fontSize *= toPX[runits.indexOf(CSSval[2])];
            } else {
                // no unit define, assume px
                size += "px";
            }
        }
        this.height = this.fontSize;
        this.font = size + " " + font_names.join(",");

        this.isDirty = true;

        return this;
    }

    /**
     * change the text to be displayed
     * @param {number|string|string[]} value a string, or an array of strings
     * @returns {Text} this object for chaining
     */
    setText(value = "") {
        var bounds = this.getBounds();

        // set the next text
        if (this._text.toString() !== value.toString()) {
            if (!Array.isArray(value)) {
                this._text = ("" + value).split("\n");
            } else {
                this._text = value;
            }
        }

        // word wrap if necessary
        if (this._text.length > 0 && this.wordWrapWidth > 0) {
            this._text = this.metrics.wordWrap(this._text, this.wordWrapWidth, getContext2d(renderer, this));
        }

        // calculcate the text size and update the bounds accordingly
        bounds.addBounds(this.metrics.measureText(this._text, getContext2d(renderer, this)), true);

        // update the offScreenCanvas texture if required
        if (this.offScreenCanvas === true) {
            var width = Math.ceil(this.metrics.width),
                height = Math.ceil(this.metrics.height);

            if (renderer instanceof WebGLRenderer) {
                // invalidate the previous corresponding texture so that it can reuploaded once changed
                this.glTextureUnit = renderer.cache.getUnit(renderer.cache.get(this.canvasTexture.canvas));
                renderer.currentCompositor.unbindTexture2D(null, this.glTextureUnit);

                if (renderer.WebGLVersion === 1) {
                    // round size to next Pow2
                    width = nextPowerOfTwo(this.metrics.width);
                    height = nextPowerOfTwo(this.metrics.height);
                }
            }

            // resize the cache canvas if necessary
            if (this.canvasTexture.width < width || this.canvasTexture.height < height) {
                this.canvasTexture.resize(width, height);
            }

            this.canvasTexture.clear();
            this._drawFont(this.canvasTexture.context, this._text,  this.pos.x - this.metrics.x, this.pos.y - this.metrics.y, false);
        }

        this.isDirty = true;

        return this;
    }

    /**
     * measure the given text size in pixels
     * @param {CanvasRenderer|WebGLRenderer} renderer reference to the active renderer
     * @param {string} [text] the text to be measured
     * @returns {TextMetrics} a TextMetrics object defining the dimensions of the given piece of text
     */
    measureText(renderer, text = this._text) {
        return this.metrics.measureText(text, getContext2d(renderer, this));
    }


    /**
     * draw a text at the specified coord
     * @param {CanvasRenderer|WebGLRenderer} renderer Reference to the destination renderer instance
     * @param {string} [text]
     * @param {number} [x]
     * @param {number} [y]
     * @param {boolean} [stroke=false] draw stroke the the text if true
     */
    draw(renderer, text, x = this.pos.x, y = this.pos.y, stroke = false) {
        // "hacky patch" for backward compatibilty
        if (typeof this.ancestor === "undefined") {

            // update position if changed
            if (this.pos.x !== x || this.pos.y !== y) {
                this.pos.x = x;
                this.pos.y = y;
                this.isDirty = true;
            }

            // update text cache
            this.setText(text);

            x = this.metrics.x;
            y = this.metrics.y;

            // save the previous context
            renderer.save();

            // apply the defined alpha value
            renderer.setGlobalAlpha(renderer.globalAlpha() * this.getOpacity());

        } else {
             // added directly to an object container
            x = this.pos.x;
            y = this.pos.y;
        }

        // clamp to pixel grid if required
        if (renderer.settings.subPixel === false) {
            x = ~~x;
            y = ~~y;
        }

        // draw the text
        if (this.offScreenCanvas === true) {
            renderer.drawImage(this.canvasTexture.canvas, x, y);
        } else {
            renderer.drawFont(this._drawFont(renderer.getFontContext(), this._text, x, y, stroke));
        }


        // for backward compatibilty
        if (typeof this.ancestor === "undefined") {
            // restore previous context
            renderer.restore();
        }
    }

    /**
     * draw a stroke text at the specified coord, as defined <br>
     * by the `lineWidth` and `fillStroke` properties. <br>
     * Note : using drawStroke is not recommended for performance reasons
     * @param {CanvasRenderer|WebGLRenderer} renderer Reference to the destination renderer instance
     * @param {string} text
     * @param {number} x
     * @param {number} y
     */
    drawStroke(renderer, text, x, y) {
        this.draw(renderer, text, x, y, true);
    }

    /**
     * @ignore
     */
    _drawFont(context, text, x, y, stroke = false) {
        setContextStyle(context, this, stroke);

        for (var i = 0; i < text.length; i++) {
            var string = text[i].trimRight();
            // draw the string
            context[stroke ? "strokeText" : "fillText"](string, x, y);
            // add leading space
            y += this.metrics.lineHeight();
        }
        return this.metrics;
    }

    /**
     * Destroy function
     * @ignore
     */
    destroy() {
        pool.push(this.fillStyle);
        pool.push(this.strokeStyle);
        this.fillStyle = this.strokeStyle = undefined;
        this.metrics = undefined;
        this._text.length = 0;
        super.destroy();
    }
}

/**
 * @classdesc
 * a bitmap font object
 * @augments Renderable
 */
class BitmapText extends Renderable {
    /**
     * @param {number} x position of the text object
     * @param {number} y position of the text object
     * @param {object} settings the text configuration
     * @param {string|Image} settings.font a font name to identify the corresponing source image
     * @param {string} [settings.fontData=settings.font] the bitmap font data corresponding name, or the bitmap font data itself
     * @param {number} [settings.size] size a scaling ratio
     * @param {Color|string} [settings.fillStyle] a CSS color value used to tint the bitmapText (@see BitmapText.tint)
     * @param {number} [settings.lineWidth=1] line width, in pixels, when drawing stroke
     * @param {string} [settings.textAlign="left"] horizontal text alignment
     * @param {string} [settings.textBaseline="top"] the text baseline
     * @param {number} [settings.lineHeight=1.0] line spacing height
     * @param {Vector2d} [settings.anchorPoint={x:0.0, y:0.0}] anchor point to draw the text at
     * @param {number} [settings.wordWrapWidth] the maximum length in CSS pixel for a single segment of text
     * @param {(string|string[])} [settings.text] a string, or an array of strings
     * @example
     * // Use me.loader.preload or me.loader.load to load assets
     * me.loader.preload([
     *     { name: "arial", type: "binary" src: "data/font/arial.fnt" },
     *     { name: "arial", type: "image" src: "data/font/arial.png" },
     * ])
     * // Then create an instance of your bitmap font:
     * var myFont = new me.BitmapText(x, y, {font:"arial", text:"Hello"});
     * // two possibilities for using "myFont"
     * // either call the draw function from your Renderable draw function
     * myFont.draw(renderer, "Hello!", 0, 0);
     * // or just add it to the word container
     * me.game.world.addChild(myFont);
     */
    constructor(x, y, settings) {
        // call the parent constructor
        super(x, y, settings.width || 0, settings.height || 0);

        /**
         * Set the default text alignment (or justification),<br>
         * possible values are "left", "right", and "center".
         * @public
         * @type {string}
         * @default "left"
         */
        this.textAlign = settings.textAlign || "left";

        /**
         * Set the text baseline (e.g. the Y-coordinate for the draw operation), <br>
         * possible values are "top", "hanging, "middle, "alphabetic, "ideographic, "bottom"<br>
         * @public
         * @type {string}
         * @default "top"
         */
        this.textBaseline = settings.textBaseline || "top";

        /**
         * Set the line spacing height (when displaying multi-line strings). <br>
         * Current font height will be multiplied with this value to set the line height.
         * @public
         * @type {number}
         * @default 1.0
         */
        this.lineHeight = settings.lineHeight || 1.0;

        /**
         * the maximum length in CSS pixel for a single segment of text.
         * (use -1 to disable word wrapping)
         * @public
         * @type {number}
         * @default -1
         */
        this.wordWrapWidth = settings.wordWrapWidth || -1;

        /**
         * the text to be displayed
         * @private
         */
        this._text = [];

        /**
         * scaled font size
         * @private
         */
        this.fontScale = pool.pull("Vector2d", 1.0, 1.0);

        /**
         * font image
         * @private
         */
        this.fontImage = (typeof settings.font === "object") ? settings.font : loader.getImage(settings.font);

        if (typeof settings.fontData !== "string") {
            /**
             * font data
             * @private
             */
            // use settings.font to retreive the data from the loader
            this.fontData = pool.pull("BitmapTextData", loader.getBinary(settings.font));
        } else {
            this.fontData = pool.pull("BitmapTextData",
                // if starting/includes "info face" the whole data string was passed as parameter
                (settings.fontData.includes("info face")) ? settings.fontData : loader.getBinary(settings.fontData)
            );
        }
        // if floating was specified through settings
        if (typeof settings.floating !== "undefined") {
            this.floating = !!settings.floating;
        }

        // apply given fillstyle
        if (typeof settings.fillStyle !== "undefined") {
            if (settings.fillStyle instanceof Color) {
                this.fillStyle.setColor(settings.fillStyle);
            } else {
                // string (#RGB, #ARGB, #RRGGBB, #AARRGGBB)
                this.fillStyle.parseCSS(settings.fillStyle);
            }
        }

        // update anchorPoint if provided
        if (typeof settings.anchorPoint !== "undefined") {
            this.anchorPoint.set(settings.anchorPoint.x, settings.anchorPoint.y);
        } else {
            this.anchorPoint.set(0, 0);
        }

        // instance to text metrics functions
        this.metrics = new TextMetrics(this);

        // resize if necessary
        if (typeof settings.size === "number" && settings.size !== 1.0) {
            this.resize(settings.size);
        }

        // set the text
        this.setText(settings.text);
    }

    /**
     * change the font settings
     * @param {string} textAlign ("left", "center", "right")
     * @param {number} [scale]
     * @returns {BitmapText} this object for chaining
     */
    set(textAlign, scale) {
        this.textAlign = textAlign;
        // updated scaled Size
        if (scale) {
            this.resize(scale);
        }
        this.isDirty = true;

        return this;
    }

    /**
     * change the text to be displayed
     * @param {number|string|string[]} value a string, or an array of strings
     * @returns {BitmapText} this object for chaining
     */
    setText(value = "") {
        if (this._text.toString() !== value.toString()) {
            if (!Array.isArray(value)) {
                this._text = ("" + value).split("\n");
            } else {
                this._text = value;
            }
            this.isDirty = true;
        }

        if (this._text.length > 0 && this.wordWrapWidth > 0) {
            this._text = this.metrics.wordWrap(this._text, this.wordWrapWidth);
        }

        this.getBounds().addBounds(this.metrics.measureText(this._text), true);

        return this;
    }

    /**
     * defines the color used to tint the bitmap text
     * @public
     * @type {Color}
     * @see Renderable#tint
     */
    get fillStyle() {
        return this.tint;
    }
    set fillStyle(value) {
        this.tint = value;
    }

    /**
     * change the font display size
     * @param {number} scale ratio
     * @returns {BitmapText} this object for chaining
     */
    resize(scale) {
        this.fontScale.set(scale, scale);

        this.getBounds().addBounds(this.metrics.measureText(this._text), true);

        // clear the cache text to recalculate bounds
        this.isDirty = true;

        return this;
    }

    /**
     * measure the given text size in pixels
     * @param {string} [text]
     * @returns {TextMetrics} a TextMetrics object with two properties: `width` and `height`, defining the output dimensions
     */
    measureText(text = this._text) {
        return this.metrics.measureText(text);
    }

    /**
     * draw the bitmap font
     * @param {CanvasRenderer|WebGLRenderer} renderer Reference to the destination renderer instance
     * @param {string} [text]
     * @param {number} [x]
     * @param {number} [y]
     */
    draw(renderer, text, x, y) {
        // save the previous global alpha value
        var _alpha = renderer.globalAlpha();

        // allows to provide backward compatibility when
        // adding Bitmap Font to an object container
        if (typeof this.ancestor === "undefined") {
            // update cache
            this.setText(text);
            renderer.setGlobalAlpha(_alpha * this.getOpacity());
        } else {
            // added directly to an object container
            x = this.pos.x;
            y = this.pos.y;
        }

        var lX = x;
        var stringHeight = this.metrics.lineHeight();
        var maxWidth = 0;

        for (var i = 0; i < this._text.length; i++) {
            x = lX;
            var string = this._text[i].trimRight();
            // adjust x pos based on alignment value
            var stringWidth = this.metrics.lineWidth(string);
            switch (this.textAlign) {
                case "right":
                    x -= stringWidth;
                    break;

                case "center":
                    x -= stringWidth * 0.5;
                    break;
            }

            // adjust y pos based on alignment value
            switch (this.textBaseline) {
                case "middle":
                    y -= stringHeight * 0.5;
                    break;

                case "ideographic":
                case "alphabetic":
                case "bottom":
                    y -= stringHeight;
                    break;
            }

            // update initial position if required
            if (this.isDirty === true && typeof this.ancestor === "undefined") {
                if (i === 0) {
                    this.pos.y = y;
                }
                if (maxWidth < stringWidth) {
                    maxWidth = stringWidth;
                    this.pos.x = x;
                }
            }

            // draw the string
            var lastGlyph = null;
            for (var c = 0, len = string.length; c < len; c++) {
                // calculate the char index
                var ch = string.charCodeAt(c);
                var glyph = this.fontData.glyphs[ch];
                var glyphWidth = glyph.width;
                var glyphHeight = glyph.height;
                var kerning = (lastGlyph && lastGlyph.kerning) ? lastGlyph.getKerning(ch) : 0;

                // draw it
                if (glyphWidth !== 0 && glyphHeight !== 0) {
                    // some browser throw an exception when drawing a 0 width or height image
                    renderer.drawImage(this.fontImage,
                        glyph.x, glyph.y,
                        glyphWidth, glyphHeight,
                        x + glyph.xoffset,
                        y + glyph.yoffset * this.fontScale.y,
                        glyphWidth * this.fontScale.x, glyphHeight * this.fontScale.y
                    );
                }

                // increment position
                x += (glyph.xadvance + kerning) * this.fontScale.x;
                lastGlyph = glyph;
            }
            // increment line
            y += stringHeight;
        }

        if (typeof this.ancestor === "undefined") {
            // restore the previous global alpha value
            renderer.setGlobalAlpha(_alpha);
        }

        // clear the dirty flag here for
        // backward compatibility
        this.isDirty = false;
    }

    /**
     * Destroy function
     * @ignore
     */
    destroy() {
        pool.push(this.fontScale);
        this.fontScale = undefined;
        pool.push(this.fontData);
        this.fontData = undefined;
        this._text.length = 0;
        this.metrics = undefined;
        super.destroy();
    }

}

// bitmap constants
const LOG2_PAGE_SIZE = 9;
const PAGE_SIZE = 1 << LOG2_PAGE_SIZE;

/**
 * a glyph representing a single character in a font
 * @ignore
 */
class Glyph {
    /**
     * @ignore
     */
    constructor() {
        this.id = 0;
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
        this.u = 0;
        this.v = 0;
        this.u2 = 0;
        this.v2 = 0;
        this.xoffset = 0;
        this.yoffset = 0;
        this.xadvance = 0;
        this.fixedWidth = false;
    }

    /**
     * @ignore
     */
    getKerning(ch) {
        if (this.kerning) {
            var page = this.kerning[ch >>> LOG2_PAGE_SIZE];
            if (page) {
                return page[ch & PAGE_SIZE - 1] || 0;
            }
        }
        return 0;
    }

    /**
     * @ignore
     */
    setKerning(ch, value) {
        if (!this.kerning) {
            this.kerning = {};
        }
        var page = this.kerning[ch >>> LOG2_PAGE_SIZE];
        if (typeof page === "undefined") {
            this.kerning[ch >>> LOG2_PAGE_SIZE] = {};
            page = this.kerning[ch >>> LOG2_PAGE_SIZE];
        }
        page[ch & PAGE_SIZE - 1] = value;
    }
}

// bitmap constants
const capChars = ["M", "N", "B", "D", "C", "E", "F", "K", "A", "G", "H", "I", "J", "L", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];

/**
 * Gets the value from a string of pairs.
 * @ignore
 */
function getValueFromPair(string, pattern) {
    var value = string.match(pattern);
    if (!value) {
        throw new Error("Could not find pattern " + pattern + " in string: " + string);
    }

    return value[0].split("=")[1];
}
/**
 * Gets the first glyph in the map that is not a space character
 * @ignore
 * @name _getFirstGlyph
 * @memberof BitmapTextData
 * @param {object} glyphs the map of glyphs, each key is a char code
 * @returns {Glyph}
 */
function getFirstGlyph(glyphs) {
    var keys = Object.keys(glyphs);
    for (var i = 0; i < keys.length; i++) {
        if (keys[i] > 32) {
            return glyphs[keys[i]];
        }
    }
    return null;
}
/**
 * Creates a glyph to use for the space character
 * @ignore
 * @name createSpaceGlyph
 * @memberof BitmapTextData
 * @param {object} glyphs the map of glyphs, each key is a char code
 */
function createSpaceGlyph(glyphs) {
    var spaceCharCode = " ".charCodeAt(0);
    var glyph = glyphs[spaceCharCode];
    if (!glyph) {
        glyph = new Glyph();
        glyph.id = spaceCharCode;
        glyph.xadvance = getFirstGlyph(glyphs).xadvance;
        glyphs[spaceCharCode] = glyph;
    }
}


/**
 * Class for storing relevant data from the font file.
 * @ignore
 */
class BitmapTextData {

   /**
    * @param {string} data - The bitmap font data pulled from the resource loader using me.loader.getBinary()
    */
    constructor(data) {
        this.onResetEvent(data);
    }

    /**
     * @ignore
     */
    onResetEvent(data) {
        this.padTop = 0;
        this.padRight = 0;
        this.padBottom = 0;
        this.padLeft = 0;
        this.lineHeight = 0;
        // The distance from the top of most uppercase characters to the baseline. Since the drawing position is the cap height of
        // the first line, the cap height can be used to get the location of the baseline.
        this.capHeight = 1;
        // The distance from the bottom of the glyph that extends the lowest to the baseline. This number is negative.
        this.descent = 0;

        /**
         * The map of glyphs, each key is a char code.
         * @name glyphs
         * @type {object}
         * @memberof BitmapTextData
         */
        this.glyphs = {};

        // parse the data
        this.parse(data);
    }

    /**
     * This parses the font data text and builds a map of glyphs containing the data for each character
     * @name parse
     * @memberof BitmapTextData
     * @param {string} fontData
     */
    parse(fontData) {
        if (!fontData) {
            throw new Error("File containing font data was empty, cannot load the bitmap font.");
        }
        var lines = fontData.split(/\r\n|\n/);
        var padding = fontData.match(/padding\=\d+,\d+,\d+,\d+/g);
        if (!padding) {
            throw new Error("Padding not found in first line");
        }
        var paddingValues = padding[0].split("=")[1].split(",");
        this.padTop = parseFloat(paddingValues[0]);
        this.padLeft = parseFloat(paddingValues[1]);
        this.padBottom = parseFloat(paddingValues[2]);
        this.padRight = parseFloat(paddingValues[3]);

        this.lineHeight = parseFloat(getValueFromPair(lines[1], /lineHeight\=\d+/g));

        var baseLine = parseFloat(getValueFromPair(lines[1], /base\=\d+/g));

        var padY = this.padTop + this.padBottom;

        var glyph = null;

        var i;

        for (i = 4; i < lines.length; i++) {
            var line = lines[i];
            var characterValues = line.split(/=|\s+/);
            if (!line || /^kernings/.test(line)) {
                continue;
            }
            if (/^kerning\s/.test(line)) {
                var first = parseFloat(characterValues[2]);
                var second = parseFloat(characterValues[4]);
                var amount = parseFloat(characterValues[6]);

                glyph = this.glyphs[first];
                if (glyph !== null && typeof glyph !== "undefined") {
                    glyph.setKerning(second, amount);
                }
            } else {
                glyph = new Glyph();

                var ch = parseFloat(characterValues[2]);
                glyph.id = ch;
                glyph.x = parseFloat(characterValues[4]);
                glyph.y = parseFloat(characterValues[6]);
                glyph.width = parseFloat(characterValues[8]);
                glyph.height = parseFloat(characterValues[10]);
                glyph.xoffset = parseFloat(characterValues[12]);
                glyph.yoffset = parseFloat(characterValues[14]);
                glyph.xadvance = parseFloat(characterValues[16]);

                if (glyph.width > 0 && glyph.height > 0) {
                    this.descent = Math.min(baseLine + glyph.yoffset, this.descent);
                }

                this.glyphs[ch] = glyph;
            }
        }

        this.descent += this.padBottom;

        createSpaceGlyph(this.glyphs);

        var capGlyph = null;
        for (i = 0; i < capChars.length; i++) {
            var capChar = capChars[i];
            capGlyph = this.glyphs[capChar.charCodeAt(0)];
            if (capGlyph) {
                break;
            }
        }
        if (!capGlyph) {
            for (var charCode in this.glyphs) {
                if (this.glyphs.hasOwnProperty(charCode)) {
                    glyph = this.glyphs[charCode];
                    if (glyph.height === 0 || glyph.width === 0) {
                        continue;
                    }
                    this.capHeight = Math.max(this.capHeight, glyph.height);
                }
            }
        } else {
            this.capHeight = capGlyph.height;
        }
        this.capHeight -= padY;
    }
}

/**
 * @classdesc
 * a generic Color Layer Object.  Fills the entire Canvas with the color not just the container the object belongs to.
 * @augments Renderable
 */
class ColorLayer extends Renderable {
    /**
     * @param {string} name Layer name
     * @param {Color|string} color CSS color
     * @param {number} [z = 0] z-index position
     */
    constructor(name, color, z) {
        // parent constructor
        super(0, 0, Infinity, Infinity);

        /**
         * the layer color component
         * @public
         * @type {Color}
         * @name color
         * @memberof ColorLayer#
         */
         this.color = pool.pull("Color").parseCSS(color);

         this.onResetEvent(name, color, z);

    }

    onResetEvent(name, color, z = 0) {
        // apply given parameters
        this.name = name;
        this.pos.z = z;
        this.floating = true;
        // string (#RGB, #ARGB, #RRGGBB, #AARRGGBB)
        this.color.parseCSS(color);
    }

    /**
     * draw this color layer (automatically called by melonJS)
     * @name draw
     * @memberof ColorLayer
     * @protected
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer instance
     * @param {Camera2d} [viewport] the viewport to (re)draw
     */
    draw(renderer, viewport) {
        renderer.save();
        renderer.clipRect(
            0, 0,
            viewport.width, viewport.height
        );
        renderer.clearColor(this.color);
        renderer.restore();
    }

    /**
     * Destroy function
     * @ignore
     */
    destroy() {
        pool.push(this.color);
        this.color = undefined;
        super.destroy();
    }

}

/**
 * @classdesc
 * a generic Image Layer Object
 * @augments Renderable
 */
class ImageLayer extends Sprite {
    /**
     * @param {number} x x coordinate
     * @param {number} y y coordinate
     * @param {object} settings ImageLayer properties
     * @param {HTMLImageElement|HTMLCanvasElement|string} settings.image Image reference. See {@link loader.getImage}
     * @param {string} [settings.name="me.ImageLayer"] layer name
     * @param {number} [settings.z=0] z-index position
     * @param {number|Vector2d} [settings.ratio=1.0] Scrolling ratio to be applied. See {@link ImageLayer#ratio}
     * @param {string} [settings.repeat='repeat'] define if and how an Image Layer should be repeated (accepted values are 'repeat', 'repeat-x', 'repeat-y', 'no-repeat'). See {@link ImageLayer#repeat}
     * @param {number|Vector2d} [settings.anchorPoint=0.0] Image origin. See {@link ImageLayer#anchorPoint}
     * @example
     * // create a repetitive background pattern on the X axis using the citycloud image asset
     * me.game.world.addChild(new me.ImageLayer(0, 0, {
     *     image:"citycloud",
     *     repeat :"repeat-x"
     * }), 1);
     */
    constructor(x, y, settings) {
        // call the constructor
        super(x, y, settings);

        // render in screen coordinates
        this.floating = true;

        // image drawing offset
        this.offset.set(x, y);

        /**
         * Define the image scrolling ratio<br>
         * Scrolling speed is defined by multiplying the viewport delta position by the specified ratio.
         * Setting this vector to &lt;0.0,0.0&gt; will disable automatic scrolling.<br>
         * To specify a value through Tiled, use one of the following format : <br>
         * - a number, to change the value for both axis <br>
         * - a json expression like `json:{"x":0.5,"y":0.5}` if you wish to specify a different value for both x and y
         * @public
         * @type {Vector2d}
         * @default <1.0,1.0>
         * @name ImageLayer#ratio
         */
        this.ratio = pool.pull("Vector2d", 1.0, 1.0);

        if (typeof(settings.ratio) !== "undefined") {
            // little hack for backward compatiblity
            if (isNumeric(settings.ratio)) {
                this.ratio.set(settings.ratio, +settings.ratio);
            } else /* vector */ {
                this.ratio.setV(settings.ratio);
            }
        }

        if (typeof(settings.anchorPoint) === "undefined") {
            /**
             * Define how the image is anchored to the viewport bounds<br>
             * By default, its upper-left corner is anchored to the viewport bounds upper left corner.<br>
             * The anchorPoint is a unit vector where each component falls in range [0.0,1.0].<br>
             * Some common examples:<br>
             * - &lt;0.0,0.0&gt; : (Default) Anchor image to the upper-left corner of viewport bounds
             * - &lt;0.5,0.5&gt; : Center the image within viewport bounds
             * - &lt;1.0,1.0&gt; : Anchor image to the lower-right corner of viewport bounds
             * To specify a value through Tiled, use one of the following format : <br>
             * - a number, to change the value for both axis <br>
             * - a json expression like `json:{"x":0.5,"y":0.5}` if you wish to specify a different value for both x and y
             * @public
             * @member {Vector2d}
             * @default <0.0,0.0>
             * @name ImageLayer#anchorPoint
             */
            this.anchorPoint.set(0, 0);
        }
        else {
            if (typeof(settings.anchorPoint) === "number") {
                this.anchorPoint.set(settings.anchorPoint, settings.anchorPoint);
            }
            else /* vector */ {
                this.anchorPoint.setV(settings.anchorPoint);
            }
        }

        this.repeat = settings.repeat || "repeat";

        // on context lost, all previous textures are destroyed
        on(ONCONTEXT_RESTORED, this.createPattern, this);
    }

    /**
     * Define if and how an Image Layer should be repeated.<br>
     * By default, an Image Layer is repeated both vertically and horizontally.<br>
     * Acceptable values : <br>
     * - 'repeat' - The background image will be repeated both vertically and horizontally <br>
     * - 'repeat-x' - The background image will be repeated only horizontally.<br>
     * - 'repeat-y' - The background image will be repeated only vertically.<br>
     * - 'no-repeat' - The background-image will not be repeated.<br>
     * @public
     * @type {string}
     * @default 'repeat'
     * @name ImageLayer#repeat
     */

    get repeat() {
        return this._repeat;
    }

    set repeat(value) {
        this._repeat = value;
        switch (this._repeat) {
            case "no-repeat" :
                this.repeatX = false;
                this.repeatY = false;
                break;
            case "repeat-x" :
                this.repeatX = true;
                this.repeatY = false;
                break;
            case "repeat-y" :
                this.repeatX = false;
                this.repeatY = true;
                break;
            default : // "repeat"
                this.repeatX = true;
                this.repeatY = true;
                break;
        }
        this.resize(viewport.width, viewport.height);
        this.createPattern();
    }


    // called when the layer is added to the game world or a container
    onActivateEvent() {
        // register to the viewport change notification
        on(VIEWPORT_ONCHANGE, this.updateLayer, this);
        on(VIEWPORT_ONRESIZE, this.resize, this);
        // force a first refresh when the level is loaded
        once(LEVEL_LOADED, () => {
            this.updateLayer(viewport.pos);
        });
        // in case the level is not added to the root container,
        // the onActivateEvent call happens after the LEVEL_LOADED event
        // so we need to force a first update
        if (this.ancestor.root !== true) {
            this.updateLayer(viewport.pos);
        }
    }

    /**
     * resize the Image Layer to match the given size
     * @name resize
     * @memberof ImageLayer
     * @param {number} w new width
     * @param {number} h new height
     */
    resize(w, h) {
        return super.resize(
            this.repeatX ? Infinity : w,
            this.repeatY ? Infinity : h
        );
    }

    /**
     * createPattern function
     * @ignore
     */
    createPattern() {
        this._pattern = renderer.createPattern(this.image, this._repeat);
    }

    /**
     * updateLayer function
     * @ignore
     */
    updateLayer(vpos) {
        var rx = this.ratio.x,
            ry = this.ratio.y;

        if (rx === 0 && ry === 0) {
            // static image
            return;
        }

        var width = this.width,
            height = this.height,
            bw = viewport.bounds.width,
            bh = viewport.bounds.height,
            ax = this.anchorPoint.x,
            ay = this.anchorPoint.y,

            /*
             * Automatic positioning
             *
             * See https://github.com/melonjs/melonJS/issues/741#issuecomment-138431532
             * for a thorough description of how this works.
             */
            x = ax * (rx - 1) * (bw - viewport.width) + this.offset.x - rx * vpos.x,
            y = ay * (ry - 1) * (bh - viewport.height) + this.offset.y - ry * vpos.y;


        // Repeat horizontally; start drawing from left boundary
        if (this.repeatX) {
            this.pos.x = x % width;
        }
        else {
            this.pos.x = x;
        }

        // Repeat vertically; start drawing from top boundary
        if (this.repeatY) {
            this.pos.y = y % height;
        }
        else {
            this.pos.y = y;
        }

        this.isDirty = true;
    }

   /**
    * override the default predraw function
    * as repeat and anchor are managed directly in the draw method
    * @ignore
    */
    preDraw(renderer) {
        // save the context
        renderer.save();
        // apply the defined alpha value
        renderer.setGlobalAlpha(renderer.globalAlpha() * this.getOpacity());

        // apply the defined tint, if any
        renderer.setTint(this.tint);
    }

    /**
     * draw this ImageLayer (automatically called by melonJS)
     * @name draw
     * @memberof ImageLayer
     * @protected
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer instance
     * @param {Camera2d} [viewport] the viewport to (re)draw
     */
    draw(renderer, viewport) {
        var width = this.width,
            height = this.height,
            bw = viewport.bounds.width,
            bh = viewport.bounds.height,
            ax = this.anchorPoint.x,
            ay = this.anchorPoint.y,
            x = this.pos.x,
            y = this.pos.y;

        if (this.ratio.x === 0 && this.ratio.y === 0) {
            // static image
            x = x + ax * (bw - width);
            y = y + ay * (bh - height);
        }

        renderer.translate(x, y);
        renderer.drawPattern(
            this._pattern,
            0,
            0,
            viewport.width * 2,
            viewport.height * 2
        );
    }

    // called when the layer is removed from the game world or a container
    onDeactivateEvent() {
        // cancel all event subscriptions
        off(VIEWPORT_ONCHANGE, this.updateLayer);
        off(VIEWPORT_ONRESIZE, this.resize);
    }

    /**
     * Destroy function<br>
     * @ignore
     */
    destroy() {
        pool.push(this.ratio);
        this.ratio = undefined;
        off(ONCONTEXT_RESTORED, this.createPattern);
        super.destroy();
    }

}

/**
 * @classdesc
 * A NineSliceSprite is similar to a Sprite, but it uses 9-slice scaling to strech its inner area to fit the size of the Renderable,
 * by proportionally scaling a sprite by splitting it in a grid of nine parts (with only parts 1, 3, 7, 9 not being scaled). <br>
 * <img src="images/9-slice-scaling.png"/><br>
 * @see https://en.wikipedia.org/wiki/9-slice_scaling
 * @augments Sprite
 */
class NineSliceSprite extends Sprite {
    /**
     * @param {number} x the x coordinates of the sprite object
     * @param {number} y the y coordinates of the sprite object
     * @param {object} settings Configuration parameters for the Sprite object
     * @param {number} settings.width the width of the Renderable over which the sprite needs to be stretched
     * @param {number} settings.height the height of the Renderable over which the sprite needs to be stretched
     * @param {number} [settings.insetx] the width of a corner over which the sprite is unscaled (default is a quarter of the sprite width)
     * @param {number} [settings.insety] the height of a corner over which the sprite is unscaled (default is a quarter of the sprite height)
     * @param {HTMLImageElement|HTMLCanvasElement|TextureAtlas|string} settings.image reference to spritesheet image, a texture atlas or to a texture atlas
     * @param {string} [settings.name=""] name of this object
     * @param {string} [settings.region] region name of a specific region to use when using a texture atlas, see {@link TextureAtlas}
     * @param {number} [settings.framewidth] Width of a single frame within the spritesheet
     * @param {number} [settings.frameheight] Height of a single frame within the spritesheet
     * @param {string|Color} [settings.tint] a tint to be applied to this sprite
     * @param {number} [settings.flipX] flip the sprite on the horizontal axis
     * @param {number} [settings.flipY] flip the sprite on the vertical axis
     * @param {Vector2d} [settings.anchorPoint={x:0.5, y:0.5}] Anchor point to draw the frame at (defaults to the center of the frame).
     * @example
     * this.panelSprite = new me.NineSliceSprite(0, 0, {
     *     image : game.texture,
     *     region : "grey_panel",
     *     width : this.width,
     *     height : this.height
     * });
     */
    constructor(x, y, settings) {
        // call the super constructor
        super(x, y, settings);

        // ensure mandatory properties are defined
        if ((typeof settings.width !== "number") || (typeof settings.height !== "number")) {
            throw new Error("height and width properties are mandatory");
        }

        // adjust the nss sprite size accordingly to the target "expanded" size
        this.width = Math.floor(settings.width);
        this.height = Math.floor(settings.height);

        // nine slice sprite specific local variables
        this.nss_width = this.width;
        this.nss_height = this.height;

        this.insetx = settings.insetx;
        this.insety = settings.insety;
    }

    /**
     * @ignore
     */
    draw(renderer) {
        // the frame to draw
        var frame = this.current;

        // cache the current position and size
        var dx = this.pos.x,
            dy = this.pos.y;

        var w = frame.width,
            h = frame.height;

        // frame offset in the texture/atlas
        var frame_offset = frame.offset;
        var g_offset = this.offset;


        // remove image's TexturePacker/ShoeBox rotation
        if (frame.angle !== 0) {
            renderer.translate(-dx, -dy);
            renderer.rotate(frame.angle);
            dx -= h;
            w = frame.height;
            h = frame.width;
        }

        var sx = g_offset.x + frame_offset.x,
            sy = g_offset.y + frame_offset.y;

        // should this be configurable ?
        var corner_width = this.insetx || w / 4,
            corner_height = this.insety || h / 4;

        // OPTIMIZE ME !

        // DRAW CORNERS

        // Top Left
        renderer.drawImage(
            this.image,
            sx,                          // sx
            sy,                          // sy
            corner_width, corner_height, // sw,sh
            dx, dy,                      // dx,dy
            corner_width, corner_height  // dw,dh
        );

        // Top Right
        renderer.drawImage(
            this.image,
            sx + w - corner_width,          // sx
            sy,                             // sy
            corner_width, corner_height,    // sw,sh
            dx + this.nss_width - corner_width, // dx
            dy,                             // dy
            corner_width, corner_height     // dw,dh
        );
        // Bottom Left
        renderer.drawImage(
            this.image,
            sx,                                 // sx
            sy + h - corner_height,             // sy
            corner_width, corner_height,        // sw,sh
            dx,                                 // dx
            dy + this.nss_height - corner_height,   // dy
            corner_width, corner_height         // dw,dh
        );
        // Bottom Right
        renderer.drawImage(
            this.image,
            sx + w - corner_width,              // sx
            sy + h - corner_height,             // sy
            corner_width, corner_height,        // sw,sh
            dx + this.nss_width - corner_width,     //dx
            dy + this.nss_height - corner_height,   // dy
            corner_width, corner_height         // dw,dh
        );


        // DRAW SIDES and CENTER
        var image_center_width = w - (corner_width << 1);
        var image_center_height = h - (corner_height << 1);

        var target_center_width = this.nss_width - (corner_width << 1);
        var target_center_height = this.nss_height - (corner_height << 1);

        //Top center
        renderer.drawImage(
            this.image,
            sx + corner_width,         // sx
            sy,                        // sy
            image_center_width,        // sw
            corner_height,             // sh
            dx + corner_width,         // dx
            dy,                        // dy
            target_center_width,       // dw
            corner_height              // dh
        );

        //Bottom center
        renderer.drawImage(
            this.image,
            sx + corner_width,                  // sx
            sy + h - corner_height,             // sy
            image_center_width,                 // sw
            corner_height,                      // sh
            dx + corner_width,                  // dx
            dy + this.nss_height - corner_height,   // dx
            target_center_width,                // dw
            corner_height                       // dh
        );

        // Middle Left
        renderer.drawImage(
            this.image,
            sx,                   // sx
            sy + corner_height,   // sy
            corner_width,         // sw
            image_center_height,  // sh
            dx,                   // dx
            dy + corner_height,   // dy
            corner_width,         // dw
            target_center_height  // dh
        );

        // Middle Right
        renderer.drawImage(
            this.image,
            sx + w - corner_width,          // sx
            sy + corner_height,             // sy
            corner_width,                   // sw
            image_center_height,            // sh
            dx + this.nss_width - corner_width, // dx
            dy + corner_height,             // dy
            corner_width,                   // dw
            target_center_height            // dh
        );

        // Middle Center
        renderer.drawImage(
            this.image,
            sx + corner_width,    // sx
            sy + corner_height,   // sy
            image_center_width,   // sw
            image_center_height,  // sh
            dx + corner_width,    // dx
            dy + corner_height,   // dy
            target_center_width,  // dw
            target_center_height  // dh
        );
    }
}

/**
 * @classdesc
 * GUI Object<br>
 * A very basic object to manage GUI elements <br>
 * The object simply register on the "pointerdown" <br>
 * or "touchstart" event and call the onClick function"
 * @augments Sprite
 */
class GUI_Object extends Sprite {
    /**
     * @param {number} x the x coordinate of the GUI Object
     * @param {number} y the y coordinate of the GUI Object
     * @param {object} settings See {@link Sprite}
     * @example
     * // create a basic GUI Object
     * class myButton extends GUI_Object {
     *    constructor(x, y) {
     *       var settings = {}
     *       settings.image = "button";
     *       settings.framewidth = 100;
     *       settings.frameheight = 50;
     *       // super constructor
     *       super(x, y, settings);
     *       // define the object z order
     *       this.pos.z = 4;
     *    }
     *
     *    // output something in the console
     *    // when the object is clicked
     *    onClick:function (event) {
     *       console.log("clicked!");
     *       // don't propagate the event
     *       return false;
     *    }
     * });
     *
     * // add the object at pos (10,10)
     * me.game.world.addChild(new myButton(10,10));
     */
    constructor(x, y, settings) {

        // call the parent constructor
        super(x, y, settings);

        /**
         * object can be clicked or not
         * @public
         * @type {boolean}
         * @default true
         * @name GUI_Object#isClickable
         */
        this.isClickable = true;

        /**
         * Tap and hold threshold timeout in ms
         * @type {number}
         * @default 250
         * @name GUI_Object#holdThreshold
         */
        this.holdThreshold = 250;

        /**
         * object can be tap and hold
         * @public
         * @type {boolean}
         * @default false
         * @name GUI_Object#isHoldable
         */
        this.isHoldable = false;

        /**
         * true if the pointer is over the object
         * @public
         * @type {boolean}
         * @default false
         * @name GUI_Object#hover
         */
        this.hover = false;

        // object has been updated (clicked,etc..)
        this.holdTimeout = null;
        this.released = true;

        // GUI items use screen coordinates
        this.floating = true;

        // enable event detection
        this.isKinematic = false;
    }

    /**
     * function callback for the pointerdown event
     * @ignore
     */
    clicked(event) {
        // Check if left mouse button is pressed
        if (event.button === 0 && this.isClickable) {
            this.dirty = true;
            this.released = false;
            if (this.isHoldable) {
                if (this.holdTimeout !== null) {
                    timer.clearTimeout(this.holdTimeout);
                }
                this.holdTimeout = timer.setTimeout(this.hold.bind(this), this.holdThreshold, false);
                this.released = false;
            }
            return this.onClick(event);
        }
    }

    /**
     * function called when the object is pressed (to be extended)
     * @name onClick
     * @memberof GUI_Object
     * @public
     * @param {Pointer} event the event object
     * @returns {boolean} return false if we need to stop propagating the event
     */
    onClick(event) { // eslint-disable-line no-unused-vars
        return false;
    }

    /**
     * function callback for the pointerEnter event
     * @ignore
     */
    enter(event) {
        this.hover = true;
        this.dirty = true;
        return this.onOver(event);
    }

    /**
     * function called when the pointer is over the object
     * @name onOver
     * @memberof GUI_Object
     * @public
     * @param {Pointer} event the event object
     */
    onOver(event) { // eslint-disable-line no-unused-vars
        // to be extended
    }

    /**
     * function callback for the pointerLeave event
     * @ignore
     */
    leave(event) {
        this.hover = false;
        this.dirty = true;
        this.release(event);
        return this.onOut(event);
    }

    /**
     * function called when the pointer is leaving the object area
     * @name onOut
     * @memberof GUI_Object
     * @public
     * @param {Pointer} event the event object
     */
    onOut(event) { // eslint-disable-line no-unused-vars
        // to be extended
    }

    /**
     * function callback for the pointerup event
     * @ignore
     */
    release(event) {
        if (this.released === false) {
            this.released = true;
            this.dirty = true;
            timer.clearTimeout(this.holdTimeout);
            return this.onRelease(event);
        }
    }

    /**
     * function called when the object is pressed and released (to be extended)
     * @name onRelease
     * @memberof GUI_Object
     * @public
     * @returns {boolean} return false if we need to stop propagating the event
     */
    onRelease() {
        return false;
    }

    /**
     * function callback for the tap and hold timer event
     * @ignore
     */
    hold() {
        timer.clearTimeout(this.holdTimeout);
        this.dirty = true;
        if (!this.released) {
            this.onHold();
        }
    }

    /**
     * function called when the object is pressed and held<br>
     * to be extended <br>
     * @name onHold
     * @memberof GUI_Object
     * @public
     */
    onHold() {}

    /**
     * function called when added to the game world or a container
     * @ignore
     */
    onActivateEvent() {
        // register pointer events
        registerPointerEvent("pointerdown", this, this.clicked.bind(this));
        registerPointerEvent("pointerup", this, this.release.bind(this));
        registerPointerEvent("pointercancel", this, this.release.bind(this));
        registerPointerEvent("pointerenter", this, this.enter.bind(this));
        registerPointerEvent("pointerleave", this, this.leave.bind(this));
    }

    /**
     * function called when removed from the game world or a container
     * @ignore
     */
    onDeactivateEvent() {
        // release pointer events
        releasePointerEvent("pointerdown", this);
        releasePointerEvent("pointerup", this);
        releasePointerEvent("pointercancel", this);
        releasePointerEvent("pointerenter", this);
        releasePointerEvent("pointerleave", this);
        timer.clearTimeout(this.holdTimeout);
    }
}

/**
 * @classdesc
 * a basic collectable helper class for immovable object (e.g. a coin)
 * @augments Sprite
 */
class Collectable extends Sprite {
    /**
     * @param {number} x the x coordinates of the collectable
     * @param {number} y the y coordinates of the collectable
     * @param {object} settings See {@link Sprite}
     */
    constructor(x, y, settings) {

        // call the super constructor
        super(x, y, settings);

        this.name = settings.name;
        this.type = settings.type;
        this.id = settings.id;

        // add and configure the physic body
        var shape = settings.shapes;
        if (typeof shape === "undefined") {
            shape = pool.pull("Polygon", 0, 0, [
                pool.pull("Vector2d", 0,          0),
                pool.pull("Vector2d", this.width, 0),
                pool.pull("Vector2d", this.width, this.height)
            ]);
        }
        this.body = new Body(this, shape);
        this.body.collisionType = collision.types.COLLECTABLE_OBJECT;
        // by default only collides with PLAYER_OBJECT
        this.body.setCollisionMask(collision.types.PLAYER_OBJECT);
        this.body.setStatic(true);

        // Update anchorPoint
        if (settings.anchorPoint) {
            this.anchorPoint.set(settings.anchorPoint.x, settings.anchorPoint.y);
        } else {
            // for backward compatibility
            this.anchorPoint.set(0, 0);
        }

    }

}

/**
 * @classdesc
 * trigger an event when colliding with another object
 * @augments Renderable
 */
class Trigger extends Renderable {
    /**
     * @param {number} x the x coordinates of the trigger area
     * @param {number} y the y coordinates of the trigger area
     * @param {number} [settings.width] width of the trigger area
     * @param {number} [settings.height] height of the trigger area
     * @param {Rect[]|Polygon[]|Line[]|Ellipse[]} [settings.shapes] collision shape(s) that will trigger the event
     * @param {string} [settings.duration] Fade duration (in ms)
     * @param {string|Color} [settings.color] Fade color
     * @param {string} [settings.event="level"] the type of event to trigger (only "level" supported for now)
     * @param {string} [settings.to] level to load if level trigger
     * @param {string|Container} [settings.container] Target container. See {@link level.load}
     * @param {Function} [settings.onLoaded] Level loaded callback. See {@link level.load}
     * @param {boolean} [settings.flatten] Flatten all objects into the target container. See {@link level.load}
     * @param {boolean} [settings.setViewportBounds] Resize the viewport to match the level. See {@link level.load}
     * @example
     * me.game.world.addChild(new me.Trigger(
     *     x, y, {
     *         shapes: [new me.Rect(0, 0, 100, 100)],
     *         "duration" : 250,
     *         "color" : "#000",
     *         "to" : "mymap2"
     *     }
     * ));
     */
    constructor(x, y, settings) {
        // call the parent constructor
        super(x, y, settings.width || 0, settings.height || 0);

        // for backward compatibility
        this.anchorPoint.set(0, 0);

        this.fade = settings.fade;
        this.duration = settings.duration;
        this.fading = false;

        // Tiled Settings
        this.name = "Trigger";
        this.type = settings.type;
        this.id = settings.id;

        // a temp variable
        this.gotolevel = settings.to;

        // Collect the defined trigger settings
        this.triggerSettings = {
            // the default (and only for now) action
            event: "level"
        };

        [ "type", "container", "onLoaded", "flatten", "setViewportBounds", "to" ].forEach(function(property) {
            if (typeof settings[property] !== "undefined") {
                this.triggerSettings[property] = settings[property];
            }
        }.bind(this));

        // add and configure the physic body
        var shape = settings.shapes;
        if (typeof shape === "undefined") {
            shape = pool.pull("Polygon", 0, 0, [
                pool.pull("Vector2d", 0,          0),
                pool.pull("Vector2d", this.width, 0),
                pool.pull("Vector2d", this.width, this.height)
            ]);
        }
        this.body = new Body(this, shape);
        this.body.collisionType = collision.types.ACTION_OBJECT;
        // by default only collides with PLAYER_OBJECT
        this.body.setCollisionMask(collision.types.PLAYER_OBJECT);
        this.body.setStatic(true);
        this.resize(this.body.getBounds().width, this.body.getBounds().height);
    }

    /**
     * @ignore
     */
     getTriggerSettings() {
         // Lookup for the container instance
         if (typeof(this.triggerSettings.container) === "string") {
             this.triggerSettings.container = world.getChildByName(this.triggerSettings.container)[0];
         }
         return this.triggerSettings;
     }

    /**
     * @ignore
     */
    onFadeComplete() {
        level.load(this.gotolevel, this.getTriggerSettings());
        viewport.fadeOut(this.fade, this.duration);
    }

    /**
     * trigger this event
     * @name triggerEvent
     * @memberof Trigger
     * @protected
     */
    triggerEvent() {
        var triggerSettings = this.getTriggerSettings();

        if (triggerSettings.event === "level") {
            this.gotolevel = triggerSettings.to;
            // load a level
            //console.log("going to : ", to);
            if (this.fade && this.duration) {
                if (!this.fading) {
                    this.fading = true;
                    viewport.fadeIn(this.fade, this.duration,
                            this.onFadeComplete.bind(this));
                }
            } else {
                level.load(this.gotolevel, triggerSettings);
            }
        } else {
            throw new Error("Trigger invalid type");
        }
    }

    /**
     * onCollision callback, triggered in case of collision with this trigger
     * @name onCollision
     * @memberof Trigger
     * @param {ResponseObject} response the collision response object
     * @param {Renderable} other the other renderable touching this one (a reference to response.a or response.b)
     * @returns {boolean} true if the object should respond to the collision (its position and velocity will be corrected)
     */
    onCollision(response, other) { // eslint-disable-line no-unused-vars
        if (this.name === "Trigger") {
            this.triggerEvent.apply(this);
        }
        return false;
    }

}

/** @ignore */
function createGradient(light) {
    var context = light.texture.context;

    var x1 = light.texture.width / 2,
        y1 = light.texture.height / 2;

    var radiusX = light.radiusX,
        radiusY = light.radiusY;

    var scaleX, scaleY, invScaleX, invScaleY;
    var gradient;


    light.texture.clear();

    if (radiusX >= radiusY) {
        scaleX = 1;
        invScaleX = 1;
        scaleY = radiusY/radiusX;
        invScaleY = radiusX/radiusY;
        gradient = context.createRadialGradient(x1, y1 * invScaleY, 0, x1, radiusY * invScaleY, radiusX);
    }
    else {
        scaleY = 1;
        invScaleY = 1;
        scaleX = radiusX/radiusY;
        invScaleX = radiusY/radiusX;
        gradient = context.createRadialGradient(x1 * invScaleX, y1, 0, x1 * invScaleX, y1, radiusY);
    }

    gradient.addColorStop( 0, light.color.toRGBA(light.intensity));
    gradient.addColorStop( 1, light.color.toRGBA(0.0));

    context.fillStyle = gradient;

    context.setTransform(scaleX, 0, 0, scaleY, 0, 0);
    context.fillRect(0, 0, light.texture.width * invScaleX, light.texture.height * invScaleY);
}

/**
 * @classdesc
 * A 2D point light.
 * Note: this is a very experimental and work in progress feature, that provides a simple spot light effect.
 * The light effect is best rendered in WebGL, as they are few limitations when using the Canvas Renderer
 * (multiple lights are not supported, alpha component of the ambient light is ignored)
 * @see stage.lights
 */
class Light2d extends Renderable {
   /**
    * @param {number} x - The horizontal position of the light.
    * @param {number} y - The vertical position of the light.
    * @param {number} radiusX - The horizontal radius of the light.
    * @param {number} [radiusY=radiusX] - The vertical radius of the light.
    * @param {Color|string} [color="#FFF"] the color of the light
    * @param {number} [intensity=0.7] - The intensity of the light.
    */
    constructor(x, y, radiusX, radiusY = radiusX, color = "#FFF", intensity = 0.7) {
        // call the parent constructor
        super(x, y, radiusX * 2, radiusY * 2);

        /**
         * the color of the light
         * @type {Color}
         * @default "#FFF"
         */
        this.color = pool.pull("Color").parseCSS(color);

        /**
         * The horizontal radius of the light
         * @type {number}
         */
        this.radiusX = radiusX;

        /**
         * The vertical radius of the light
         * @type {number}
         */
        this.radiusY = radiusY;

        /**
         * The intensity of the light
         * @type {number}
         * @default 0.7
         */
        this.intensity = intensity;

        /**
         * the default blend mode to be applied when rendering this light
         * @type {string}
         * @default "lighter"
         * @see CanvasRenderer#setBlendMode
         * @see WebGLRenderer#setBlendMode
         */
        this.blendMode = "lighter";

        /** @ignore */
        this.visibleArea = pool.pull("Ellipse", this.centerX, this.centerY, this.width, this.height);

        /** @ignore */
        this.texture = pool.pull("CanvasTexture", this.width, this.height, { offscreenCanvas: false });

        this.anchorPoint.set(0, 0);

        createGradient(this);
    }

    /**
     * returns a geometry representing the visible area of this light
     * @name getVisibleArea
     * @memberof Light2d
     * @returns {Ellipse} the light visible mask
     */
    getVisibleArea() {
        return this.visibleArea.setShape(this.getBounds().centerX, this.getBounds().centerY, this.width, this.height);
    }

    /**
     * draw this Light2d (automatically called by melonJS)
     * @name draw
     * @memberof Light2d
     * @protected
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer instance
     * @param {Camera2d} [viewport] the viewport to (re)draw
     */
    draw(renderer, viewport) {   // eslint-disable-line no-unused-vars
        renderer.drawImage(this.texture.canvas, this.getBounds().x, this.getBounds().y);
    }

    /**
     * Destroy function<br>
     * @ignore
     */
    destroy() {
        pool.push(this.color);
        this.color = undefined;
        pool.push(this.texture);
        this.texture = undefined;
        pool.push(this.visibleArea);
        this.visibleArea = undefined;
        super.destroy();
    }
}

/**
 * @classdesc
 * A Draggable base object
 * @see DropTarget
 * @augments Renderable
 */
class Draggable extends Renderable {
    /**
     * @param {number} x the x coordinates of the draggable object
     * @param {number} y the y coordinates of the draggable object
     * @param {number} width draggable object width
     * @param {number} height draggable object height
     */
    constructor(x, y, width, height) {
        super(x, y, width, height);
        this.isKinematic = false;
        this.dragging = false;
        this.dragId = null;
        this.grabOffset = new Vector2d(0, 0);
        this.initEvents();
    }

    /**
     * Initializes the events the modules needs to listen to
     * It translates the pointer events to me.events
     * in order to make them pass through the system and to make
     * this module testable. Then we subscribe this module to the
     * transformed events.
     * @name initEvents
     * @memberof Draggable
     * @private
     */
    initEvents() {
        registerPointerEvent("pointerdown", this, (e) => { emit(DRAGSTART, e, this); });
        registerPointerEvent("pointerup", this,  (e) => { emit(DRAGEND, e, this); });
        registerPointerEvent("pointercancel", this, (e) => { emit(DRAGEND, e, this); });
        on(POINTERMOVE, this.dragMove.bind(this));
        on(DRAGSTART, (e, draggable) => {
            if (draggable === this) {
                this.dragStart(e);
            }
        });
        on(DRAGEND, (e, draggable) => {
            if (draggable === this) {
                this.dragEnd(e);
            }
        });
    }

    /**
     * Gets called when the user starts dragging the entity
     * @name dragStart
     * @memberof Draggable
     * @param {object} e the pointer event
     * @returns {boolean} false if the object is being dragged
     */
    dragStart(e) {
        if (this.dragging === false) {
            this.dragging = true;
            this.grabOffset.set(e.gameX, e.gameY);
            this.grabOffset.sub(this.pos);
            return false;
        }
    }

    /**
     * Gets called when the user drags this entity around
     * @name dragMove
     * @memberof Draggable
     * @param {object} e the pointer event
     */
    dragMove(e) {
        if (this.dragging === true) {
            this.pos.set(e.gameX, e.gameY, this.pos.z); //TODO : z ?
            this.pos.sub(this.grabOffset);
        }
    }

    /**
     * Gets called when the user stops dragging the entity
     * @name dragEnd
     * @memberof Draggable
     * @returns {boolean} false if the object stopped being dragged
     */
    dragEnd() {
        if (this.dragging === true) {
            this.dragging = false;
            return false;
        }
    }

    /**
     * Destructor
     * @name destroy
     * @memberof Draggable
     * @ignore
     */
    destroy() {
        off(POINTERMOVE, this.dragMove);
        off(DRAGSTART, this.dragStart);
        off(DRAGEND, this.dragEnd);
        releasePointerEvent("pointerdown", this);
        releasePointerEvent("pointerup", this);
        releasePointerEvent("pointercancel", this);
        super.destroy();
    }
}
/**
 * @classdesc
 * a base drop target object
 * @see Draggable
 * @augments Renderable
 */
class DropTarget extends Renderable {
    /**
     * @param {number} x the x coordinates of the drop target
     * @param {number} y the y coordinates of the drop target
     * @param {number} width drop target width
     * @param {number} height drop target height
     */
    constructor(x, y, width, height) {
        super(x, y, width, height);

        this.isKinematic = false;

        /**
         * constant for the overlaps method
         * @public
         * @constant
         * @type {string}
         * @name CHECKMETHOD_OVERLAP
         * @memberof DropTarget
         */
        this.CHECKMETHOD_OVERLAP = "overlaps";

        /**
         * constant for the contains method
         * @public
         * @constant
         * @type {string}
         * @name CHECKMETHOD_CONTAINS
         * @memberof DropTarget
         */
        this.CHECKMETHOD_CONTAINS = "contains";

        /**
         * the checkmethod we want to use
         * @public
         * @constant
         * @type {string}
         * @name checkMethod
         * @default "overlaps"
         * @memberof DropTarget
         */
        this.checkMethod = this.CHECKMETHOD_OVERLAP;

        on(DRAGEND, this.checkOnMe, this);

    }

    /**
     * Sets the collision method which is going to be used to check a valid drop
     * @name setCheckMethod
     * @memberof DropTarget
     * @param {string} checkMethod the checkmethod (defaults to CHECKMETHOD_OVERLAP)
     */
    setCheckMethod(checkMethod) {
        //  We can improve this check,
        //  because now you can use every method in theory
        if (typeof(this.getBounds()[this.checkMethod]) === "function") {
            this.checkMethod = checkMethod;
        }
    }

    /**
     * Checks if a dropped entity is dropped on the current entity
     * @name checkOnMe
     * @memberof DropTarget
     * @param {object} e the triggering event
     * @param {Draggable} draggable the draggable object that is dropped
     */
    checkOnMe(e, draggable) {
        if (draggable && this.getBounds()[this.checkMethod](draggable.getBounds())) {
            // call the drop method on the current entity
            this.drop(draggable);
        }
    }

    /**
     * Gets called when a draggable entity is dropped on the current entity
     * @name drop
     * @memberof DropTarget
     * @param {Draggable} draggable the draggable object that is dropped
     */
    drop(draggable) {  // eslint-disable-line no-unused-vars

    }

    /**
     * Destructor
     * @name destroy
     * @memberof DropTarget
     * @ignore
     */
    destroy() {
        off(DRAGEND, this.checkOnMe);
        super.destroy();
    }
}

/**
 * ParticleEmitterSettings contains the default settings for ParticleEmitter
 * @see ParticleEmitter
 * @namespace ParticleEmitterSettings
 */
const ParticleEmitterSettings = {
    /**
     * Width of the particle spawn area.
     * @type {number}
     * @name width
     * @memberof ParticleEmitterSettings
     * @default 1
     */
    width : 1,

    /**
     * Height of the particle spawn area
     * @public
     * @type {number}
     * @name height
     * @memberof ParticleEmitterSettings
     * @default 1
     */
    height : 1,

    /**
     * image used for particles texture
     * (by default melonJS will create an white 8x8 texture image)
     * @public
     * @type {HTMLCanvasElement}
     * @name image
     * @memberof ParticleEmitterSettings
     * @default undefined
     * @see ParticleEmitterSettings.textureSize
     */
    image : undefined,

    /**
     * default texture size used for particles if no image is specified
     * (by default melonJS will create an white 8x8 texture image)
     * @public
     * @type {number}
     * @name textureSize
     * @memberof ParticleEmitterSettings
     * @default 8
     * @see ParticleEmitterSettings.image
     */
    textureSize : 8,

    /**
     * tint to be applied to particles
     * @public
     * @type {string}
     * @name tint
     * @memberof ParticleEmitterSettings
     * @default "#fff"
     */
    tint : "#fff",

    /**
     * Total number of particles in the emitter
     * @public
     * @type {number}
     * @name totalParticles
     * @default 50
     * @memberof ParticleEmitterSettings
     */
    totalParticles : 50,

    /**
     * Start angle for particle launch in Radians
     * @public
     * @type {number}
     * @name angle
     * @default Math.PI / 2
     * @memberof ParticleEmitterSettings
     */
    angle : Math.PI / 2,

    /**
     * Variation in the start angle for particle launch in Radians.
     * @public
     * @type {number}
     * @name angleVariation
     * @default 0
     * @memberof ParticleEmitterSettings
     */
    angleVariation : 0,

    /**
     * Minimum time each particle lives once it is emitted in ms.
     * @public
     * @type {number}
     * @name minLife
     * @default 1000
     * @memberof ParticleEmitterSettings
     */
    minLife : 1000,

    /**
     * Maximum time each particle lives once it is emitted in ms.
     * @public
     * @type {number}
     * @name maxLife
     * @default 3000
     * @memberof ParticleEmitterSettings
     */
    maxLife : 3000,

    /**
     * Start speed of particles.<br>
     * @public
     * @type {number}
     * @name speed
     * @default 2
     * @memberof ParticleEmitterSettings
     */
    speed : 2,

    /**
     * Variation in the start speed of particles
     * @public
     * @type {number}
     * @name speedVariation
     * @default 1
     * @memberof ParticleEmitterSettings
     */
    speedVariation : 1,

    /**
     * Minimum start rotation for particles sprites in Radians
     * @public
     * @type {number}
     * @name minRotation
     * @default 0
     * @memberof ParticleEmitterSettings
     */
    minRotation : 0,

    /**
     * Maximum start rotation for particles sprites in Radians
     * @public
     * @type {number}
     * @name maxRotation
     * @default 0
     * @memberof ParticleEmitterSettings
     */
    maxRotation : 0,

    /**
     * Minimum start scale ratio for particles (1 = no scaling)
     * @public
     * @type {number}
     * @name minStartScale
     * @default 1
     * @memberof ParticleEmitterSettings
     */
    minStartScale : 1,

    /**
     * Maximum start scale ratio for particles (1 = no scaling)
     * @public
     * @type {number}
     * @name maxStartScale
     * @default 1
     * @memberof ParticleEmitterSettings
     */
    maxStartScale : 1,

    /**
     * Minimum end scale ratio for particles
     * @public
     * @type {number}
     * @name minEndScale
     * @default 0
     * @memberof ParticleEmitterSettings
     */
    minEndScale : 0,

    /**
     * Maximum end scale ratio for particles
     * @public
     * @type {number}
     * @name maxEndScale
     * @default 0
     * @memberof ParticleEmitterSettings
     */
    maxEndScale : 0,

    /**
     * Vertical force (Gravity) for each particle
     * @public
     * @type {number}
     * @name gravity
     * @default 0
     * @memberof ParticleEmitterSettings
     * @see game.world.gravity
     */
    gravity : 0,

    /**
     * Horizontal force (like a Wind) for each particle
     * @public
     * @type {number}
     * @name wind
     * @default 0
     * @memberof ParticleEmitterSettings
     */
    wind : 0,

    /**
     * Update the rotation of particle in accordance the particle trajectory.<br>
     * The particle sprite should aim at zero angle (draw from left to right).<br>
     * Override the particle minRotation and maxRotation.<br>
     * @public
     * @type {boolean}
     * @name followTrajectory
     * @default false
     * @memberof ParticleEmitterSettings
     */
    followTrajectory : false,

    /**
     * Enable the Texture Additive by composite operation ("additive" blendMode)
     * @public
     * @type {boolean}
     * @name textureAdditive
     * @default false
     * @memberof ParticleEmitterSettings
     * @see ParticleEmitterSettings.blendMode
     */
    textureAdditive : false,

    /**
     * the blend mode to be applied when rendering particles.
     * (note: this will superseed the `textureAdditive` setting if different than "normal")
     * @public
     * @type {string}
     * @name blendMode
     * @default normal
     * @memberof ParticleEmitterSettings
     * @see CanvasRenderer#setBlendMode
     * @see WebGLRenderer#setBlendMode
     */
    blendMode : "normal",

    /**
     * Update particles only in the viewport, remove it when out of viewport.
     * @public
     * @type {boolean}
     * @name onlyInViewport
     * @default true
     * @memberof ParticleEmitterSettings
     */
    onlyInViewport : true,

    /**
     * Render particles in screen space.
     * @public
     * @type {boolean}
     * @name floating
     * @default false
     * @memberof ParticleEmitterSettings
     */
    floating : false,

    /**
     * Maximum number of particles launched each time in this emitter (used only if emitter is Stream).
     * @public
     * @type {number}
     * @name maxParticles
     * @default 10
     * @memberof ParticleEmitterSettings
     */
    maxParticles : 10,

    /**
     * How often a particle is emitted in ms (used only if emitter is a Stream).
     * @public
     * @type {number}
     * @name frequency
     * @default 100
     * @memberof ParticleEmitterSettings
     */
    frequency : 100,

    /**
     * Duration that the emitter releases particles in ms (used only if emitter is Stream).
     * After this period, the emitter stop the launch of particles.
     * @public
     * @type {number}
     * @name duration
     * @default Infinity
     * @memberof ParticleEmitterSettings
     */
    duration : Infinity,

    /**
     * Skip n frames after updating the particle system once.
     * This can be used to reduce the performance impact of emitters with many particles.
     * @public
     * @type {number}
     * @name framesToSkip
     * @default 0
     * @memberof ParticleEmitterSettings
     */
    framesToSkip : 0
};

/**
 * @ignore
 */
function createDefaultParticleTexture(w = 8, h = 8) {
    var defaultParticleTexture = pool.pull("CanvasTexture", w, h, { offscreenCanvas: true });

    defaultParticleTexture.context.fillStyle = "#fff";
    defaultParticleTexture.context.fillRect(0, 0, w, h);

    return defaultParticleTexture;
}
/**
 * @classdesc
 * Particle Emitter Object.
 * @augments Container
 */
class ParticleEmitter extends Container {
    /**
     * @param {number} x x position of the particle emitter
     * @param {number} y y position of the particle emitter
     * @param {ParticleEmitterSettings} [settings=ParticleEmitterSettings] the settings for the particle emitter.
     * @example
     * // Create a particle emitter at position 100, 100
     * var emitter = new ParticleEmitter(100, 100, {
     *     width: 16,
     *     height : 16,
     *     tint: "#f00",
     *     totalParticles: 32,
     *     angle: 0,
     *     angleVariation: 6.283185307179586,
     *     maxLife: 5,
     *     speed: 3
     * });
     *
     * // Add the emitter to the game world
     * me.game.world.addChild(emitter);
     *
     * // Launch all particles one time and stop, like a explosion
     * emitter.burstParticles();
     *
     * // Launch constantly the particles, like a fountain
     * emitter.streamParticles();
     *
     * // At the end, remove emitter from the game world
     * // call this in onDestroyEvent function
     * me.game.world.removeChild(emitter);
     */
    constructor(x, y, settings = {}) {
        // call the super constructor
        super(
            x, y,
            settings.width | 1,
            settings.height | 1
        );

        /**
         * the current (active) emitter settings
         * @public
         * @type {ParticleEmitterSettings}
         * @name settings
         * @memberof ParticleEmitter
         */
        this.settings = {};

        // center the emitter around the given coordinates
        this.centerOn(x, y);

        // Emitter is Stream, launch particles constantly
        /** @ignore */
        this._stream = false;

        // Frequency timer (in ms) for emitter launch new particles
        // used only in stream emitter
        /** @ignore */
        this._frequencyTimer = 0;

        // Time of live (in ms) for emitter launch new particles
        // used only in stream emitter
        /** @ignore */
        this._durationTimer = 0;

        // Emitter is emitting particles
        /** @ignore */
        this._enabled = false;

        // Emitter will always update
        this.alwaysUpdate = true;

        // don't sort the particles by z-index
        this.autoSort = false;

        // count the updates
        this._updateCount = 0;

        // internally store how much time was skipped when frames are skipped
        this._dt = 0;

        //this.anchorPoint.set(0, 0);

        // Reset the emitter to defaults
        this.reset(settings);
    }

    /**
     * Reset the emitter with particle emitter settings.
     * @param {ParticleEmitterSettings} settings [optional] object with emitter settings. See {@link ParticleEmitterSettings}
     */
    reset(settings = {}) {
        Object.assign(this.settings, ParticleEmitterSettings, settings);

        if (typeof this.settings.image === "undefined") {
            this._defaultParticle = createDefaultParticleTexture(settings.textureSize, settings.textureSize);
            this.settings.image = this._defaultParticle.canvas;
        }

        this.floating = this.settings.floating;

        this.isDirty = true;
    }

    /**
     * returns a random point on the x axis within the bounds of this emitter
     * @returns {number}
     */
    getRandomPointX() {
        return randomFloat(0, this.getBounds().width);
    }

    /**
     * returns a random point on the y axis within the bounds this emitter
     * @returns {number}
     */
    getRandomPointY() {
        return randomFloat(0, this.getBounds().height);
    }

    // Add count particles in the game world
    /** @ignore */
    addParticles(count) {
        for (var i = 0; i < count; i++) {
            // Add particle to the container
            this.addChild(pool.pull("Particle", this), this.pos.z);
        }
        this.isDirty = true;
    }

    /**
     * Emitter is of type stream and is launching particles
     * @returns {boolean} Emitter is Stream and is launching particles
     */
    isRunning() {
        return this._enabled && this._stream;
    }

    /**
     * Launch particles from emitter constantly (e.g. for stream)
     * @param {number} duration [optional] time that the emitter releases particles in ms
     */
    streamParticles(duration) {
        this._enabled = true;
        this._stream = true;
        this.settings.frequency = Math.max(1, this.settings.frequency);
        this._durationTimer = (typeof duration === "number") ? duration : this.settings.duration;
    }

    /**
     * Stop the emitter from generating new particles (used only if emitter is Stream)
     */
    stopStream() {
        this._enabled = false;
    }

    /**
     * Launch all particles from emitter and stop (e.g. for explosion)
     * @param {number} total [optional] number of particles to launch
     */
    burstParticles(total) {
        this._enabled = true;
        this._stream = false;
        this.addParticles((typeof total === "number") ? total : this.settings.totalParticles);
        this._enabled = false;
    }

    /**
     * @ignore
     */
    update(dt) {
        // skip frames if necessary
        if (++this._updateCount > this.settings.framesToSkip) {
            this._updateCount = 0;
        }
        if (this._updateCount > 0) {
            this._dt += dt;
            return this.isDirty;
        }

        // apply skipped delta time
        dt += this._dt;
        this._dt = 0;

        // Update particles
        this.isDirty |= super.update(dt);

        // Launch new particles, if emitter is Stream
        if ((this._enabled) && (this._stream)) {
            // Check if the emitter has duration set
            if (this._durationTimer !== Infinity) {
                this._durationTimer -= dt;

                if (this._durationTimer <= 0) {
                    this.stopStream();
                    return this.isDirty;
                }
            }

            // Increase the emitter launcher timer
            this._frequencyTimer += dt;

            // Check for new particles launch
            var particlesCount = this.children.length;
            if ((particlesCount < this.settings.totalParticles) && (this._frequencyTimer >= this.settings.frequency)) {
                if ((particlesCount + this.settings.maxParticles) <= this.settings.totalParticles) {
                    this.addParticles(this.settings.maxParticles);
                }
                else {
                    this.addParticles(this.settings.totalParticles - particlesCount);
                }
                this._frequencyTimer = 0;
                this.isDirty = true;
            }
        }
        return this.isDirty;
    }

    /**
     * Destroy function
     * @ignore
     */
    destroy() {
        // call the parent destroy method
        super.destroy(arguments);
        // clean emitter specific Properties
        if (typeof this._defaultParticle !== "undefined") {
            pool.push(this._defaultParticle);
            this._defaultParticle = undefined;
        }
        this.settings.image = undefined;
        this.settings = undefined;
    }
}

/**
 * @classdesc
 * Single Particle Object.
 * @augments Renderable
 */
class Particle extends Renderable {
    /**
     * @param {ParticleEmitter} emitter the particle emitter
     */
    constructor(emitter) {
        // Call the super constructor
        super(
            emitter.getRandomPointX(),
            emitter.getRandomPointY(),
            emitter.settings.image.width,
            emitter.settings.image.height
        );
        this.onResetEvent(emitter, true);
    }

    /**
     * @ignore
     */
    onResetEvent(emitter, newInstance = false) {
        if (newInstance === false) {
            this.pos.set(
                emitter.getRandomPointX(),
                emitter.getRandomPointY()
            );
            this.resize(
                emitter.settings.image.width,
                emitter.settings.image.height
            );
            this.currentTransform.identity();
        } else {
            // particle velocity
            this.vel = pool.pull("Vector2d");
        }

        this.image = emitter.settings.image;

        // Particle will always update
        this.alwaysUpdate = true;

        if (typeof emitter.settings.tint === "string") {
            this.tint.parseCSS(emitter.settings.tint);
        }

        if (emitter.settings.textureAdditive === true) {
            this.blendMode = "additive";
        }

        if (emitter.settings.blendMode !== "normal") {
            this.blendMode = emitter.settings.blendMode;
        }

        // Set the start particle Angle and Speed as defined in emitter
        var angle = emitter.settings.angle + ((emitter.settings.angleVariation > 0) ? (randomFloat(0, 2) - 1) * emitter.settings.angleVariation : 0);
        var speed = emitter.settings.speed + ((emitter.settings.speedVariation > 0) ? (randomFloat(0, 2) - 1) * emitter.settings.speedVariation : 0);

        // Set the start particle Velocity
        this.vel.set(speed * Math.cos(angle), -speed * Math.sin(angle));

        // Set the start particle Time of Life as defined in emitter
        this.life = randomFloat(emitter.settings.minLife, emitter.settings.maxLife);
        this.startLife = this.life;

        // Set the start and end particle Scale as defined in emitter
        // clamp the values as minimum and maximum scales range
        this.startScale = clamp(
            randomFloat(emitter.settings.minStartScale, emitter.settings.maxStartScale),
            emitter.settings.minStartScale,
            emitter.settings.maxStartScale
        );
        this.endScale = clamp(
            randomFloat(emitter.settings.minEndScale, emitter.settings.maxEndScale),
            emitter.settings.minEndScale,
            emitter.settings.maxEndScale
        );

        // Set the particle Gravity and Wind (horizontal gravity) as defined in emitter
        this.gravity = emitter.settings.gravity;
        this.wind = emitter.settings.wind;

        // Set if the particle update the rotation in accordance the trajectory
        this.followTrajectory = emitter.settings.followTrajectory;

        // Set if the particle update only in Viewport
        this.onlyInViewport = emitter.settings.onlyInViewport;

        // cache inverse of the expected delta time
        this._deltaInv = timer.maxfps / 1000;

        // Set the start particle rotation as defined in emitter
        // if the particle not follow trajectory
        if (!emitter.settings.followTrajectory) {
            this.angle = randomFloat(emitter.settings.minRotation, emitter.settings.maxRotation);
        }
    }

    /**
     * Update the Particle <br>
     * This is automatically called by the game manager {@link game}
     * @ignore
     * @param {number} dt time since the last update in milliseconds
     */
    update(dt) {
        // move things forward independent of the current frame rate
        var skew = dt * this._deltaInv;

        // Decrease particle life
        this.life = this.life > dt ? this.life - dt : 0;

        if (this.life <= 0) {
            this.ancestor.removeChild(this);
            return false;
        }

        // Calculate the particle Age Ratio
        var ageRatio = this.life / this.startLife;

        // Resize the particle as particle Age Ratio
        var scale = this.startScale;
        if (this.startScale > this.endScale) {
            scale *= ageRatio;
            scale = (scale < this.endScale) ? this.endScale : scale;
        }
        else if (this.startScale < this.endScale) {
            scale /= ageRatio;
            scale = (scale > this.endScale) ? this.endScale : scale;
        }

        // Set the particle opacity as Age Ratio
        this.alpha = ageRatio;

        // Adjust the particle velocity
        this.vel.x += this.wind * skew;
        this.vel.y += this.gravity * skew;

        // If necessary update the rotation of particle in accordance the particle trajectory
        var angle = this.followTrajectory ? Math.atan2(this.vel.y, this.vel.x) : this.angle;

        this.pos.x += this.vel.x * skew;
        this.pos.y += this.vel.y * skew;

        // Update particle transform
        this.currentTransform.setTransform(
            scale, 0, 0,
            0, scale, 0,
            this.pos.x, this.pos.y, 1
        ).rotate(angle);

        // mark as dirty if the particle is not dead yet
        this.isDirty = this.inViewport || !this.onlyInViewport;

        return super.update(dt);
    }

    /**
     * @ignore
     */
    draw(renderer) {
        var w = this.width, h = this.height;
        renderer.drawImage(
            this.image,
            0, 0,
            w, h,
            -w / 2, -h / 2,
            w, h
        );
    }
}

/**
 * @classdesc
 * a Generic Object Entity
 * @augments Renderable
 * @see Renderable
 */
class Entity extends Renderable {
    /**
     * @param {number} x the x coordinates of the entity object
     * @param {number} y the y coordinates of the entity object
     * @param {object} settings Entity properties, to be defined through Tiled or when calling the entity constructor
     * <img src="images/object_properties.png"/>
     * @param {number} settings.width the physical width the entity takes up in game
     * @param {number} settings.height the physical height the entity takes up in game
     * @param {string} [settings.name] object entity name
     * @param {string} [settings.id] object unique IDs
     * @param {Image|string} [settings.image] resource name of a spritesheet to use for the entity renderable component
     * @param {Vector2d} [settings.anchorPoint=0.0] Entity anchor point
     * @param {number} [settings.framewidth=settings.width] width of a single frame in the given spritesheet
     * @param {number} [settings.frameheight=settings.width] height of a single frame in the given spritesheet
     * @param {string} [settings.type] object type
     * @param {number} [settings.collisionMask] Mask collision detection for this object
     * @param {Rect[]|Polygon[]|Line[]|Ellipse[]} [settings.shapes] the initial list of collision shapes (usually populated through Tiled)
     */
    constructor(x, y, settings) {

        // ensure mandatory properties are defined
        if ((typeof settings.width !== "number") || (typeof settings.height !== "number")) {
            throw new Error("height and width properties are mandatory when passing settings parameters to an object entity");
        }

        // call the super constructor
        super(x, y, settings.width, settings.height);

        /**
         * The array of renderable children of this entity.
         * @ignore
         */
        this.children = [];

        if (settings.image) {
            // set the frame size to the given entity size, if not defined in settings
            settings.framewidth = settings.framewidth || settings.width;
            settings.frameheight = settings.frameheight || settings.height;
            this.renderable = new Sprite(0, 0, settings);
        }

        // Update anchorPoint
        if (settings.anchorPoint) {
            this.anchorPoint.set(settings.anchorPoint.x, settings.anchorPoint.y);
        } else {
            // for backward compatibility
            this.anchorPoint.set(0, 0);
        }

        // set the sprite name if specified
        if (typeof (settings.name) === "string") {
            this.name = settings.name;
        }

        /**
         * object type (as defined in Tiled)
         * @public
         * @type {string}
         * @name type
         * @memberof Entity
         */
        this.type = settings.type || "";

        /**
         * object unique ID (as defined in Tiled)
         * @public
         * @type {number}
         * @name id
         * @memberof Entity
         */
        this.id = settings.id || "";

        /**
         * dead/living state of the entity<br>
         * default value : true
         * @public
         * @type {boolean}
         * @name alive
         * @memberof Entity
         */
        this.alive = true;

        /**
         * the entity body object
         * @public
         * @member {Body}
         * @name body
         * @memberof Entity
         */
        // initialize the default body
        if (typeof settings.shapes === "undefined") {
            settings.shapes = pool.pull("Polygon", 0, 0, [
                pool.pull("Vector2d", 0,          0),
                pool.pull("Vector2d", this.width, 0),
                pool.pull("Vector2d", this.width, this.height),
                pool.pull("Vector2d", 0,          this.height)
            ]);
        }
        this.body = new Body(this, settings.shapes, this.onBodyUpdate.bind(this));

        // resize the entity if required
        if (this.width === 0 && this.height === 0) {
            this.resize(this.body.getBounds().width, this.body.getBounds().height);
        }

        // set the  collision mask and type (if defined)
        this.body.setCollisionMask(settings.collisionMask);
        this.body.setCollisionType(settings.collisionType);

        // disable for entities
        this.autoTransform = false;
    }


    /**
     * The entity renderable component (can be any objects deriving from me.Renderable, like me.Sprite for example)
     * @public
     * @type {Renderable}
     * @name renderable
     * @memberof Entity
     */

    get renderable() {
        return this.children[0];
    }

    set renderable(value) {
        if (value instanceof Renderable) {
            this.children[0] = value;
            this.children[0].ancestor = this;
        } else {
            throw new Error(value + "should extend me.Renderable");
        }
    }

    /** @ignore */
    update(dt) {
        if (this.renderable) {
            this.isDirty |= this.renderable.update(dt);
        }
        return super.update(dt);
    }

    /**
     * update the bounds position when the body is modified
     * @ignore
     * @name onBodyUpdate
     * @memberof Entity
     * @param {Body} body the body whose bounds to update
     */
    onBodyUpdate(body) {
        // update the entity bounds to include the body bounds
        this.getBounds().addBounds(body.getBounds(), true);
        // update the bounds pos
        this.updateBoundsPos(this.pos.x, this.pos.y);
    }

    preDraw(renderer) {
        renderer.save();

        // translate to the entity position
        renderer.translate(
            this.pos.x + this.body.getBounds().x,
            this.pos.y + this.body.getBounds().y
        );

        if (this.renderable instanceof Renderable) {
            // draw the child renderable's anchorPoint at the entity's
            // anchor point.  the entity's anchor point is a scale from
            // body position to body width/height
            renderer.translate(
                this.anchorPoint.x * this.body.getBounds().width,
                this.anchorPoint.y * this.body.getBounds().height
            );
        }
    }

    /**
     * draw this entity (automatically called by melonJS)
     * @name draw
     * @memberof Entity
     * @protected
     * @param {CanvasRenderer|WebGLRenderer} renderer a renderer instance
     * @param {Camera2d} [viewport] the viewport to (re)draw
     */
    draw(renderer, viewport) {
        var renderable = this.renderable;
        if (renderable instanceof Renderable) {
            // predraw (apply transforms)
            renderable.preDraw(renderer);

            // draw the object
            renderable.draw(renderer, viewport);

            // postdraw (clean-up);
            renderable.postDraw(renderer);
        }
    }

    /**
     * Destroy function<br>
     * @ignore
     */
    destroy() {
        // free some property objects
        if (this.renderable) {
            this.renderable.destroy.apply(this.renderable, arguments);
            this.children.splice(0, 1);
        }

        // call the parent destroy method
        super.destroy(arguments);
    }

    /**
     * onDeactivateEvent Notification function<br>
     * Called by engine before deleting the object
     * @name onDeactivateEvent
     * @memberof Entity
     */
    onDeactivateEvent() {
        if (this.renderable && this.renderable.onDeactivateEvent) {
            this.renderable.onDeactivateEvent();
        }
    }

}

/*
 * placeholder for all deprecated classes and corresponding alias for backward compatibility
 */

/**
 * display a deprecation warning in the console
 * @ignore
 * @param {string} deprecated deprecated class,function or property name
 * @param {string} replacement the replacement class, function, or property name
 * @param {string} version the version since when the lass,function or property is deprecated
 */
function warning(deprecated, replacement, version) {
    var msg = "melonJS: %s is deprecated since version %s, please use %s";
    var stack = new Error().stack;

    if (console.groupCollapsed) {
        console.groupCollapsed(
            "%c" + msg,
            "font-weight:normal;color:yellow;",
            deprecated,
            version,
            replacement
        );
    } else {
        console.warn(
            msg,
            deprecated,
            version,
            replacement
        );
    }

    if (typeof stack !== "undefined") {
        console.warn(stack);
    }

    if (console.groupCollapsed) {
        console.groupEnd();
    }
}
/**
 * @public
 * @name turnOnPointerLock
 * @returns {boolean} return true if the request was successfully submitted
 * @memberof device#
 * @deprecated since 10.3.0
 * @see input.requestPointerLock
 */
device.turnOnPointerLock = function () {
    warning("device.turnOnPointerLock()", "input.requestPointerLock()", "10.3.0");
    return requestPointerLock();
};

/**
 * @public
 * @name turnOffPointerLock
 * @returns {boolean} return true if the request was successfully submitted
 * @memberof device#
 * @deprecated since 10.3.0
 * @see input.exitPointerLock
 */
device.turnOffPointerLock = function () {
    warning("device.turnOffPointerLock()", "input.exitPointerLock()", "10.3.0");
    return exitPointerLock();
};

/**
 * Alias of {@link TextureAtlas}
 *
 * @public
 * @name Texture
 * @class
 * @memberof Renderer#
 * @deprecated since 10.4.0
 * @see TextureAtlas
 */
Object.defineProperty(Renderer.prototype, "Texture", {
    /**
     * @ignore
     */
    get : function () {
        warning("me.video.renderer.Texture", "me.TextureAtlas", "10.4.0");
        return TextureAtlas;
    }
});


/**
 * @classdesc
 * Used to make a game entity draggable
 * @augments Entity
 * @deprecated since 10.5.0
 * @see Draggable
 */
class DraggableEntity extends Draggable {
    /**
     * @param {number} x the x coordinates of the draggable object
     * @param {number} y the y coordinates of the draggable object
     * @param {object} settings Entity properties (see {@link Entity})
     */
    constructor(x, y, settings) {
        warning("DraggableEntity", "Draggable", "10.5.0");
        super(x, y, settings.width, settings.height);
    }
}

/**
 * @classdesc
 * Used to make a game entity a droptarget
 * @augments Entity
 * @deprecated since 10.5.0
 * @see DropTarget
 */
class DroptargetEntity extends DropTarget {
    /**
     * @param {number} x the x coordinates of the draggable object
     * @param {number} y the y coordinates of the draggable object
     * @param {object} settings Entity properties (see {@link Entity})
     */
    constructor(x, y, settings) {
        warning("DroptargetEntity", "DropTarget", "10.5.0");
        super(x, y, settings.width, settings.height);
    }
}

// ES5/ES6 polyfills


/**
 * current melonJS version
 * @static
 * @constant
 * @name version
 * @type {string}
 */
const version = "12.0.0";


/**
 * a flag indicating that melonJS is fully initialized
 * @type {boolean}
 * @default false
 * @readonly
 */
var initialized = false;

/**
 * disable melonJS auto-initialization
 * @type {boolean}
 * @default false
 * @see boot
 */
var skipAutoInit = false;

/**
 * initialize the melonJS library.
 * this is automatically called unless me.skipAutoInit is set to true,
 * to allow asynchronous loaders to work.
 * @name boot
 * @see skipAutoInit
 * @public
 */
function boot() {
    // don't do anything if already initialized (should not happen anyway)
    if (initialized === true) {
        return;
    }

    // register all built-ins objects into the object pool
    pool.register("me.Entity", Entity);
    pool.register("me.Collectable", Collectable);
    pool.register("me.Trigger", Trigger);
    pool.register("me.Light2d", Light2d);
    pool.register("me.Tween", Tween, true);
    pool.register("me.Color", Color, true);
    pool.register("me.Particle", Particle, true);
    pool.register("me.Sprite", Sprite);
    pool.register("me.NineSliceSprite", NineSliceSprite);
    pool.register("me.Renderable", Renderable);
    pool.register("me.Text", Text, true);
    pool.register("me.BitmapText", BitmapText);
    pool.register("me.BitmapTextData", BitmapTextData, true);
    pool.register("me.ImageLayer", ImageLayer);
    pool.register("me.ColorLayer", ColorLayer, true);
    pool.register("me.Vector2d", Vector2d, true);
    pool.register("me.Vector3d", Vector3d, true);
    pool.register("me.ObservableVector2d", ObservableVector2d, true);
    pool.register("me.ObservableVector3d", ObservableVector3d, true);
    pool.register("me.Matrix2d", Matrix2d, true);
    pool.register("me.Matrix3d", Matrix3d, true);
    pool.register("me.Rect", Rect, true);
    pool.register("me.RoundRect", RoundRect, true);
    pool.register("me.Polygon", Polygon, true);
    pool.register("me.Line", Line, true);
    pool.register("me.Ellipse", Ellipse, true);
    pool.register("me.Bounds", Bounds, true);

    // duplicate all entries if use with no namespace (e.g. es6)
    pool.register("Entity", Entity);
    pool.register("Collectable", Collectable);
    pool.register("Trigger", Trigger);
    pool.register("Light2d", Light2d);
    pool.register("Tween", Tween, true);
    pool.register("Color", Color, true);
    pool.register("Particle", Particle, true);
    pool.register("Sprite", Sprite);
    pool.register("NineSliceSprite", NineSliceSprite);
    pool.register("Renderable", Renderable);
    pool.register("Text", Text, true);
    pool.register("BitmapText", BitmapText);
    pool.register("BitmapTextData", BitmapTextData, true);
    pool.register("ImageLayer", ImageLayer);
    pool.register("ColorLayer", ColorLayer, true);
    pool.register("Vector2d", Vector2d, true);
    pool.register("Vector3d", Vector3d, true);
    pool.register("ObservableVector2d", ObservableVector2d, true);
    pool.register("ObservableVector3d", ObservableVector3d, true);
    pool.register("Matrix2d", Matrix2d, true);
    pool.register("Matrix3d", Matrix3d, true);
    pool.register("Rect", Rect, true);
    pool.register("RoundRect", RoundRect, true);
    pool.register("Polygon", Polygon, true);
    pool.register("Line", Line, true);
    pool.register("Ellipse", Ellipse, true);
    pool.register("Bounds", Bounds, true);
    pool.register("CanvasTexture", CanvasTexture, true);

    // publish Boot notification
    emit(BOOT);

    // enable/disable the cache
    loader.setNocache( utils.getUriFragment().nocache || false );

    // automatically enable keyboard events
    initKeyboardEvent();

    // mark melonJS as initialized
    initialized = true;
}
// call the library init function when ready
device.onReady(function () {
    {
       boot();
    }
});

export { BitmapText, BitmapTextData, Body, Bounds, Camera2d, CanvasRenderer, Collectable, Color, ColorLayer, Container, Draggable, DraggableEntity, DropTarget, DroptargetEntity, Ellipse, Entity, GLShader, GUI_Object, ImageLayer, Light2d, Line, math as Math, Matrix2d, Matrix3d, NineSliceSprite, ObservableVector2d, ObservableVector3d, Particle, ParticleEmitter, ParticleEmitterSettings, Pointer, Polygon, QuadTree, Rect, Renderable, Renderer, RoundRect, Sprite, Stage, TMXHexagonalRenderer, TMXIsometricRenderer, TMXLayer, TMXOrthogonalRenderer, TMXRenderer, TMXStaggeredRenderer, TMXTileMap, TMXTileset, TMXTilesetGroup, Text, TextureAtlas, Tile, Trigger, Tween, Vector2d, Vector3d, WebGLCompositor, WebGLRenderer, World, audio, boot, collision, device, event, game, initialized, input, level, loader, plugin, plugins, pool, save, skipAutoInit, state, timer, utils, version, video, warning };
